import * as i0 from '@angular/core';
import { inject, ChangeDetectorRef, Input, Component, Injectable, InjectionToken, Injector, NgModuleFactory, Compiler, PLATFORM_ID, makeStateKey, TransferState, REQUEST, NgZone, signal, computed, effect, LOCALE_ID, ComponentFactoryResolver, ApplicationRef, isDevMode, input, ElementRef, Directive, EventEmitter, Output, TemplateRef, ViewContainerRef, IterableDiffers, HostListener, provideAppInitializer, makeEnvironmentProviders, Pipe, SecurityContext, NgModule } from '@angular/core';
import { of, BehaviorSubject, Subject, firstValueFrom, throwError, timeout, lastValueFrom, Observable, timer, pipe, concat, ReplaySubject, EMPTY, map as map$1, Subscription, combineLatest, from, take as take$1, filter as filter$1, fromEvent, switchMap as switchMap$1, startWith, distinctUntilChanged as distinctUntilChanged$1 } from 'rxjs';
import { PRIMARY_OUTLET, Router, NavigationStart, NavigationError, NavigationEnd, NavigationCancel, TitleStrategy, ActivatedRoute, RouterOutlet, RouterModule } from '@angular/router';
import { isPlatformBrowser, DOCUMENT, registerLocaleData, NgComponentOutlet, isPlatformServer, DatePipe, DATE_PIPE_DEFAULT_TIMEZONE, CommonModule } from '@angular/common';
import { map, distinctUntilChanged, filter, catchError, tap, take, switchMap, mapTo, takeUntil, delay, retryWhen, shareReplay, debounceTime, finalize } from 'rxjs/operators';
import { HttpClient, HttpContextToken, HttpErrorResponse, HttpContext, HttpParams, HttpHeaders, HttpResponse, provideHttpClient, withInterceptorsFromDi, withXsrfConfiguration, withFetch, withInterceptors } from '@angular/common/http';
import compare from 'just-compare';
import clone from 'just-clone';
import { NgxValidateCoreModule } from '@ngx-validate/core';
export { NgxValidateCoreModule } from '@ngx-validate/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { Title, DomSanitizer } from '@angular/platform-browser';
import { DateTime } from 'luxon';
import { FormGroupDirective, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';

// Not an abstract class on purpose. Do not change!
class AbstractNgModelComponent {
    constructor() {
        this.cdRef = inject(ChangeDetectorRef);
        this.valueFn = value => value;
        this.valueLimitFn = value => false;
    }
    set value(value) {
        value = this.valueFn(value, this._value);
        if (this.valueLimitFn(value, this._value) !== false || this.readonly)
            return;
        this._value = value;
        this.notifyValueChange();
    }
    get value() {
        return this._value || this.defaultValue;
    }
    get defaultValue() {
        return this._value;
    }
    notifyValueChange() {
        if (this.onChange) {
            this.onChange(this.value);
        }
    }
    writeValue(value) {
        this._value = this.valueLimitFn(value, this._value) || value;
        this.cdRef.markForCheck();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbstractNgModelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: AbstractNgModelComponent, isStandalone: true, selector: "ng-component", inputs: { disabled: "disabled", readonly: "readonly", valueFn: "valueFn", valueLimitFn: "valueLimitFn", value: "value" }, ngImport: i0, template: '', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbstractNgModelComponent, decorators: [{
            type: Component,
            args: [{
                    template: '',
                }]
        }], propDecorators: { disabled: [{
                type: Input
            }], readonly: [{
                type: Input
            }], valueFn: [{
                type: Input
            }], valueLimitFn: [{
                type: Input
            }], value: [{
                type: Input
            }] } });

/**
 * @deprecated Use `authGuard` *function* instead.
 */
class AuthGuard {
    canActivate() {
        console.error('You should add @abp/ng-oauth packages or create your own auth packages.');
        return false;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AuthGuard, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AuthGuard, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AuthGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
const authGuard = () => {
    console.error('You should add @abp/ng-oauth packages or create your own auth packages.');
    return false;
};
const asyncAuthGuard = () => {
    console.error('You should add @abp/ng-oauth packages or create your own auth packages.');
    return false;
};

/**
 * Abstract service for Authentication.
 */
class AuthService {
    warningMessage() {
        console.error('You should add @abp/ng-oauth packages or create your own auth packages.');
    }
    get oidc() {
        this.warningMessage();
        return false;
    }
    set oidc(value) {
        this.warningMessage();
    }
    init() {
        this.warningMessage();
        return Promise.resolve(undefined);
    }
    login(params) {
        this.warningMessage();
        return of(undefined);
    }
    logout(queryParams) {
        this.warningMessage();
        return of(undefined);
    }
    navigateToLogin(queryParams) { }
    get isInternalAuth() {
        throw new Error('not implemented');
    }
    get isAuthenticated() {
        this.warningMessage();
        return false;
    }
    loginUsingGrant(grantType, parameters, headers) {
        console.log({ grantType, parameters, headers });
        return Promise.reject(new Error('not implemented'));
    }
    getAccessTokenExpiration() {
        this.warningMessage();
        return 0;
    }
    getRefreshToken() {
        this.warningMessage();
        return '';
    }
    getAccessToken() {
        this.warningMessage();
        return '';
    }
    refreshToken() {
        this.warningMessage();
        return Promise.resolve(undefined);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AuthService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AuthService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AuthService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class AbstractAuthErrorFilter {
}
class AuthErrorFilterService extends AbstractAuthErrorFilter {
    warningMessage() {
        console.error('You should add @abp/ng-oauth packages or create your own auth packages.');
    }
    get(id) {
        this.warningMessage();
        throw new Error('not implemented');
    }
    add(filter) {
        this.warningMessage();
    }
    patch(item) {
        this.warningMessage();
    }
    remove(id) {
        this.warningMessage();
    }
    run(event) {
        this.warningMessage();
        throw new Error('not implemented');
    }
}

const LOCALIZATIONS = new InjectionToken('LOCALIZATIONS');
function localizationContributor(localizations) {
    if (localizations) {
        localizations$.next([...localizations$.value, ...localizations]);
    }
}
const localizations$ = new BehaviorSubject([]);

const CORE_OPTIONS = new InjectionToken('CORE_OPTIONS');
function coreOptionsFactory({ ...options }) {
    return {
        ...options,
    };
}

// This will not be necessary when only Angukar 9.1+ is supported
function getLocaleDirection(locale) {
    return /^(ar(-[A-Z]{2})?|ckb(-IR)?|fa(-AF)?|he|ks|lrc(-IQ)?|mzn|pa-Arab|ps(-PK)?|sd|ug|ur(-IN)?|uz-Arab|yi)$/.test(locale)
        ? 'rtl'
        : 'ltr';
}
function createLocalizer(localization) {
    return (resourceName, key, defaultValue) => {
        if (resourceName === '_')
            return key;
        const resource = localization?.values?.[resourceName];
        if (!resource)
            return defaultValue;
        return resource[key] || defaultValue;
    };
}
function createLocalizerWithFallback(localization) {
    const findLocalization = createLocalizationFinder(localization);
    return (resourceNames, keys, defaultValue) => {
        const { localized } = findLocalization(resourceNames, keys);
        return localized || defaultValue;
    };
}
function createLocalizationPipeKeyGenerator(localization) {
    const findLocalization = createLocalizationFinder(localization);
    return (resourceNames, keys, defaultKey) => {
        const { resourceName, key } = findLocalization(resourceNames, keys);
        return !resourceName ? defaultKey : resourceName === '_' ? key : `${resourceName}::${key}`;
    };
}
function createLocalizationFinder(localization) {
    const localize = createLocalizer(localization);
    return (resourceNames, keys) => {
        resourceNames = resourceNames.concat(localization.defaultResourceName || '').filter(Boolean);
        const resourceCount = resourceNames.length;
        const keyCount = keys.length;
        for (let i = 0; i < resourceCount; i++) {
            const resourceName = resourceNames[i];
            for (let j = 0; j < keyCount; j++) {
                const key = keys[j];
                const localized = localize(resourceName, key, null);
                if (localized)
                    return { resourceName, key, localized };
            }
        }
        return { resourceName: undefined, key: undefined, localized: undefined };
    };
}

function createTokenParser(format) {
    return (str) => {
        const tokens = [];
        const regex = format.replace(/\./g, '\\.').replace(/\{\s?([0-9a-zA-Z]+)\s?\}/g, (_, token) => {
            tokens.push(token);
            return '(.+)';
        });
        const matches = (str.match(regex) || []).slice(1);
        return matches.reduce((acc, v, i) => {
            const key = tokens[i];
            acc[key] = [...(acc[key] || []), v].filter(Boolean);
            return acc;
        }, {});
    };
}
function interpolate(text, params) {
    return text
        .replace(/(['"])?\{\s*(\d+)\s*\}\1/g, (_, quote, digit) => (quote ? quote : '') + (params[digit] ?? `{${digit}}`) + (quote ? quote : ''))
        .replace(/\s+/g, ' ');
}
function escapeHtmlChars(value) {
    return value && typeof value === 'string'
        ? value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
        : value;
}

class ContentProjectionService {
    constructor() {
        this.injector = inject(Injector);
    }
    projectContent(projectionStrategy, injector = this.injector) {
        return projectionStrategy.injectContent(injector);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ContentProjectionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ContentProjectionService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ContentProjectionService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

function pushValueTo(array) {
    return (element) => {
        array.push(element);
        return array;
    };
}

function noop() {
    const fn = function () { };
    return fn;
}
function isUndefinedOrEmptyString(value) {
    return value === undefined || value === '';
}
function isNullOrUndefined(obj) {
    return obj === null || obj === undefined;
}
function isNullOrEmpty(obj) {
    return obj === null || obj === undefined || obj === '';
}
function exists(obj) {
    return !isNullOrUndefined(obj);
}
function isObject(obj) {
    return obj instanceof Object;
}
function isArray(obj) {
    return Array.isArray(obj);
}
function isObjectAndNotArray(obj) {
    return isObject(obj) && !isArray(obj);
}
function isNode(obj) {
    return obj instanceof Node;
}
function isObjectAndNotArrayNotNode(obj) {
    return isObjectAndNotArray(obj) && !isNode(obj);
}
function checkHasProp(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}

function getShortDateFormat(configStateService) {
    const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');
    return dateTimeFormat.shortDatePattern;
}
function getShortTimeFormat(configStateService) {
    const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');
    return dateTimeFormat?.shortTimePattern?.replace('tt', 'a');
}
function getShortDateShortTimeFormat(configStateService) {
    const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');
    return `${dateTimeFormat.shortDatePattern} ${dateTimeFormat?.shortTimePattern?.replace('tt', 'a')}`;
}

function deepMerge(target, source) {
    if (isObjectAndNotArrayNotNode(target) && isObjectAndNotArrayNotNode(source)) {
        return deepMergeRecursively(target, source);
    }
    else if (isNullOrUndefined(target) && isNullOrUndefined(source)) {
        return {};
    }
    else {
        return exists(source) ? source : target;
    }
}
function deepMergeRecursively(target, source) {
    const shouldNotRecurse = isNullOrUndefined(target) ||
        isNullOrUndefined(source) || // at least one not defined
        isArray(target) ||
        isArray(source) || // at least one array
        !isObject(target) ||
        !isObject(source) || // at least one not an object
        isNode(target) ||
        isNode(source); // at least one node
    /**
     * if we will not recurse any further,
     * we will prioritize source if it is a defined value.
     */
    if (shouldNotRecurse) {
        return exists(source) ? source : target;
    }
    const keysOfTarget = Object.keys(target);
    const keysOfSource = Object.keys(source);
    const uniqueKeys = new Set(keysOfTarget.concat(keysOfSource));
    return [...uniqueKeys].reduce((retVal, key) => {
        retVal[key] = deepMergeRecursively(target[key], source[key]);
        return retVal;
    }, {});
}

class InternalStore {
    get state() {
        return this.state$.value;
    }
    constructor(initialState) {
        this.initialState = initialState;
        this.state$ = new BehaviorSubject(this.initialState);
        this.update$ = new Subject();
        this.sliceState = (selector, compareFn = compare) => this.state$.pipe(map(selector), distinctUntilChanged(compareFn));
        this.sliceUpdate = (selector, filterFn = (x) => x !== undefined) => this.update$.pipe(map(selector), filter(filterFn));
    }
    patch(state) {
        let patchedState = state;
        if (typeof state === 'object' && !Array.isArray(state)) {
            patchedState = { ...this.state, ...state };
        }
        this.state$.next(patchedState);
        this.update$.next(patchedState);
    }
    deepPatch(state) {
        // TODO: Strict improve deepMerge
        this.state$.next(deepMerge(this.state, state));
        this.update$.next(state);
    }
    set(state) {
        this.state$.next(state);
        this.update$.next(state);
    }
    reset() {
        this.set(this.initialState);
    }
}

const mapToApiUrl = (key) => (apis) => ((key && apis[key]) || apis.default).url || apis.default.url;
const mapToIssuer = (issuer) => {
    if (!issuer) {
        return issuer;
    }
    return issuer.endsWith('/') ? issuer : issuer + '/';
};
class EnvironmentService {
    constructor() {
        this.store = new InternalStore({});
    }
    get createOnUpdateStream() {
        return this.store.sliceUpdate;
    }
    getEnvironment$() {
        return this.store.sliceState(state => state);
    }
    getEnvironment() {
        return this.store.state;
    }
    getApiUrl(key) {
        return mapToApiUrl(key)(this.store.state?.apis);
    }
    getApiUrl$(key) {
        return this.store.sliceState(state => state.apis).pipe(map(mapToApiUrl(key)));
    }
    setState(environment) {
        this.store.set(environment);
    }
    getIssuer() {
        const issuer = this.store.state?.oAuthConfig?.issuer;
        return mapToIssuer(issuer);
    }
    getIssuer$() {
        return this.store.sliceState(state => state?.oAuthConfig?.issuer).pipe(map(mapToIssuer));
    }
    getImpersonation() {
        return this.store.state?.oAuthConfig?.impersonation || {};
    }
    getImpersonation$() {
        return this.store.sliceState(state => state?.oAuthConfig?.impersonation || {});
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: EnvironmentService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: EnvironmentService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: EnvironmentService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class HttpErrorReporterService {
    constructor() {
        this._reporter$ = new Subject();
        this._errors$ = new BehaviorSubject([]);
    }
    get reporter$() {
        return this._reporter$.asObservable();
    }
    get errors$() {
        return this._errors$.asObservable();
    }
    get errors() {
        return this._errors$.value;
    }
    reportError(error) {
        this._reporter$.next(error);
        this._errors$.next([...this.errors, error]);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HttpErrorReporterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HttpErrorReporterService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HttpErrorReporterService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

function getRemoteEnv(injector, environment) {
    const environmentService = injector.get(EnvironmentService);
    const { remoteEnv } = environment;
    const { headers = {}, method = 'GET', url } = remoteEnv || {};
    if (!url)
        return Promise.resolve();
    const http = injector.get(HttpClient);
    const httpErrorReporter = injector.get(HttpErrorReporterService);
    return http
        .request(method, url, { headers })
        .pipe(catchError(err => {
        httpErrorReporter.reportError(err);
        return of(null);
    }), // TODO: Consider get handle function from a provider
    tap(env => environmentService.setState(mergeEnvironments(environment, env || {}, remoteEnv))))
        .toPromise();
}
function mergeEnvironments(local, remote, config) {
    switch (config.mergeStrategy) {
        case 'deepmerge':
            return deepMerge(local, remote);
        case 'overwrite':
        case null:
        case undefined:
            return remote;
        default:
            return config.mergeStrategy(local, remote);
    }
}

class LazyModuleFactory extends NgModuleFactory {
    get moduleType() {
        return this.moduleWithProviders.ngModule;
    }
    constructor(moduleWithProviders) {
        super();
        this.moduleWithProviders = moduleWithProviders;
    }
    create(parentInjector) {
        const injector = Injector.create({
            ...(parentInjector && { parent: parentInjector }),
            providers: this.moduleWithProviders.providers,
        });
        const compiler = injector.get(Compiler);
        const factory = compiler.compileModuleSync(this.moduleType);
        return factory.create(injector);
    }
}
function featuresFactory(configState, featureKeys, mapFn = features => features) {
    return configState.getFeatures$(featureKeys).pipe(filter(Boolean), map(mapFn));
}

/** @deprecated the method will change in v8.0 */
function downloadBlob(blob, filename) {
    const blobUrl = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = blobUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.dispatchEvent(new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
        view: window,
    }));
    document.body.removeChild(link);
}

function isNumber(value) {
    return value == Number(value);
}

function mapEnumToOptions(_enum) {
    const options = [];
    for (const member in _enum)
        if (!isNumber(member))
            options.push({
                key: member,
                value: _enum[member],
            });
    return options;
}

function uuid(a) {
    return a
        ? (a ^ ((Math.random() * 16) >> (a / 4))).toString(16)
        : ('' + 1e7 + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);
}
function generateHash(value) {
    let hashed = 0;
    let charCode;
    for (let i = 0; i < value.length; i++) {
        charCode = value.charCodeAt(i);
        hashed = (hashed << 5) - hashed + charCode;
        hashed |= 0;
    }
    return hashed;
}
function generatePassword(injector, length = 8) {
    if (injector) {
        length = getRequiredPasswordLength(injector);
    }
    length = Math.min(Math.max(4, length), 128);
    const lowers = 'abcdefghjkmnpqrstuvwxyz';
    const uppers = 'ABCDEFGHJKMNPQRSTUVWXYZ';
    const numbers = '23456789';
    const specials = '!*_#/+-.';
    const all = lowers + uppers + numbers + specials;
    const getRandom = (chrSet) => chrSet[Math.floor(Math.random() * chrSet.length)];
    const password = Array({ length });
    password[0] = getRandom(lowers);
    password[1] = getRandom(uppers);
    password[2] = getRandom(numbers);
    password[3] = getRandom(specials);
    for (let i = 4; i < length; i++) {
        password[i] = getRandom(all);
    }
    return password.sort(() => 0.5 - Math.random()).join('');
}
function getRequiredPasswordLength(injector) {
    const configState = injector.get(ConfigStateService);
    const passwordRules = configState.getSettings('Identity.Password');
    return Number(passwordRules['Abp.Identity.Password.RequiredLength']) || 8;
}

function getPathName(url) {
    const { pathname } = new URL(url, window.location.origin);
    return pathname;
}
class WebHttpUrlEncodingCodec {
    encodeKey(k) {
        return encodeURIComponent(k);
    }
    encodeValue(v) {
        return encodeURIComponent(v);
    }
    decodeKey(k) {
        return decodeURIComponent(k);
    }
    decodeValue(v) {
        return decodeURIComponent(v);
    }
}

class AbpLocalStorageService {
    constructor() {
        this.platformId = inject(PLATFORM_ID);
    }
    get length() {
        return isPlatformBrowser(this.platformId) ? localStorage.length : 0;
    }
    clear() {
        if (isPlatformBrowser(this.platformId)) {
            localStorage.clear();
        }
    }
    getItem(key) {
        if (!isPlatformBrowser(this.platformId)) {
            return null;
        }
        return localStorage.getItem(key);
    }
    key(index) {
        if (!isPlatformBrowser(this.platformId)) {
            return null;
        }
        return localStorage.key(index);
    }
    removeItem(key) {
        if (isPlatformBrowser(this.platformId)) {
            localStorage.removeItem(key);
        }
    }
    setItem(key, value) {
        if (isPlatformBrowser(this.platformId)) {
            localStorage.setItem(key, value);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpLocalStorageService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpLocalStorageService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpLocalStorageService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

const APP_INIT_ERROR_HANDLERS = new InjectionToken('APP_INIT_ERROR_HANDLERS');

const COOKIE_LANGUAGE_KEY = new InjectionToken('COOKIE_LANGUAGE_KEY', {
    factory: () => '.AspNetCore.Culture',
});

const LIST_QUERY_DEBOUNCE_TIME = new InjectionToken('LIST_QUERY_DEBOUNCE_TIME');

const LOADER_DELAY = new InjectionToken('LOADER_DELAY');

const NAVIGATE_TO_MANAGE_PROFILE = new InjectionToken('NAVIGATE_TO_MANAGE_PROFILE');

const QUEUE_MANAGER = new InjectionToken("QUEUE_MANAGER");

const TENANT_KEY = new InjectionToken('TENANT_KEY');

const INCUDE_LOCALIZATION_RESOURCES_TOKEN = new InjectionToken('INCUDE_LOCALIZATION_RESOURCES_TOKEN');

const PIPE_TO_LOGIN_FN_KEY = new InjectionToken('PIPE_TO_LOGIN_FN_KEY');

/**
 * @deprecated The token should not be used anymore.
 */
const SET_TOKEN_RESPONSE_TO_STORAGE_FN_KEY = new InjectionToken('SET_TOKEN_RESPONSE_TO_STORAGE_FN_KEY');

const CHECK_AUTHENTICATION_STATE_FN_KEY = new InjectionToken('CHECK_AUTHENTICATION_STATE_FN_KEY');

const IS_EXTERNAL_REQUEST = new HttpContextToken(() => false);

const OTHERS_GROUP = new InjectionToken('OTHERS_GROUP');

const TENANT_NOT_FOUND_BY_NAME = new InjectionToken('TENANT_NOT_FOUND_BY_NAME');

const SORT_COMPARE_FUNC = new InjectionToken('SORT_COMPARE_FUNC');
function compareFuncFactory() {
    const localizationService = inject(LocalizationService);
    const fn = (a, b) => {
        const aNumber = a.order;
        const bNumber = b.order;
        if (aNumber > bNumber)
            return 1;
        if (aNumber < bNumber)
            return -1;
        if (a.id > b.id)
            return 1;
        if (a.id < b.id)
            return -1;
        if (!Number.isInteger(aNumber))
            return 1;
        if (!Number.isInteger(bNumber))
            return -1;
        const aName = localizationService.instant(a.name);
        const bName = localizationService.instant(b.name);
        if (aName > bName)
            return 1;
        if (aName < bName)
            return -1;
        return 0;
    };
    return fn;
}

const DYNAMIC_LAYOUTS_TOKEN = new InjectionToken('DYNAMIC_LAYOUTS');

const DISABLE_PROJECT_NAME = new InjectionToken('DISABLE_APP_NAME');

const SSR_FLAG = makeStateKey('SSR_FLAG');
const APP_STARTED_WITH_SSR = new InjectionToken('APP_STARTED_WITH_SSR', {
    providedIn: 'root',
    factory: () => {
        const platformId = inject(PLATFORM_ID);
        const cookieService = inject(AbpCookieStorageService);
        if (!isPlatformBrowser(platformId))
            return true;
        const ts = inject(TransferState);
        const ssrEnabled = cookieService.getItem('ssr-init');
        // Remove the cookie after reading its value because it's only needed once
        cookieService.removeItem('ssr-init');
        return ts.get(SSR_FLAG, false) || ssrEnabled === 'true';
    },
});

class AbpCookieStorageService {
    constructor() {
        this.platformId = inject(PLATFORM_ID);
        this.document = inject(DOCUMENT);
        this.request = inject(REQUEST);
    }
    get length() {
        return isPlatformBrowser(this.platformId) ? this.keys().length : this.getCookiesFromRequest()?.size ?? 0;
    }
    clear() {
        if (!isPlatformBrowser(this.platformId))
            return;
        this.keys().forEach(k => this.removeItem(k));
    }
    getItem(key) {
        if (!isPlatformBrowser(this.platformId)) {
            return this.getCookiesFromRequest()?.get(key) ?? null;
        }
        const name = key + '=';
        const parts = (this.document.cookie || '').split('; ');
        for (const p of parts) {
            if (p.startsWith(name)) {
                return decodeURIComponent(p.slice(name.length));
            }
        }
        return null;
    }
    key(index) {
        if (!isPlatformBrowser(this.platformId))
            return null;
        return this.keys()[index] ?? null;
    }
    removeItem(key) {
        if (!isPlatformBrowser(this.platformId))
            return;
        this.setCookie(key, '', { 'max-age': -1, path: '/' });
    }
    setItem(key, value) {
        if (!isPlatformBrowser(this.platformId))
            return;
        this.setCookie(key, encodeURIComponent(value), {
            path: '/',
            sameSite: 'Lax',
            secure: true,
        });
    }
    setItemWithExpiry(key, value, seconds) {
        if (!isPlatformBrowser(this.platformId))
            return;
        this.setCookie(key, encodeURIComponent(value), {
            path: '/',
            sameSite: 'Lax',
            secure: true,
            'max-age': Math.max(0, Math.floor(seconds)),
        });
    }
    keys() {
        const raw = (this.document.cookie || '').split('; ').filter(Boolean);
        return raw
            .map(c => decodeURIComponent(c.split('=')[0]));
    }
    setCookie(name, value, opts) {
        let s = `${name}=${value}`;
        if (opts.path)
            s += `; Path=${opts.path}`;
        if (opts.domain)
            s += `; Domain=${opts.domain}`;
        if (opts.sameSite)
            s += `; SameSite=${opts.sameSite}`;
        if (opts.secure)
            s += `; Secure`;
        if (opts.expires)
            s += `; Expires=${opts.expires.toUTCString()}`;
        if (typeof opts['max-age'] === 'number')
            s += `; Max-Age=${opts['max-age']}`;
        this.document.cookie = s;
    }
    getCookiesFromRequest() {
        const cookies = new Map();
        const cookieHeader = this.request?.headers.get('cookie') ?? '';
        for (const part of cookieHeader.split(';')) {
            const i = part.indexOf('=');
            if (i > -1) {
                const k = part.slice(0, i).trim();
                const v = decodeURIComponent(part.slice(i + 1).trim());
                cookies.set(k, v);
            }
        }
        return cookies;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpCookieStorageService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpCookieStorageService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpCookieStorageService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class SessionStateService {
    constructor() {
        this.configState = inject(ConfigStateService);
        this.localStorageService = inject(AbpLocalStorageService);
        this.appStartedWithSSR = inject(APP_STARTED_WITH_SSR, { optional: true });
        this.cookieStorageService = inject(AbpCookieStorageService);
        this.store = new InternalStore({});
        this.document = inject(DOCUMENT);
        this.updateLocalStorage = () => {
            if (this.appStartedWithSSR) {
                this.cookieStorageService.setItem('abpSession', JSON.stringify(this.store.state));
            }
            else {
                this.localStorageService.setItem('abpSession', JSON.stringify(this.store.state));
            }
        };
        this.init();
        this.setInitialLanguage();
    }
    init() {
        const storageService = this.appStartedWithSSR ? this.cookieStorageService : this.localStorageService;
        const session = storageService.getItem('abpSession');
        if (session) {
            this.store.set(JSON.parse(session));
        }
        this.store.sliceUpdate(state => state).subscribe(this.updateLocalStorage);
    }
    setInitialLanguage() {
        const appLanguage = this.getLanguage();
        this.configState
            .getDeep$('localization.currentCulture.cultureName')
            .pipe(filter(cultureName => !!cultureName), take(1))
            .subscribe(lang => {
            if (lang.includes(';')) {
                lang = lang.split(';')[0];
            }
            this.setLanguage(lang);
        });
    }
    onLanguageChange$() {
        return this.store.sliceUpdate(state => state.language);
    }
    onTenantChange$() {
        return this.store.sliceUpdate(state => state.tenant);
    }
    getLanguage() {
        return this.store.state.language;
    }
    getLanguage$() {
        return this.store.sliceState(state => state.language);
    }
    getTenant() {
        return this.store.state.tenant;
    }
    getTenant$() {
        return this.store.sliceState(state => state.tenant);
    }
    setTenant(tenant) {
        if (compare(tenant, this.store.state.tenant))
            return;
        this.store.set({ ...this.store.state, tenant });
    }
    setLanguage(language) {
        const currentLanguage = this.store.state.language;
        if (language !== currentLanguage) {
            this.store.patch({ language });
        }
        const currentAttribute = this.document.documentElement.getAttribute('lang');
        if (language !== currentAttribute) {
            this.document.documentElement.setAttribute('lang', language);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SessionStateService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SessionStateService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SessionStateService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

class AbpTenantService {
    constructor() {
        this.restService = inject(RestService);
        this.apiName = 'abp';
        this.findTenantById = (id, config) => this.restService.request({
            method: 'GET',
            url: `/api/abp/multi-tenancy/tenants/by-id/${id}`,
        }, { apiName: this.apiName, ...config });
        this.findTenantByName = (name, config) => this.restService.request({
            method: 'GET',
            url: `/api/abp/multi-tenancy/tenants/by-name/${name}`,
        }, { apiName: this.apiName, ...config });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpTenantService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpTenantService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpTenantService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class MultiTenancyService {
    constructor() {
        this.sessionState = inject(SessionStateService);
        this.tenantService = inject(AbpTenantService);
        this.configStateService = inject(ConfigStateService);
        this.tenantKey = inject(TENANT_KEY);
        this.domainTenant = null;
        this.isTenantBoxVisible = true;
        this.apiName = 'abp';
        this.setTenantToState = (tenant) => {
            this.sessionState.setTenant({ id: tenant.tenantId, name: tenant.name, isAvailable: true });
            return this.configStateService.refreshAppState().pipe(map(_ => tenant));
        };
    }
    setTenantByName(tenantName) {
        return this.tenantService
            .findTenantByName(tenantName)
            .pipe(switchMap(this.setTenantToState));
    }
    setTenantById(tenantId) {
        return this.tenantService
            .findTenantById(tenantId)
            .pipe(switchMap(this.setTenantToState));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: MultiTenancyService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: MultiTenancyService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: MultiTenancyService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

const tenancyPlaceholder = '{0}';
function getCurrentTenancyName(appBaseUrl, injector) {
    const platformId = injector.get(PLATFORM_ID);
    const document = injector.get(DOCUMENT);
    if (appBaseUrl.charAt(appBaseUrl.length - 1) !== '/')
        appBaseUrl += '/';
    const parseTokens = createTokenParser(appBaseUrl);
    const token = tenancyPlaceholder.replace(/[}{]/g, '');
    const tokenValue = isPlatformBrowser(platformId)
        ? parseTokens(document.defaultView?.location.href)[token]?.[0]
        : undefined;
    return tokenValue;
}
function getCurrentTenancyNameFromUrl(tenantKey, injector) {
    const platformId = injector.get(PLATFORM_ID);
    const document = injector.get(DOCUMENT);
    if (!isPlatformBrowser(platformId)) {
        return null;
    }
    const search = document.defaultView?.location.search;
    const urlParams = new URLSearchParams(search);
    return urlParams.get(tenantKey);
}
async function parseTenantFromUrl(injector) {
    const environmentService = injector.get(EnvironmentService);
    const multiTenancyService = injector.get(MultiTenancyService);
    const tenantNotFoundHandler = injector.get(TENANT_NOT_FOUND_BY_NAME, null);
    const baseUrl = environmentService.getEnvironment()?.application?.baseUrl || '';
    const tenancyName = getCurrentTenancyName(baseUrl, injector);
    const hideTenantBox = () => {
        multiTenancyService.isTenantBoxVisible = false;
    };
    const setDomainTenant = (tenant) => {
        multiTenancyService.domainTenant = {
            id: tenant.tenantId,
            name: tenant.name,
            isAvailable: true,
        };
    };
    const setEnvironmentWithDomainTenant = (tenant) => {
        hideTenantBox();
        setDomainTenant(tenant);
    };
    if (tenancyName) {
        /**
         * We have to replace tenant name within the urls from environment,
         * because the code below will make a http request to find information about the domain tenant.
         * Before this request takes place, we need to replace placeholders aka "{0}".
         */
        replaceTenantNameWithinEnvironment(injector, tenancyName);
        const tenant$ = multiTenancyService.setTenantByName(tenancyName);
        try {
            const result = await firstValueFrom(tenant$);
            setEnvironmentWithDomainTenant(result);
            return Promise.resolve(result);
        }
        catch (httpError) {
            if (httpError instanceof HttpErrorResponse &&
                httpError.status === 404 &&
                tenantNotFoundHandler) {
                tenantNotFoundHandler(httpError);
            }
            return Promise.reject();
        }
    }
    /**
     * If there is no tenant, we still have to clean up {0}. from baseUrl to avoid incorrect http requests.
     */
    replaceTenantNameWithinEnvironment(injector, '', tenancyPlaceholder + '.');
    const tenantIdFromQueryParams = getCurrentTenancyNameFromUrl(multiTenancyService.tenantKey, injector);
    if (tenantIdFromQueryParams) {
        const tenantById$ = multiTenancyService.setTenantById(tenantIdFromQueryParams);
        return firstValueFrom(tenantById$);
    }
    return Promise.resolve();
}
function replaceTenantNameWithinEnvironment(injector, tenancyName, placeholder = tenancyPlaceholder) {
    const environmentService = injector.get(EnvironmentService);
    const environment = clone(environmentService.getEnvironment());
    if (environment.application.baseUrl) {
        environment.application.baseUrl = environment.application.baseUrl.replace(placeholder, tenancyName);
    }
    if (environment.oAuthConfig?.redirectUri) {
        environment.oAuthConfig.redirectUri = environment.oAuthConfig.redirectUri.replace(placeholder, tenancyName);
    }
    if (!environment.oAuthConfig) {
        environment.oAuthConfig = {};
    }
    environment.oAuthConfig.issuer = (environment.oAuthConfig.issuer || '').replace(placeholder, tenancyName);
    Object.keys(environment.apis).forEach(api => {
        Object.keys(environment.apis[api]).forEach(key => {
            environment.apis[api][key] = (environment.apis[api][key] || '').replace(placeholder, tenancyName);
        });
    });
    return environmentService.setState(environment);
}

async function getInitialData() {
    const injector = inject(Injector);
    const environmentService = injector.get(EnvironmentService);
    const configState = injector.get(ConfigStateService);
    const options = injector.get(CORE_OPTIONS);
    const appStartedWithSSR = injector.get(APP_STARTED_WITH_SSR);
    environmentService.setState(options.environment);
    await getRemoteEnv(injector, options.environment);
    await parseTenantFromUrl(injector);
    const authService = injector.get(AuthService, undefined, { optional: true });
    const checkAuthenticationState = injector.get(CHECK_AUTHENTICATION_STATE_FN_KEY, noop, {
        optional: true,
    });
    if (!options.skipInitAuthService && authService) {
        await authService.init();
    }
    if (options.skipGetAppConfiguration)
        return;
    const result$ = configState.refreshAppState().pipe(tap(() => checkAuthenticationState(injector)), tap(() => {
        const currentTenant = configState.getOne('currentTenant');
        injector.get(SessionStateService).setTenant(currentTenant);
    }), catchError(error => {
        const appInitErrorHandlers = injector.get(APP_INIT_ERROR_HANDLERS, null);
        if (appInitErrorHandlers && appInitErrorHandlers.length) {
            appInitErrorHandlers.forEach(func => func(error));
        }
        return throwError(() => error);
    }));
    if (appStartedWithSSR) {
        await firstValueFrom(result$.pipe(timeout(0), catchError(() => of(null))));
    }
    else {
        await lastValueFrom(result$);
    }
    await localeInitializer(injector);
}
function localeInitializer(injector) {
    const currentInjector = injector || inject(Injector);
    const sessionState = currentInjector.get(SessionStateService);
    const { registerLocaleFn } = currentInjector.get(CORE_OPTIONS);
    const lang = sessionState.getLanguage() || 'en';
    return new Promise((resolve, reject) => {
        registerLocaleFn(lang).then(module => {
            if (module?.default)
                registerLocaleData(module.default);
            return resolve('resolved');
        }, reject);
    });
}

class CrossOriginStrategy {
    constructor(crossorigin, integrity) {
        this.crossorigin = crossorigin;
        this.integrity = integrity;
    }
    setCrossOrigin(element) {
        if (this.integrity)
            element.setAttribute('integrity', this.integrity);
        if (this.crossorigin) {
            element.setAttribute('crossorigin', this.crossorigin);
        }
    }
}
class NoCrossOriginStrategy extends CrossOriginStrategy {
    setCrossOrigin() { }
}
const CROSS_ORIGIN_STRATEGY = {
    Anonymous(integrity) {
        return new CrossOriginStrategy('anonymous', integrity);
    },
    UseCredentials(integrity) {
        return new CrossOriginStrategy('use-credentials', integrity);
    },
    None() {
        return new NoCrossOriginStrategy(null);
    },
};

class DomStrategy {
    constructor(getTarget, position = 'beforeend') {
        this.getTarget = getTarget;
        this.position = position;
    }
    insertElement(element) {
        if (typeof document !== 'undefined') {
            const target = this.getTarget();
            target.insertAdjacentElement(this.position, element);
        }
    }
}
const DOM_STRATEGY = {
    AfterElement(element) {
        return new DomStrategy(() => element, 'afterend');
    },
    AppendToBody() {
        return new DomStrategy(() => document?.body, 'beforeend');
    },
    AppendToHead() {
        return new DomStrategy(() => document?.head, 'beforeend');
    },
    BeforeElement(element) {
        return new DomStrategy(() => element, 'beforebegin');
    },
    PrependToHead() {
        return new DomStrategy(() => document?.head, 'afterbegin');
    },
};

function fromLazyLoad(element, domStrategy = DOM_STRATEGY.AppendToHead(), crossOriginStrategy = CROSS_ORIGIN_STRATEGY.Anonymous()) {
    crossOriginStrategy.setCrossOrigin(element);
    domStrategy.insertElement(element);
    return new Observable((observer) => {
        element.onload = (event) => {
            clearCallbacks(element);
            observer.next(event);
            observer.complete();
        };
        const handleError = createErrorHandler(observer, element);
        element.onerror = handleError;
        element.onabort = handleError;
        element.onemptied = handleError;
        element.onstalled = handleError;
        element.onsuspend = handleError;
        return () => {
            clearCallbacks(element);
            observer.complete();
        };
    });
}
function createErrorHandler(observer, element) {
    return function (event) {
        clearCallbacks(element);
        element.parentNode?.removeChild(element);
        observer.error(event);
    };
}
function clearCallbacks(element) {
    element.onload = null;
    element.onerror = null;
    element.onabort = null;
    element.onemptied = null;
    element.onstalled = null;
    element.onsuspend = null;
}

class DefaultQueueManager {
    constructor() {
        this.queue = [];
        this.isRunning = false;
        this.stack = 0;
        this.interval = 0;
        this.stackSize = 100;
    }
    init(interval, stackSize) {
        this.interval = interval;
        this.stackSize = stackSize;
    }
    add(fn) {
        this.queue.push(fn);
        this.run();
    }
    run() {
        if (this.isRunning)
            return;
        this.stack++;
        this.isRunning = true;
        const fn = this.queue.shift();
        if (!fn) {
            this.isRunning = false;
            return;
        }
        fn();
        if (this.stack > this.stackSize) {
            setTimeout(() => {
                this.isRunning = false;
                this.run();
                this.stack = 0;
            }, this.interval);
        }
        else {
            this.isRunning = false;
            this.run();
        }
    }
}

function findRoute(routesService, path) {
    const node = routesService.find(route => route.path === path);
    return node || path === '/'
        ? node
        : findRoute(routesService, path.split('/').slice(0, -1).join('/') || '/');
}
function getRoutePath(router, url = router.url) {
    const emptyGroup = { segments: [] };
    const primaryGroup = router.parseUrl(url).root.children[PRIMARY_OUTLET];
    return '/' + (primaryGroup || emptyGroup).segments.map(({ path }) => path).join('/');
}
function reloadRoute(router, ngZone) {
    const { shouldReuseRoute } = router.routeReuseStrategy;
    const setRouteReuse = (reuse) => {
        router.routeReuseStrategy.shouldReuseRoute = reuse;
    };
    setRouteReuse(() => false);
    router.navigated = false;
    ngZone.run(async () => {
        await router.navigateByUrl(router.url).catch(noop);
        setRouteReuse(shouldReuseRoute);
    });
}

/* eslint-disable @typescript-eslint/ban-types */
class BaseTreeNode {
    constructor(props) {
        this.children = [];
        this.isLeaf = true;
        Object.assign(this, props);
    }
    static create(props) {
        return new BaseTreeNode(props);
    }
}
function createTreeFromList(list, keySelector, parentKeySelector, valueMapper) {
    const map = createMapFromList(list, keySelector, valueMapper);
    const tree = [];
    list.forEach(row => {
        const id = keySelector(row);
        const parentId = parentKeySelector(row);
        const node = map.get(id);
        if (!node)
            return;
        if (parentId) {
            const parent = map.get(parentId);
            if (!parent)
                return;
            parent.children.push(node);
            parent.isLeaf = false;
            node.parent = parent;
        }
        else {
            tree.push(node);
        }
    });
    return tree;
}
function createMapFromList(list, keySelector, valueMapper) {
    const map = new Map();
    list.forEach(row => map.set(keySelector(row), valueMapper(row)));
    return map;
}
function createTreeNodeFilterCreator(key, mapperFn) {
    return (search) => {
        const regex = new RegExp('.*' + search + '.*', 'i');
        return function collectNodes(nodes, matches = []) {
            for (const node of nodes) {
                if (regex.test(mapperFn(node[key])))
                    matches.push(node);
                if (node.children.length)
                    collectNodes(node.children, matches);
            }
            return matches;
        };
    };
}
function createGroupMap(list, othersGroupKey) {
    if (!isArray(list) || !list.some(node => Boolean(node.group)))
        return undefined;
    const mapGroup = new Map();
    for (const node of list) {
        const group = node?.group || othersGroupKey;
        if (typeof group !== 'string') {
            throw new Error(`Invalid group: ${group}`);
        }
        const items = mapGroup.get(group) || [];
        items.push(node);
        mapGroup.set(group, items);
    }
    return mapGroup;
}

class ServerCookieParser {
    static parse(cookieHeader) {
        const cookies = {};
        if (!cookieHeader)
            return cookies;
        try {
            cookieHeader.split(';').forEach(cookie => {
                const parts = cookie.trim().split('=');
                if (parts.length >= 2) {
                    const name = parts[0].trim();
                    const value = parts.slice(1).join('=');
                    if (name) {
                        try {
                            cookies[name] = decodeURIComponent(value);
                        }
                        catch (e) {
                            cookies[name] = value;
                        }
                    }
                }
            });
        }
        catch (error) {
            console.error('Error parsing cookies:', error);
        }
        return cookies;
    }
    static middleware() {
        return (req, res, next) => {
            req.cookies = ServerCookieParser.parse(req.headers.cookie || '');
            next();
        };
    }
    static getCookie(req, name) {
        const cookieHeader = req.headers.cookie;
        if (!cookieHeader)
            return undefined;
        const cookies = ServerCookieParser.parse(cookieHeader);
        return cookies[name];
    }
}

class DomInsertionService {
    constructor() {
        this.inserted = new Set();
    }
    insertContent(contentStrategy) {
        const hash = generateHash(contentStrategy.content);
        if (this.inserted.has(hash))
            return;
        const element = contentStrategy.insertElement();
        this.inserted.add(hash);
        return element;
    }
    removeContent(element) {
        if (element.textContent) {
            const hash = generateHash(element.textContent);
            this.inserted.delete(hash);
            element.parentNode?.removeChild(element);
        }
    }
    has(content) {
        const hash = generateHash(content);
        return this.inserted.has(hash);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DomInsertionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DomInsertionService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DomInsertionService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class HtmlEncodingService {
    encode(value) {
        if (!value) {
            return value;
        }
        return value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }
    decode(value) {
        if (!value) {
            return value;
        }
        return value
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'");
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HtmlEncodingService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HtmlEncodingService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HtmlEncodingService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class HttpWaitService {
    constructor() {
        this.store = new InternalStore({
            requests: [],
            filteredRequests: [],
        });
        this.destroy$ = new Subject();
        const injector = inject(Injector);
        this.delay = injector.get(LOADER_DELAY, 500);
    }
    getLoading() {
        return !!this.applyFilter(this.store.state.requests).length;
    }
    getLoading$() {
        return this.store
            .sliceState(({ requests }) => requests)
            .pipe(map(requests => !!this.applyFilter(requests).length), switchMap(condition => condition
            ? this.delay === 0
                ? of(true)
                : timer(this.delay).pipe(mapTo(true), takeUntil(this.destroy$))
            : of(false)), tap(() => this.destroy$.next()));
    }
    updateLoading$() {
        return this.store.sliceUpdate(({ requests }) => !!this.applyFilter(requests).length);
    }
    clearLoading() {
        this.store.patch({ requests: [] });
    }
    addRequest(request) {
        this.store.patch({ requests: [...this.store.state.requests, request] });
    }
    deleteRequest(request) {
        const requests = this.store.state.requests.filter(r => r !== request);
        this.store.patch({ requests });
    }
    addFilter(request) {
        const requests = Array.isArray(request) ? request : [request];
        const filteredRequests = [
            ...this.store.state.filteredRequests.filter(f => !requests.some(r => this.isSameRequest(f, r))),
            ...requests,
        ];
        this.store.patch({ filteredRequests });
    }
    removeFilter(request) {
        const requests = Array.isArray(request) ? request : [request];
        const filteredRequests = this.store.state.filteredRequests.filter(f => !requests.some(r => this.isSameRequest(f, r)));
        this.store.patch({ filteredRequests });
    }
    applyFilter(requests) {
        if (!requests) {
            return [];
        }
        const { filteredRequests } = this.store.state;
        return requests.filter(({ method, url }) => !filteredRequests.find(filteredRequest => this.isSameRequest(filteredRequest, { method, endpoint: getPathName(url) })));
    }
    isSameRequest(filteredRequest, request) {
        const { method, endpoint } = filteredRequest;
        return endpoint === request.endpoint && method === request.method;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HttpWaitService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HttpWaitService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HttpWaitService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

class ResourceWaitService {
    constructor() {
        this.store = new InternalStore({ resources: new Set() });
    }
    getLoading() {
        return !!this.store.state.resources.size;
    }
    getLoading$() {
        return this.store.sliceState(({ resources }) => !!resources.size);
    }
    updateLoading$() {
        return this.store.sliceUpdate(({ resources }) => !!resources?.size);
    }
    clearLoading() {
        this.store.patch({ resources: new Set() });
    }
    addResource(resource) {
        const resources = this.store.state.resources;
        resources.add(resource);
        this.store.patch({ resources });
    }
    deleteResource(resource) {
        const resources = this.store.state.resources;
        resources.delete(resource);
        this.store.patch({ resources });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ResourceWaitService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ResourceWaitService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ResourceWaitService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class LazyLoadService {
    constructor() {
        this.resourceWaitService = inject(ResourceWaitService);
        this.loaded = new Map();
    }
    load(strategy, retryTimes, retryDelay) {
        if (this.loaded.has(strategy.path))
            return of(new CustomEvent('load'));
        this.resourceWaitService.addResource(strategy.path);
        const delayOperator = retryDelay ? pipe(delay(retryDelay)) : pipe();
        const takeOp = retryTimes ? pipe(take(retryTimes)) : pipe();
        return strategy.createStream().pipe(retryWhen(error$ => concat(error$.pipe(delayOperator, takeOp), throwError(() => new CustomEvent('error')))), tap(() => {
            this.loaded.set(strategy.path, strategy.element);
            this.resourceWaitService.deleteResource(strategy.path);
        }), delay(100), shareReplay({ bufferSize: 1, refCount: true }));
    }
    remove(path) {
        const element = this.loaded.get(path);
        if (!element)
            return false;
        element.parentNode?.removeChild(element);
        this.loaded.delete(path);
        return true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LazyLoadService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LazyLoadService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LazyLoadService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ListService {
    set filter(value) {
        this._filter = value;
        this.get();
    }
    get filter() {
        return this._filter;
    }
    set maxResultCount(value) {
        this._maxResultCount = value;
        this.get();
    }
    get maxResultCount() {
        return this._maxResultCount;
    }
    set page(value) {
        if (value === this._page)
            return;
        this._page = value;
        this.get();
    }
    get page() {
        return this._page;
    }
    set totalCount(value) {
        if (value === this._totalCount)
            return;
        this._totalCount = value;
        this.get();
    }
    get totalCount() {
        return this._totalCount;
    }
    set sortKey(value) {
        this._sortKey = value;
        this.get();
    }
    get sortKey() {
        return this._sortKey;
    }
    set sortOrder(value) {
        this._sortOrder = value;
        this.get();
    }
    get sortOrder() {
        return this._sortOrder;
    }
    get query$() {
        return this._query$
            .asObservable()
            .pipe(this.delay, shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * @deprecated Use `requestStatus$` instead.
     */
    get isLoading$() {
        return this._isLoading$.asObservable().pipe(takeUntil(this.destroy$));
    }
    get requestStatus$() {
        return this._requestStatus.asObservable().pipe(takeUntil(this.destroy$));
    }
    constructor() {
        this._filter = '';
        this._maxResultCount = 10;
        this._page = 0;
        this._totalCount = 0;
        this._sortKey = '';
        this._sortOrder = '';
        this._query$ = new ReplaySubject(1);
        this._isLoading$ = new BehaviorSubject(false);
        this._requestStatus = new BehaviorSubject('idle');
        this.destroy$ = new Subject();
        this.get = () => {
            this.resetPageWhenUnchanged();
            this.next();
        };
        this.getWithoutPageReset = () => {
            this.next();
        };
        const injector = inject(Injector);
        const delay = injector.get(LIST_QUERY_DEBOUNCE_TIME, 300);
        this.delay = delay ? debounceTime(delay) : tap();
        this.get();
    }
    hookToQuery(streamCreatorCallback) {
        return this.query$.pipe(tap(() => this._isLoading$.next(true)), tap(() => this._requestStatus.next('loading')), switchMap(query => streamCreatorCallback(query).pipe(catchError(() => {
            this._requestStatus.next('error');
            return EMPTY;
        }), tap(() => this._requestStatus.next('success')), finalize(() => {
            this._isLoading$.next(false);
            this._requestStatus.next('idle');
        }))), filter(Boolean), shareReplay({ bufferSize: 1, refCount: true }), takeUntil(this.destroy$));
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
    resetPageWhenUnchanged() {
        const maxPage = Number(Number(this.totalCount / this._maxResultCount).toFixed());
        const skipCount = this._page * this._maxResultCount;
        if (skipCount !== this._totalCount) {
            return;
        }
        if (this.page === maxPage && this.page > 0) {
            this.page = this.page - 1;
        }
    }
    next() {
        this._query$.next({
            filter: this._filter || undefined,
            maxResultCount: this._maxResultCount,
            skipCount: this._page * this._maxResultCount,
            sorting: this._sortOrder ? `${this._sortKey} ${this._sortOrder}` : undefined,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ListService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ListService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ListService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });

class PermissionService {
    constructor() {
        this.configState = inject(ConfigStateService);
    }
    getGrantedPolicy$(key) {
        return this.getStream().pipe(map(grantedPolicies => this.isPolicyGranted(key, grantedPolicies)));
    }
    getGrantedPolicy(key) {
        const policies = this.getSnapshot();
        return this.isPolicyGranted(key, policies);
    }
    filterItemsByPolicy(items) {
        const policies = this.getSnapshot();
        return items.filter(item => !item.requiredPolicy || this.isPolicyGranted(item.requiredPolicy, policies));
    }
    filterItemsByPolicy$(items) {
        return this.getStream().pipe(map(policies => items.filter(item => !item.requiredPolicy || this.isPolicyGranted(item.requiredPolicy, policies))));
    }
    isPolicyGranted(key, grantedPolicies) {
        if (!key)
            return true;
        const orRegexp = /\|\|/g;
        const andRegexp = /&&/g;
        // TODO: Allow combination of ANDs & ORs
        if (orRegexp.test(key)) {
            const keys = key.split('||').filter(Boolean);
            if (keys.length < 2)
                return false;
            return keys.some(k => this.getPolicy(k.trim(), grantedPolicies));
        }
        else if (andRegexp.test(key)) {
            const keys = key.split('&&').filter(Boolean);
            if (keys.length < 2)
                return false;
            return keys.every(k => this.getPolicy(k.trim(), grantedPolicies));
        }
        return this.getPolicy(key, grantedPolicies);
    }
    getStream() {
        return this.configState.getAll$().pipe(map(this.mapToPolicies));
    }
    getSnapshot() {
        return this.mapToPolicies(this.configState.getAll());
    }
    mapToPolicies(applicationConfiguration) {
        return applicationConfiguration?.auth?.grantedPolicies || {};
    }
    getPolicy(key, grantedPolicies) {
        return grantedPolicies[key] || false;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PermissionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PermissionService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PermissionService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class ReplaceableComponentsService {
    get replaceableComponents$() {
        return this.store.sliceState(state => state);
    }
    get replaceableComponents() {
        return this.store.state;
    }
    get onUpdate$() {
        return this.store.sliceUpdate(state => state);
    }
    constructor() {
        this.ngZone = inject(NgZone);
        this.router = inject(Router);
        this.store = new InternalStore([]);
    }
    add(replaceableComponent, reload) {
        const replaceableComponents = [...this.store.state];
        const index = replaceableComponents.findIndex(component => component.key === replaceableComponent.key);
        if (index > -1) {
            replaceableComponents[index] = replaceableComponent;
        }
        else {
            replaceableComponents.push(replaceableComponent);
        }
        this.store.set(replaceableComponents);
        if (reload)
            reloadRoute(this.router, this.ngZone);
    }
    get(replaceableComponentKey) {
        return this.replaceableComponents.find(component => component.key === replaceableComponentKey);
    }
    get$(replaceableComponentKey) {
        return this.replaceableComponents$.pipe(map(components => components.find(component => component.key === replaceableComponentKey)));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ReplaceableComponentsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ReplaceableComponentsService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ReplaceableComponentsService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });

// source : https://github.com/armanozak/demo-angular-server-specific-interceptors
class ExternalHttpClient extends HttpClient {
    request(first, url, options = {}) {
        if (typeof first === 'string') {
            this.#setPlaceholderContext(options);
            return super.request(first, url || '', options);
        }
        this.#setPlaceholderContext(first);
        return super.request(first);
    }
    #setPlaceholderContext(optionsOrRequest) {
        optionsOrRequest.context ??= new HttpContext();
        optionsOrRequest.context.set(IS_EXTERNAL_REQUEST, true);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ExternalHttpClient, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ExternalHttpClient, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ExternalHttpClient, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class RestService {
    constructor() {
        this.options = inject(CORE_OPTIONS);
        this.http = inject(HttpClient);
        this.externalHttp = inject(ExternalHttpClient);
        this.environment = inject(EnvironmentService);
        this.httpErrorReporter = inject(HttpErrorReporterService);
    }
    getApiFromStore(apiName) {
        return this.environment.getApiUrl(apiName);
    }
    handleError(err) {
        this.httpErrorReporter.reportError(err);
        return throwError(() => err);
    }
    request(request, config, api) {
        config = config || {};
        api = api || this.getApiFromStore(config.apiName);
        const { method, params, ...options } = request;
        const { observe = "body" /* Rest.Observe.Body */, skipHandleError, responseType = "json" /* Rest.ResponseType.JSON */ } = config;
        const url = this.removeDuplicateSlashes(api + request.url);
        const httpClient = this.getHttpClient(config.skipAddingHeader);
        return httpClient
            .request(method, url, {
            observe,
            responseType: responseType,
            ...(params && {
                params: this.getParams(params, config.httpParamEncoder),
            }),
            ...options,
        })
            .pipe(catchError(err => (skipHandleError ? throwError(() => err) : this.handleError(err))));
    }
    getHttpClient(isExternal) {
        return isExternal ? this.externalHttp : this.http;
    }
    getParams(params, encoder) {
        const filteredParams = Object.entries(params).reduce((acc, [key, value]) => {
            if (isUndefinedOrEmptyString(value))
                return acc;
            if (value === null && !this.options.sendNullsAsQueryParam)
                return acc;
            acc[key] = value;
            return acc;
        }, {});
        return encoder
            ? new HttpParams({ encoder, fromObject: filteredParams })
            : new HttpParams({ fromObject: filteredParams });
    }
    removeDuplicateSlashes(url) {
        return url.replace(/([^:]\/)\/+/g, '$1');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RestService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RestService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RestService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

const NavigationEvent = {
    Cancel: NavigationCancel,
    End: NavigationEnd,
    Error: NavigationError,
    Start: NavigationStart,
};
class RouterEvents {
    #previousNavigation;
    #currentNavigation;
    constructor() {
        this.router = inject(Router);
        this.#previousNavigation = signal(undefined);
        this.previousNavigation = this.#previousNavigation.asReadonly();
        this.#currentNavigation = signal(undefined);
        this.currentNavigation = this.#currentNavigation.asReadonly();
        this.listenToNavigation();
    }
    listenToNavigation() {
        const routerEvent$ = this.router.events.pipe(filter(e => e instanceof NavigationEvent.End && !e.url.includes('error')));
        routerEvent$.subscribe(event => {
            this.#previousNavigation.set(this.currentNavigation());
            this.#currentNavigation.set(event.url);
        });
    }
    getEvents(...eventTypes) {
        const filterRouterEvents = (event) => eventTypes.some(type => event instanceof type);
        return this.router.events.pipe(filter(filterRouterEvents));
    }
    getNavigationEvents(...navigationEventKeys) {
        const filterNavigationEvents = (event) => navigationEventKeys.some(key => event instanceof NavigationEvent[key]);
        return this.router.events.pipe(filter(filterNavigationEvents));
    }
    getAllEvents() {
        return this.router.events;
    }
    getAllNavigationEvents() {
        const keys = Object.keys(NavigationEvent);
        return this.getNavigationEvents(...keys);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RouterEvents, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RouterEvents, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RouterEvents, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });

class RouterWaitService {
    constructor() {
        this.routerEvents = inject(RouterEvents);
        this.store = new InternalStore({ loading: false });
        this.destroy$ = new Subject();
        const injector = inject(Injector);
        this.delay = injector.get(LOADER_DELAY, 500);
        this.updateLoadingStatusOnNavigationEvents();
    }
    updateLoadingStatusOnNavigationEvents() {
        this.routerEvents
            .getAllNavigationEvents()
            .pipe(map(event => event instanceof NavigationStart), switchMap(condition => condition
            ? this.delay === 0
                ? of(true)
                : timer(this.delay || 0).pipe(mapTo(true), takeUntil(this.destroy$))
            : of(false)), tap(() => this.destroy$.next()))
            .subscribe(status => {
            this.setLoading(status);
        });
    }
    getLoading() {
        return this.store.state.loading;
    }
    getLoading$() {
        return this.store.sliceState(({ loading }) => loading);
    }
    updateLoading$() {
        return this.store.sliceUpdate(({ loading }) => loading);
    }
    setLoading(loading) {
        this.store.patch({ loading });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RouterWaitService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RouterWaitService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RouterWaitService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

// eslint-disable-next-line @typescript-eslint/ban-types
class AbstractTreeService {
    constructor() {
        this._flat$ = new BehaviorSubject([]);
        this._tree$ = new BehaviorSubject([]);
        this._visible$ = new BehaviorSubject([]);
        this.shouldSingularizeRoutes = true;
    }
    get flat() {
        return this._flat$.value;
    }
    get flat$() {
        return this._flat$.asObservable();
    }
    get tree() {
        return this._tree$.value;
    }
    get tree$() {
        return this._tree$.asObservable();
    }
    get visible() {
        return this._visible$.value;
    }
    get visible$() {
        return this._visible$.asObservable();
    }
    filterWith(setOrMap) {
        return this._flat$.value.filter(item => !setOrMap.has(item[this.id]));
    }
    findItemsToRemove(set) {
        return this._flat$.value.reduce((acc, item) => {
            if (!acc.has(item[this.parentId])) {
                return acc;
            }
            const childSet = new Set([item[this.id]]);
            const children = this.findItemsToRemove(childSet);
            return new Set([...acc, ...children]);
        }, set);
    }
    publish(flatItems) {
        this._flat$.next(flatItems);
        this._tree$.next(this.createTree(flatItems));
        this._visible$.next(this.createTree(flatItems.filter(item => !this.hide(item))));
        return flatItems;
    }
    createTree(items) {
        return createTreeFromList(items, item => item[this.id], item => item[this.parentId], item => BaseTreeNode.create(item));
    }
    createGroupedTree(list) {
        const map = createGroupMap(list, this.othersGroup);
        if (!map) {
            return undefined;
        }
        return Array.from(map, ([key, items]) => ({ group: key, items }));
    }
    add(items) {
        let flatItems = [];
        if (!this.shouldSingularizeRoutes) {
            flatItems = [...this.flat, ...items];
        }
        if (this.shouldSingularizeRoutes) {
            const map = new Map();
            items.forEach(item => map.set(item[this.id], item));
            flatItems = this.filterWith(map);
            map.forEach(pushValueTo(flatItems));
        }
        flatItems.sort(this.sort);
        return this.publish(flatItems);
    }
    find(predicate, tree = this.tree) {
        return tree.reduce((acc, node) => {
            if (acc) {
                return acc;
            }
            if (predicate(node)) {
                return node;
            }
            return this.find(predicate, node.children);
        }, null);
    }
    patch(identifier, props) {
        const flatItems = this._flat$.value;
        const index = flatItems.findIndex(item => item[this.id] === identifier);
        if (index < 0) {
            return false;
        }
        flatItems[index] = { ...flatItems[index], ...props };
        flatItems.sort(this.sort);
        return this.publish(flatItems);
    }
    refresh() {
        return this.add([]);
    }
    remove(identifiers) {
        const set = new Set();
        identifiers.forEach(id => set.add(id));
        const setToRemove = this.findItemsToRemove(set);
        const flatItems = this.filterWith(setToRemove);
        return this.publish(flatItems);
    }
    removeByParam(params) {
        if (!params) {
            return null;
        }
        const keys = Object.keys(params);
        if (keys.length === 0) {
            return null;
        }
        const excludedList = this.flat.filter(item => keys.every(key => item[key] === params[key]));
        if (!excludedList?.length) {
            return null;
        }
        for (const item of excludedList) {
            this.removeByParam({ [this.parentId]: item[this.id] });
        }
        const flatItems = this.flat.filter(item => !excludedList.includes(item));
        return this.publish(flatItems);
    }
    search(params, tree = this.tree) {
        const searchKeys = Object.keys(params);
        return tree.reduce((acc, node) => {
            if (acc) {
                return acc;
            }
            if (searchKeys.every(key => node[key] === params[key])) {
                return node;
            }
            return this.search(params, node.children);
        }, null);
    }
    setSingularizeStatus(singularize = true) {
        this.shouldSingularizeRoutes = singularize;
    }
}
class AbstractNavTreeService extends AbstractTreeService {
    constructor() {
        super();
        this.injector = inject(Injector);
        this.id = 'name';
        this.parentId = 'parentName';
        this.hide = (item) => item.invisible || !this.isGranted(item);
        this.sort = (a, b) => {
            return this.compareFunc(a, b);
        };
        const injector = this.injector;
        const configState = this.injector.get(ConfigStateService);
        this.subscription = configState
            .createOnUpdateStream(state => state)
            .subscribe(() => this.refresh());
        this.permissionService = injector.get(PermissionService);
        this.othersGroup = injector.get(OTHERS_GROUP);
        this.compareFunc = injector.get(SORT_COMPARE_FUNC);
    }
    isGranted({ requiredPolicy }) {
        return this.permissionService.getGrantedPolicy(requiredPolicy);
    }
    hasChildren(identifier) {
        const node = this.find(item => item[this.id] === identifier);
        return Boolean(node?.children?.length);
    }
    hasInvisibleChild(identifier) {
        const node = this.find(item => item[this.id] === identifier);
        return node?.children?.some(child => child.invisible) || false;
    }
    /* istanbul ignore next */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbstractNavTreeService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbstractNavTreeService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbstractNavTreeService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });
class RoutesService extends AbstractNavTreeService {
    hasPathOrChild(item) {
        return Boolean(item.path) || this.hasChildren(item.name);
    }
    get groupedVisible() {
        return this.createGroupedTree(this.visible.filter(item => this.hasPathOrChild(item)));
    }
    get groupedVisible$() {
        return this.visible$.pipe(map$1(items => items.filter(item => this.hasPathOrChild(item))), map$1(visible => this.createGroupedTree(visible)));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RoutesService, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RoutesService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RoutesService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class SubscriptionService {
    constructor() {
        this.subscription = new Subscription();
    }
    get isClosed() {
        return this.subscription.closed;
    }
    addOne(source$, nextOrObserver, error) {
        const subscription = source$.subscribe(nextOrObserver, error);
        this.subscription.add(subscription);
        return subscription;
    }
    closeAll() {
        this.subscription.unsubscribe();
    }
    closeOne(subscription) {
        this.removeOne(subscription);
        if (subscription) {
            subscription.unsubscribe();
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    removeOne(subscription) {
        if (!subscription)
            return;
        this.subscription.remove(subscription);
    }
    reset() {
        this.subscription.unsubscribe();
        this.subscription = new Subscription();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SubscriptionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SubscriptionService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SubscriptionService, decorators: [{
            type: Injectable
        }] });

const trackBy = (key) => (_, item) => item[key];
const trackByDeep = (
// eslint-disable-next-line @typescript-eslint/ban-types
...keys) => (_, item) => keys.reduce((acc, key) => acc[key], item);
class TrackByService {
    constructor() {
        this.by = trackBy;
        this.byDeep = trackByDeep;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TrackByService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TrackByService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TrackByService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class AbpWindowService {
    constructor() {
        this.document = inject(DOCUMENT);
        this.window = this.document.defaultView;
        this.navigator = this.window.navigator;
    }
    copyToClipboard(text) {
        return this.navigator.clipboard.writeText(text);
    }
    open(url, target, features) {
        return this.window.open(url, target, features);
    }
    reloadPage() {
        this.window.location.reload();
    }
    downloadBlob(blob, fileName) {
        const blobUrl = this.window.URL.createObjectURL(blob);
        const a = this.document.createElement('a');
        a.style.display = 'none';
        a.href = blobUrl;
        a.download = fileName;
        this.document.body.appendChild(a);
        a.dispatchEvent(new MouseEvent('click', {
            bubbles: true,
            cancelable: true,
            view: this.window,
        }));
        this.window.URL.revokeObjectURL(blobUrl);
        this.document.body.removeChild(a);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpWindowService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpWindowService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpWindowService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class InternetConnectionService {
    constructor() {
        this.document = inject(DOCUMENT);
        this.window = this.document.defaultView;
        this.navigator = this.window.navigator;
        this.status$ = new BehaviorSubject(this.navigator.onLine);
        this.status = signal(this.navigator.onLine);
        this.networkStatus = computed(() => this.status());
        this.window.addEventListener('offline', () => this.setStatus(false));
        this.window.addEventListener('online', () => this.setStatus(true));
    }
    setStatus(val) {
        this.status.set(val);
        this.status$.next(val);
    }
    get networkStatus$() {
        return this.status$.asObservable();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: InternetConnectionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: InternetConnectionService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: InternetConnectionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

class LocalStorageListenerService {
    constructor() {
        this.window = inject(DOCUMENT).defaultView;
        this.window.addEventListener('storage', event => {
            if (event.key === 'access_token') {
                const tokenRemoved = event.newValue === null;
                const tokenAdded = event.oldValue === null && event.newValue !== null;
                if (tokenRemoved || tokenAdded) {
                    this.window.location.assign('/');
                }
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalStorageListenerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalStorageListenerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalStorageListenerService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

class AbpTitleStrategy extends TitleStrategy {
    constructor() {
        super();
        this.title = inject(Title);
        this.localizationService = inject(LocalizationService);
        this.disableProjectName = inject(DISABLE_PROJECT_NAME, { optional: true });
        this.langugageChange = toSignal(this.localizationService.languageChange$);
        effect(() => {
            if (this.langugageChange()) {
                this.updateTitle(this.routerState);
            }
        });
    }
    updateTitle(routerState) {
        this.routerState = routerState;
        const title = this.buildTitle(routerState);
        const projectName = this.localizationService.instant({
            key: '::AppName',
            defaultValue: 'MyProjectName',
        });
        if (!title) {
            return this.title.setTitle(projectName);
        }
        let localizedText = this.localizationService.instant({ key: title, defaultValue: title });
        if (!this.disableProjectName) {
            localizedText += ` | ${projectName}`;
        }
        this.title.setTitle(localizedText);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpTitleStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpTitleStrategy, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpTitleStrategy, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

class TimezoneService {
    constructor() {
        this.configState = inject(ConfigStateService);
        this.document = inject(DOCUMENT);
        this.cookieKey = '__timezone';
        this.configState.getOne$('setting').subscribe(settings => {
            this.timeZoneNameFromSettings = settings?.values?.['Abp.Timing.TimeZone'];
        });
        this.configState.getOne$('clock').subscribe(clock => {
            this.isUtcClockEnabled = clock?.kind === 'Utc';
        });
    }
    /**
     * Returns the effective timezone to be used across the application.
     *
     * This value is determined based on the clock kind setting in the configuration:
     * - If clock kind is not equal to Utc, the browser's local timezone is returned.
     * - If clock kind is equal to Utc, the configured timezone (`timeZoneNameFromSettings`) is returned if available;
     *   otherwise, the browser's timezone is used as a fallback.
     *
     * @returns The IANA timezone name (e.g., 'Europe/Istanbul', 'America/New_York').
     */
    get timezone() {
        if (!this.isUtcClockEnabled) {
            return this.getBrowserTimezone();
        }
        return this.timeZoneNameFromSettings || this.getBrowserTimezone();
    }
    /**
     * Retrieves the browser's local timezone based on the user's system settings.
     *
     * @returns The IANA timezone name (e.g., 'Europe/Istanbul', 'America/New_York').
     */
    getBrowserTimezone() {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    /**
     * Sets the application's timezone in a cookie to persist the user's selected timezone.
     *
     * This method sets the cookie only if the clock kind setting is set to UTC.
     * The cookie is stored using the key defined by `this.cookieKey` and applied to the root path (`/`).
     *
     * @param timezone - The IANA timezone name to be stored (e.g., 'Europe/Istanbul').
     */
    setTimezone(timezone) {
        if (this.isUtcClockEnabled) {
            this.document.cookie = `${this.cookieKey}=${timezone}; path=/`;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimezoneService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimezoneService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimezoneService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

class TimeService {
    constructor() {
        this.locale = inject(LOCALE_ID);
    }
    /**
     * Returns the current date and time in the specified timezone.
     *
     * @param zone - An IANA timezone name (e.g., 'Europe/Istanbul', 'UTC'); defaults to the system's local timezone.
     * @returns A Luxon DateTime instance representing the current time in the given timezone.
     */
    now(zone = 'local') {
        return DateTime.now().setZone(zone);
    }
    /**
     * Converts the input date to the specified timezone, applying any timezone and daylight saving time (DST) adjustments.
     *
     * This method:
     * 1. Parses the input value into a Luxon DateTime object.
     * 2. Applies the specified IANA timezone, including any DST shifts based on the given date.
     *
     * @param value - The ISO string or Date object to convert.
     * @param zone - An IANA timezone name (e.g., 'America/New_York').
     * @returns A Luxon DateTime instance adjusted to the specified timezone and DST rules.
     */
    toZone(value, zone) {
        return DateTime.fromISO(value instanceof Date ? value.toISOString() : value, {
            zone,
        });
    }
    /**
     * Formats the input date by applying timezone and daylight saving time (DST) adjustments.
     *
     * This method:
     * 1. Converts the input date to the specified timezone.
     * 2. Formats the result using the given format and locale, reflecting any timezone or DST shifts.
     *
     * @param value - The ISO string or Date object to format.
     * @param format - The format string (default: 'ff').
     * @param zone - Optional IANA timezone name (e.g., 'America/New_York'); defaults to the system's local timezone.
     * @returns A formatted date string adjusted for the given timezone and DST rules.
     */
    format(value, format = 'ff', zone = 'local') {
        return this.toZone(value, zone).setLocale(this.locale).toFormat(format);
    }
    /**
     * Formats a date using the standard time offset (ignoring daylight saving time) for the specified timezone.
     *
     * This method:
     * 1. Converts the input date to UTC.
     * 2. Calculates the standard UTC offset for the given timezone (based on January 1st to avoid DST).
     * 3. Applies the standard offset manually to the UTC time.
     * 4. Formats the result using the specified format and locale, without applying additional timezone shifts.
     *
     * @param value - The ISO string or Date object to format.
     * @param format - The Luxon format string (default: 'ff').
     * @param zone - Optional IANA timezone name (e.g., 'America/New_York'); if omitted, system local timezone is used.
     * @returns A formatted date string adjusted by standard time (non-DST).
     */
    formatDateWithStandardOffset(value, format = 'ff', zone) {
        const utcDate = typeof value === 'string'
            ? DateTime.fromISO(value, { zone: 'UTC' })
            : DateTime.fromJSDate(value, { zone: 'UTC' });
        if (!utcDate.isValid)
            return '';
        const targetZone = zone ?? DateTime.local().zoneName;
        const januaryDate = DateTime.fromObject({ year: utcDate.year, month: 1, day: 1 }, { zone: targetZone });
        const standardOffset = januaryDate.offset;
        const dateWithStandardOffset = utcDate.plus({ minutes: standardOffset });
        return dateWithStandardOffset.setZone('UTC').setLocale(this.locale).toFormat(format);
    }
    /**
     * Formats the input date using its original clock time, without converting based on timezone or DST
     *
     * This method:
     * 1. Converts the input date to ISO string.
     * 2. Calculates the date time in UTC, keeping the local time.
     * 3. Formats the result using the specified format and locale, without shifting timezones.
     *
     * @param value - The ISO string or Date object to format.
     * @param format - The format string (default: 'ff').
     * @returns A formatted date string without applying timezone.
     */
    formatWithoutTimeZone(value, format = 'ff') {
        const isoString = value instanceof Date ? value.toISOString() : value;
        const dateTime = DateTime.fromISO(isoString)
            .setZone('utc', { keepLocalTime: true })
            .setLocale(this.locale);
        return dateTime.toFormat(format);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimeService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimeService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimeService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ContainerStrategy {
    constructor(containerRef) {
        this.containerRef = containerRef;
    }
    prepare() { }
}
class ClearContainerStrategy extends ContainerStrategy {
    getIndex() {
        return 0;
    }
    prepare() {
        this.containerRef.clear();
    }
}
class InsertIntoContainerStrategy extends ContainerStrategy {
    constructor(containerRef, index) {
        super(containerRef);
        this.index = index;
    }
    getIndex() {
        return Math.min(Math.max(0, this.index), this.containerRef.length);
    }
}
const CONTAINER_STRATEGY = {
    Clear(containerRef) {
        return new ClearContainerStrategy(containerRef);
    },
    Append(containerRef) {
        return new InsertIntoContainerStrategy(containerRef, containerRef.length);
    },
    Prepend(containerRef) {
        return new InsertIntoContainerStrategy(containerRef, 0);
    },
    Insert(containerRef, index) {
        return new InsertIntoContainerStrategy(containerRef, index);
    },
};

class ContentSecurityStrategy {
    constructor(nonce) {
        this.nonce = nonce;
    }
}
class LooseContentSecurityStrategy extends ContentSecurityStrategy {
    constructor(nonce) {
        super(nonce);
    }
    applyCSP(element) {
        if (this.nonce) {
            element.setAttribute('nonce', this.nonce);
        }
    }
}
class NoContentSecurityStrategy extends ContentSecurityStrategy {
    constructor() {
        super();
    }
    applyCSP(_) { }
}
const CONTENT_SECURITY_STRATEGY = {
    Loose(nonce) {
        return new LooseContentSecurityStrategy(nonce);
    },
    None() {
        return new NoContentSecurityStrategy();
    },
};

class ContentStrategy {
    constructor(content, domStrategy = DOM_STRATEGY.AppendToHead(), contentSecurityStrategy = CONTENT_SECURITY_STRATEGY.None(), options = {}) {
        this.content = content;
        this.domStrategy = domStrategy;
        this.contentSecurityStrategy = contentSecurityStrategy;
        this.options = options;
    }
    insertElement() {
        const element = this.createElement();
        if (this.options && Object.keys(this.options).length > 0) {
            Object.keys(this.options).forEach(key => {
                if (this.options[key]) {
                    element[key] = this.options[key];
                }
            });
        }
        this.contentSecurityStrategy.applyCSP(element);
        this.domStrategy.insertElement(element);
        return element;
    }
}
class StyleContentStrategy extends ContentStrategy {
    createElement() {
        const element = inject(DOCUMENT).createElement('style');
        element.textContent = this.content;
        return element;
    }
}
class ScriptContentStrategy extends ContentStrategy {
    createElement() {
        const element = inject(DOCUMENT).createElement('script');
        element.textContent = this.content;
        return element;
    }
}
const CONTENT_STRATEGY = {
    AppendScriptToBody(content, options) {
        return new ScriptContentStrategy(content, DOM_STRATEGY.AppendToBody(), undefined, options);
    },
    AppendScriptToHead(content, options) {
        return new ScriptContentStrategy(content, DOM_STRATEGY.AppendToHead(), undefined, options);
    },
    AppendStyleToHead(content, options) {
        return new StyleContentStrategy(content, DOM_STRATEGY.AppendToHead(), undefined, options);
    },
    PrependStyleToHead(content, options) {
        return new StyleContentStrategy(content, DOM_STRATEGY.PrependToHead(), undefined, options);
    },
};

class ContextStrategy {
    constructor(context) {
        this.context = context;
    }
    setContext(componentRef) {
        return this.context;
    }
}
class NoContextStrategy extends ContextStrategy {
    constructor() {
        super(undefined);
    }
}
class ComponentContextStrategy extends ContextStrategy {
    setContext(componentRef) {
        Object.keys(this.context).forEach(key => (componentRef.instance[key] = this.context[key]));
        componentRef.changeDetectorRef.detectChanges();
        return this.context;
    }
}
class TemplateContextStrategy extends ContextStrategy {
    setContext() {
        return this.context;
    }
}
const CONTEXT_STRATEGY = {
    None() {
        return new NoContextStrategy();
    },
    Component(context) {
        return new ComponentContextStrategy(context);
    },
    Template(context) {
        return new TemplateContextStrategy(context);
    },
};

class LoadingStrategy {
    constructor(path, domStrategy = DOM_STRATEGY.AppendToHead(), crossOriginStrategy = CROSS_ORIGIN_STRATEGY.Anonymous()) {
        this.path = path;
        this.domStrategy = domStrategy;
        this.crossOriginStrategy = crossOriginStrategy;
    }
    createStream() {
        this.element = this.createElement();
        return of(null).pipe(switchMap(() => fromLazyLoad(this.element, this.domStrategy, this.crossOriginStrategy)));
    }
}
class ScriptLoadingStrategy extends LoadingStrategy {
    constructor(src, domStrategy, crossOriginStrategy) {
        super(src, domStrategy, crossOriginStrategy);
    }
    createElement() {
        const element = document.createElement('script');
        element.src = this.path;
        return element;
    }
}
class StyleLoadingStrategy extends LoadingStrategy {
    constructor(href, domStrategy, crossOriginStrategy) {
        super(href, domStrategy, crossOriginStrategy);
    }
    createElement() {
        const element = document.createElement('link');
        element.rel = 'stylesheet';
        element.href = this.path;
        return element;
    }
}
const LOADING_STRATEGY = {
    AppendScriptToBody(src) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToBody(), CROSS_ORIGIN_STRATEGY.None());
    },
    AppendAnonymousScriptToBody(src, integrity) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToBody(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    AppendAnonymousScriptToHead(src, integrity) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    AppendAnonymousStyleToHead(src, integrity) {
        return new StyleLoadingStrategy(src, DOM_STRATEGY.AppendToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    PrependAnonymousScriptToHead(src, integrity) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.PrependToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    PrependAnonymousStyleToHead(src, integrity) {
        return new StyleLoadingStrategy(src, DOM_STRATEGY.PrependToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
};

class ProjectionStrategy {
    constructor(content) {
        this.content = content;
    }
}
class ComponentProjectionStrategy extends ProjectionStrategy {
    constructor(component, containerStrategy, contextStrategy = CONTEXT_STRATEGY.None()) {
        super(component);
        this.containerStrategy = containerStrategy;
        this.contextStrategy = contextStrategy;
    }
    injectContent(injector) {
        this.containerStrategy.prepare();
        const resolver = injector.get(ComponentFactoryResolver);
        const factory = resolver.resolveComponentFactory(this.content);
        const componentRef = this.containerStrategy.containerRef.createComponent(factory, this.containerStrategy.getIndex(), injector);
        this.contextStrategy.setContext(componentRef);
        return componentRef;
    }
}
class RootComponentProjectionStrategy extends ProjectionStrategy {
    constructor(component, contextStrategy = CONTEXT_STRATEGY.None(), domStrategy = DOM_STRATEGY.AppendToBody()) {
        super(component);
        this.contextStrategy = contextStrategy;
        this.domStrategy = domStrategy;
    }
    injectContent(injector) {
        const appRef = injector.get(ApplicationRef);
        const resolver = injector.get(ComponentFactoryResolver);
        const componentRef = resolver
            .resolveComponentFactory(this.content)
            .create(injector);
        this.contextStrategy.setContext(componentRef);
        appRef.attachView(componentRef.hostView);
        const element = componentRef.hostView.rootNodes[0];
        this.domStrategy.insertElement(element);
        return componentRef;
    }
}
class TemplateProjectionStrategy extends ProjectionStrategy {
    constructor(templateRef, containerStrategy, contextStrategy = CONTEXT_STRATEGY.None()) {
        super(templateRef);
        this.containerStrategy = containerStrategy;
        this.contextStrategy = contextStrategy;
    }
    injectContent() {
        this.containerStrategy.prepare();
        const embeddedViewRef = this.containerStrategy.containerRef.createEmbeddedView(this.content, this.contextStrategy.context, this.containerStrategy.getIndex());
        embeddedViewRef.detectChanges();
        return embeddedViewRef;
    }
}
const PROJECTION_STRATEGY = {
    AppendComponentToBody(component, context) {
        return new RootComponentProjectionStrategy(component, context && CONTEXT_STRATEGY.Component(context));
    },
    AppendComponentToContainer(component, containerRef, context) {
        return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Append(containerRef), context && CONTEXT_STRATEGY.Component(context));
    },
    AppendTemplateToContainer(templateRef, containerRef, context) {
        return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Append(containerRef), context && CONTEXT_STRATEGY.Template(context));
    },
    PrependComponentToContainer(component, containerRef, context) {
        return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Prepend(containerRef), context && CONTEXT_STRATEGY.Component(context));
    },
    PrependTemplateToContainer(templateRef, containerRef, context) {
        return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Prepend(containerRef), context && CONTEXT_STRATEGY.Template(context));
    },
    ProjectComponentToContainer(component, containerRef, context) {
        return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Clear(containerRef), context && CONTEXT_STRATEGY.Component(context));
    },
    ProjectTemplateToContainer(templateRef, containerRef, context) {
        return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Clear(containerRef), context && CONTEXT_STRATEGY.Template(context));
    },
};

class DomStrategyService {
    constructor() {
        this.document = inject(DOCUMENT);
    }
    afterElement(el) {
        return new DomStrategy(() => el, 'afterend');
    }
    beforeElement(el) {
        return new DomStrategy(() => el, 'beforebegin');
    }
    appendToBody() {
        return new DomStrategy(() => this.document.body, 'beforeend');
    }
    appendToHead() {
        return new DomStrategy(() => this.document.head, 'beforeend');
    }
    prependToHead() {
        return new DomStrategy(() => this.document.head, 'afterbegin');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DomStrategyService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DomStrategyService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DomStrategyService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class AbpApplicationConfigurationService {
    constructor() {
        this.restService = inject(RestService);
        this.apiName = 'abp';
        this.get = (options, config) => this.restService.request({
            method: 'GET',
            url: '/api/abp/application-configuration',
            params: { includeLocalizationResources: options.includeLocalizationResources },
        }, { apiName: this.apiName, ...config });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpApplicationConfigurationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpApplicationConfigurationService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpApplicationConfigurationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class AbpApplicationLocalizationService {
    constructor() {
        this.restService = inject(RestService);
        this.apiName = 'abp';
        this.get = (input, config) => this.restService.request({
            method: 'GET',
            url: '/api/abp/application-localization',
            params: { cultureName: input.cultureName, onlyDynamics: input.onlyDynamics },
        }, { apiName: this.apiName, ...config });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpApplicationLocalizationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpApplicationLocalizationService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpApplicationLocalizationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ConfigStateService {
    setState(config) {
        this.store.set(config);
    }
    get createOnUpdateStream() {
        return this.store.sliceUpdate;
    }
    constructor() {
        this.abpConfigService = inject(AbpApplicationConfigurationService);
        this.abpApplicationLocalizationService = inject(AbpApplicationLocalizationService);
        this.includeLocalizationResources = inject(INCUDE_LOCALIZATION_RESOURCES_TOKEN, { optional: true });
        this.updateSubject = new Subject();
        this.store = new InternalStore({});
        this.initUpdateStream();
    }
    initUpdateStream() {
        this.updateSubject
            .pipe(switchMap(() => this.abpConfigService.get({
            includeLocalizationResources: !!this.includeLocalizationResources,
        })))
            .pipe(switchMap(appState => this.getLocalizationAndCombineWithAppState(appState)))
            .subscribe(res => this.store.set(res));
    }
    getLocalizationAndCombineWithAppState(appState) {
        if (!appState.localization.currentCulture.cultureName) {
            throw new Error('culture name should defined');
        }
        const cultureName = this.uiCultureFromAuthCodeFlow ?? appState.localization.currentCulture.cultureName;
        return this.getlocalizationResource(cultureName).pipe(map(result => ({ ...appState, localization: { ...appState.localization, ...result } })), tap(() => (this.uiCultureFromAuthCodeFlow = undefined)));
    }
    getlocalizationResource(cultureName) {
        return this.abpApplicationLocalizationService.get({
            cultureName: cultureName,
            onlyDynamics: false,
        });
    }
    refreshAppState() {
        this.updateSubject.next();
        return this.createOnUpdateStream(state => state).pipe(take(1));
    }
    refreshLocalization(lang) {
        if (this.includeLocalizationResources) {
            return this.refreshAppState().pipe(map(() => null));
        }
        return this.getlocalizationResource(lang)
            .pipe(tap(result => this.store.patch({ localization: { ...this.store.state.localization, ...result } })))
            .pipe(map(() => null));
    }
    getOne$(key) {
        return this.store.sliceState(state => state[key]);
    }
    getOne(key) {
        return this.store.state[key];
    }
    getAll$() {
        return this.store.sliceState(state => state);
    }
    getAll() {
        return this.store.state;
    }
    getDeep$(keys) {
        keys = splitKeys(keys);
        return this.store
            .sliceState(state => state)
            .pipe(map(state => {
            return keys.reduce((acc, val) => {
                if (acc) {
                    return acc[val];
                }
                return undefined;
            }, state);
        }));
    }
    getDeep(keys) {
        keys = splitKeys(keys);
        return keys.reduce((acc, val) => {
            if (acc) {
                return acc[val];
            }
            return undefined;
        }, this.store.state);
    }
    getFeature(key) {
        return this.store.state.features?.values?.[key];
    }
    getFeature$(key) {
        return this.store.sliceState(state => state.features?.values?.[key]);
    }
    getFeatures(keys) {
        const { features } = this.store.state;
        if (!features)
            return;
        return keys.reduce((acc, key) => ({ ...acc, [key]: features.values[key] }), {});
    }
    getFeatures$(keys) {
        return this.store.sliceState(({ features }) => {
            if (!features?.values)
                return;
            return keys.reduce((acc, key) => ({ ...acc, [key]: features.values[key] }), {});
        });
    }
    isFeatureEnabled(key, features) {
        return features.values[key] === 'true';
    }
    getFeatureIsEnabled(key) {
        return this.isFeatureEnabled(key, this.store.state.features);
    }
    getFeatureIsEnabled$(key) {
        return this.store.sliceState(state => this.isFeatureEnabled(key, state.features));
    }
    getSetting(key) {
        return this.store.state.setting?.values?.[key];
    }
    getSetting$(key) {
        return this.store.sliceState(state => state.setting?.values?.[key]);
    }
    getSettings(keyword) {
        const settings = this.store.state.setting?.values || {};
        if (!keyword)
            return settings;
        const keysFound = Object.keys(settings).filter(key => key.indexOf(keyword) > -1);
        return keysFound.reduce((acc, key) => {
            acc[key] = settings[key];
            return acc;
        }, {});
    }
    getSettings$(keyword) {
        return this.store
            .sliceState(state => state.setting?.values)
            .pipe(map((settings = {}) => {
            if (!keyword)
                return settings;
            const keysFound = Object.keys(settings).filter(key => key.indexOf(keyword) > -1);
            return keysFound.reduce((acc, key) => {
                acc[key] = settings[key];
                return acc;
            }, {});
        }));
    }
    getGlobalFeatures() {
        return this.store.state.globalFeatures;
    }
    getGlobalFeatures$() {
        return this.store.sliceState(state => state.globalFeatures);
    }
    isGlobalFeatureEnabled(key, globalFeatures) {
        const features = globalFeatures.enabledFeatures || [];
        return features.some(f => key === f);
    }
    getGlobalFeatureIsEnabled(key) {
        return this.isGlobalFeatureEnabled(key, this.store.state.globalFeatures);
    }
    getGlobalFeatureIsEnabled$(key) {
        return this.store.sliceState(state => this.isGlobalFeatureEnabled(key, state.globalFeatures));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ConfigStateService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ConfigStateService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ConfigStateService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });
function splitKeys(keys) {
    if (typeof keys === 'string') {
        keys = keys.split('.');
    }
    if (!Array.isArray(keys)) {
        throw new Error('The argument must be a dot string or an string array.');
    }
    return keys;
}

class LocalizationService {
    /**
     * Returns currently selected language
     * Even though this looks like it's redundant to return the same value as `getLanguage()`,
     * it's actually not. This could be invoked any time, and the latestLang could be different from the
     * sessionState.getLanguage() value.
     */
    get currentLang() {
        return this.latestLang || this.sessionState.getLanguage();
    }
    get currentLang$() {
        return this.sessionState.getLanguage$();
    }
    get languageChange$() {
        return this._languageChange$.asObservable();
    }
    constructor() {
        this.sessionState = inject(SessionStateService);
        this.injector = inject(Injector);
        this.configState = inject(ConfigStateService);
        this.latestLang = this.sessionState.getLanguage();
        this._languageChange$ = new Subject();
        this.uiLocalizations$ = new BehaviorSubject(new Map());
        this.localizations$ = new BehaviorSubject(new Map());
        const otherInstance = inject(LocalizationService, { optional: true, skipSelf: true });
        if (otherInstance)
            throw new Error('LocalizationService should have only one instance.');
        this.listenToSetLanguage();
        this.initLocalizationValues();
    }
    initLocalizationValues() {
        localizations$.subscribe(val => this.addLocalization(val));
        const legacyResources$ = this.configState.getDeep$('localization.values');
        const remoteLocalizations$ = this.configState.getDeep$('localization.resources');
        const currentLanguage$ = this.sessionState.getLanguage$();
        const uiLocalizations$ = combineLatest([currentLanguage$, this.uiLocalizations$]).pipe(map(([currentLang, localizations]) => localizations.get(currentLang)));
        combineLatest([legacyResources$, remoteLocalizations$, uiLocalizations$])
            .pipe(map(([legacy, resource, local]) => {
            if (!resource) {
                return;
            }
            const remote = combineLegacyandNewResources(legacy || {}, resource);
            if (remote) {
                if (!local) {
                    local = new Map();
                }
                Object.entries(remote).forEach(entry => {
                    const resourceName = entry[0];
                    const remoteTexts = entry[1];
                    let resource = local?.get(resourceName) || {};
                    resource = { ...resource, ...remoteTexts };
                    local?.set(resourceName, resource);
                });
            }
            return local;
        }), filter(Boolean))
            .subscribe(val => this.localizations$.next(val));
    }
    addLocalization(localizations) {
        if (!localizations)
            return;
        const localizationMap = this.uiLocalizations$.value;
        localizations.forEach(loc => {
            const cultureMap = localizationMap.get(loc.culture) || new Map();
            loc.resources.forEach(res => {
                let resource = cultureMap.get(res.resourceName) || {};
                resource = { ...resource, ...res.texts };
                cultureMap.set(res.resourceName, resource);
            });
            localizationMap.set(loc.culture, cultureMap);
        });
        this.uiLocalizations$.next(localizationMap);
    }
    listenToSetLanguage() {
        this.sessionState
            .onLanguageChange$()
            .pipe(filter(lang => this.configState.getDeep('localization.currentCulture.cultureName') !== lang), switchMap(lang => this.configState.refreshLocalization(lang).pipe(map(() => lang))), filter(Boolean), switchMap(lang => from(this.registerLocale(lang).then(() => lang))))
            .subscribe(lang => this._languageChange$.next(lang));
    }
    registerLocale(locale) {
        const { registerLocaleFn } = this.injector.get(CORE_OPTIONS);
        return registerLocaleFn(locale).then(module => {
            if (module?.default)
                registerLocaleData(module.default);
            this.latestLang = locale;
        });
    }
    /**
     * Returns an observable localized text with the given interpolation parameters in current language.
     * @param key Localizaton key to replace with localized text
     * @param interpolateParams Values to interpolate
     */
    get(key, ...interpolateParams) {
        return this.configState
            .getAll$()
            .pipe(map(state => this.getLocalization(state, key, ...interpolateParams)));
    }
    getResource(resourceName) {
        return this.localizations$.value.get(resourceName);
    }
    getResource$(resourceName) {
        return this.localizations$.pipe(map(res => res.get(resourceName)));
    }
    /**
     * Returns localized text with the given interpolation parameters in current language.
     * @param key Localization key to replace with localized text
     * @param interpolateParams Values to intepolate.
     */
    instant(key, ...interpolateParams) {
        return this.getLocalization(this.configState.getAll(), key, ...interpolateParams);
    }
    localize(resourceName, key, defaultValue) {
        return this.configState.getOne$('localization').pipe(map(createLocalizer), map(localize => localize(resourceName, key, defaultValue)));
    }
    localizeSync(resourceName, key, defaultValue) {
        const localization = this.configState.getOne('localization');
        return createLocalizer(localization)(resourceName, key, defaultValue);
    }
    localizeWithFallback(resourceNames, keys, defaultValue) {
        return this.configState.getOne$('localization').pipe(map(createLocalizerWithFallback), map(localizeWithFallback => localizeWithFallback(resourceNames, keys, defaultValue)));
    }
    localizeWithFallbackSync(resourceNames, keys, defaultValue) {
        const localization = this.configState.getOne('localization');
        return createLocalizerWithFallback(localization)(resourceNames, keys, defaultValue);
    }
    getLocalization(state, key, ...interpolateParams) {
        let defaultValue = '';
        if (!key) {
            return defaultValue;
        }
        if (typeof key !== 'string') {
            defaultValue = key.defaultValue;
            key = key.key;
        }
        const keys = key.split('::');
        const warn = (message) => {
            if (isDevMode())
                console.warn(message);
        };
        if (keys.length < 2) {
            warn('The localization source separator (::) not found.');
            return defaultValue || key;
        }
        if (!state.localization)
            return defaultValue || keys[1];
        const sourceName = keys[0] || state.localization.defaultResourceName;
        const sourceKey = keys[1];
        if (sourceName === '_') {
            return defaultValue || sourceKey;
        }
        if (!sourceName) {
            warn('Localization source name is not specified and the defaultResourceName was not defined!');
            return defaultValue || sourceKey;
        }
        const source = this.localizations$.value.get(sourceName);
        if (!source) {
            warn('Could not find localization source: ' + sourceName);
            return defaultValue || sourceKey;
        }
        let localization = source[sourceKey];
        if (typeof localization === 'undefined') {
            return defaultValue || sourceKey;
        }
        interpolateParams = interpolateParams.filter(params => params != null);
        if (localization)
            localization = interpolate(localization, interpolateParams);
        if (typeof localization !== 'string')
            localization = '';
        return localization || defaultValue || key;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalizationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalizationService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalizationService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });
function recursivelyMergeBaseResources(baseResourceName, source) {
    const item = source[baseResourceName];
    if (item.baseResources.length === 0) {
        return item;
    }
    return item.baseResources.reduce((acc, baseResource) => {
        const baseItem = recursivelyMergeBaseResources(baseResource, source);
        const texts = { ...baseItem.texts, ...acc.texts };
        return { ...acc, texts };
    }, item);
}
function mergeResourcesWithBaseResource(resource) {
    const entities = Object.keys(resource).map(key => {
        const newValue = recursivelyMergeBaseResources(key, resource);
        return [key, newValue];
    });
    return entities.reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
}
function combineLegacyandNewResources(legacy, resource) {
    const mergedResource = mergeResourcesWithBaseResource(resource);
    return Object.entries(mergedResource).reduce((acc, [key, value]) => {
        return { ...acc, [key]: value.texts };
    }, legacy);
}

class DynamicLayoutComponent {
    constructor() {
        this.layouts = inject(DYNAMIC_LAYOUTS_TOKEN);
        this.isLayoutVisible = true;
        this.defaultLayout = input(undefined);
        this.router = inject(Router);
        this.route = inject(ActivatedRoute);
        this.routes = inject(RoutesService);
        this.localizationService = inject(LocalizationService);
        this.replaceableComponents = inject(ReplaceableComponentsService);
        this.subscription = inject(SubscriptionService);
        this.routerEvents = inject(RouterEvents);
        this.environment = inject(EnvironmentService);
        const dynamicLayoutComponent = inject(DynamicLayoutComponent, { optional: true, skipSelf: true });
        if (dynamicLayoutComponent) {
            if (isDevMode())
                console.warn('DynamicLayoutComponent must be used only in AppComponent.');
            return;
        }
        this.checkLayoutOnNavigationEnd();
        this.listenToLanguageChange();
        this.listenToEnvironmentChange();
    }
    checkLayoutOnNavigationEnd() {
        const navigationEnd$ = this.routerEvents.getNavigationEvents('End');
        this.subscription.addOne(navigationEnd$, () => this.getLayout());
    }
    getLayout() {
        let expectedLayout = this.getExtractedLayout();
        if (!expectedLayout)
            expectedLayout = "empty" /* eLayoutType.empty */;
        if (this.layoutKey === expectedLayout)
            return;
        const key = this.layouts.get(expectedLayout);
        if (key) {
            this.layout = this.getComponent(key)?.component;
            this.layoutKey = expectedLayout;
        }
        if (!this.layout) {
            this.showLayoutNotFoundError(expectedLayout);
        }
    }
    getExtractedLayout() {
        const routeData = this.route.snapshot.data || {};
        let expectedLayout = routeData['layout'];
        let node = findRoute(this.routes, getRoutePath(this.router));
        node = { parent: node };
        while (node.parent) {
            node = node.parent;
            if (node.layout) {
                expectedLayout = node.layout;
                break;
            }
        }
        return expectedLayout ?? this.defaultLayout();
    }
    showLayoutNotFoundError(layoutName) {
        let message = `Layout ${layoutName} not found.`;
        if (layoutName === 'account') {
            message =
                'Account layout not found. Please check your configuration. If you are using LeptonX, please make sure you have added "provideAccountLayout()" to your app configuration.';
        }
        console.warn(message);
    }
    listenToLanguageChange() {
        this.subscription.addOne(this.localizationService.languageChange$, () => {
            this.isLayoutVisible = false;
            setTimeout(() => (this.isLayoutVisible = true), 0);
        });
    }
    getComponent(key) {
        return this.replaceableComponents.get(key);
    }
    listenToEnvironmentChange() {
        this.environment
            .createOnUpdateStream(x => x.oAuthConfig)
            .pipe(take$1(1), filter$1(config => config.responseType === 'code'))
            .subscribe(() => {
            if (this.layout) {
                return;
            }
            this.getLayout();
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DynamicLayoutComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.7", type: DynamicLayoutComponent, isStandalone: true, selector: "abp-dynamic-layout", inputs: { defaultLayout: { classPropertyName: "defaultLayout", publicName: "defaultLayout", isSignal: true, isRequired: false, transformFunction: null } }, providers: [SubscriptionService], ngImport: i0, template: `
    @if (isLayoutVisible) {
      <ng-container [ngComponentOutlet]="layout"></ng-container>
    }
  `, isInline: true, dependencies: [{ kind: "directive", type: NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"], exportAs: ["ngComponentOutlet"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DynamicLayoutComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-dynamic-layout',
                    template: `
    @if (isLayoutVisible) {
      <ng-container [ngComponentOutlet]="layout"></ng-container>
    }
  `,
                    providers: [SubscriptionService],
                    imports: [NgComponentOutlet],
                }]
        }], ctorParameters: () => [] });

class ReplaceableRouteContainerComponent {
    constructor() {
        this.route = inject(ActivatedRoute);
        this.replaceableComponents = inject(ReplaceableComponentsService);
        this.subscription = inject(SubscriptionService);
    }
    ngOnInit() {
        this.defaultComponent = this.route.snapshot.data.replaceableComponent.defaultComponent;
        this.componentKey = this.route.snapshot.data.replaceableComponent.key;
        const component$ = this.replaceableComponents
            .get$(this.componentKey)
            .pipe(distinctUntilChanged());
        this.subscription.addOne(component$, (res = {}) => {
            this.externalComponent = res.component;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ReplaceableRouteContainerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: ReplaceableRouteContainerComponent, isStandalone: true, selector: "abp-replaceable-route-container", providers: [SubscriptionService], ngImport: i0, template: `
    <ng-container *ngComponentOutlet="externalComponent || defaultComponent"></ng-container>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"], exportAs: ["ngComponentOutlet"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ReplaceableRouteContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-replaceable-route-container',
                    template: `
    <ng-container *ngComponentOutlet="externalComponent || defaultComponent"></ng-container>
  `,
                    providers: [SubscriptionService],
                    imports: [NgComponentOutlet],
                }]
        }] });

class RouterOutletComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RouterOutletComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: RouterOutletComponent, isStandalone: true, selector: "abp-router-outlet", ngImport: i0, template: ` <router-outlet></router-outlet> `, isInline: true, dependencies: [{ kind: "directive", type: RouterOutlet, selector: "router-outlet", inputs: ["name", "routerOutletData"], outputs: ["activate", "deactivate", "attach", "detach"], exportAs: ["outlet"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RouterOutletComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-router-outlet',
                    template: ` <router-outlet></router-outlet> `,
                    imports: [RouterOutlet],
                }]
        }] });

// Different locales from .NET
// Key is .NET locale, value is Angular locale
const differentLocales = {
    aa: 'en',
    'aa-DJ': 'en',
    'aa-ER': 'en',
    'aa-ET': 'en',
    'af-ZA': 'af',
    'agq-CM': 'agq',
    'ak-GH': 'ak',
    'am-ET': 'am',
    'ar-001': 'ar',
    arn: 'en',
    'arn-CL': 'en',
    'as-IN': 'as',
    'asa-TZ': 'asa',
    'ast-ES': 'ast',
    'az-Cyrl-AZ': 'az-Cyrl',
    'az-Latn-AZ': 'az-Latn',
    ba: 'ru',
    'ba-RU': 'ru',
    'bas-CM': 'bas',
    'be-BY': 'be',
    'bem-ZM': 'bem',
    'bez-TZ': 'bez',
    'bg-BG': 'bg',
    bin: 'en',
    'bin-NG': 'en',
    'bm-Latn': 'bm',
    'bm-Latn-ML': 'bm',
    'bn-BD': 'bn',
    'bo-CN': 'bo',
    'br-FR': 'br',
    'brx-IN': 'brx',
    'bs-Cyrl-BA': 'bs-Cyrl',
    'bs-Latn-BA': 'bs-Latn',
    byn: 'en',
    'byn-ER': 'en',
    'ca-ES': 'ca',
    'ca-ES-valencia': 'ca-ES-VALENCIA',
    'ce-RU': 'ce',
    'cgg-UG': 'cgg',
    'chr-Cher': 'chr',
    'chr-Cher-US': 'chr',
    co: 'en',
    'co-FR': 'fr',
    'cs-CZ': 'cs',
    'cu-RU': 'cu',
    'cy-GB': 'cy',
    'da-DK': 'da',
    'dav-KE': 'dav',
    'de-DE': 'de',
    'dje-NE': 'dje',
    'dsb-DE': 'dsb',
    'dua-CM': 'dua',
    dv: 'en',
    'dv-MV': 'en',
    'dyo-SN': 'dyo',
    'dz-BT': 'dz',
    'ebu-KE': 'ebu',
    'ee-GH': 'ee',
    'el-GR': 'el',
    'en-029': 'en',
    'en-ID': 'en',
    'en-US': 'en',
    'eo-001': 'en',
    'es-ES': 'es',
    'et-EE': 'et',
    'eu-ES': 'eu',
    'ewo-CM': 'ewo',
    'fa-IR': 'fa',
    'ff-Latn-SN': 'ff-Latn',
    'ff-NG': 'ff',
    'fi-FI': 'fi',
    'fil-PH': 'fil',
    'fo-FO': 'fo',
    'fr-029': 'fr',
    'fr-FR': 'fr',
    'fur-IT': 'fur',
    'fy-NL': 'fy',
    'ga-IE': 'ga',
    'gd-GB': 'gd',
    'gl-ES': 'gl',
    gn: 'en',
    'gn-PY': 'en',
    'gsw-CH': 'gsw',
    'gu-IN': 'gu',
    'guz-KE': 'guz',
    'gv-IM': 'gv',
    'ha-Latn': 'ha',
    'ha-Latn-GH': 'ha-GH',
    'ha-Latn-NE': 'ha-NE',
    'ha-Latn-NG': 'ha',
    'haw-US': 'haw',
    'he-IL': 'he',
    'hi-IN': 'hi',
    'hr-HR': 'hr',
    'hsb-DE': 'hsb',
    'hu-HU': 'hu',
    'hy-AM': 'hy',
    'ia-001': 'ia',
    'ia-FR': 'ia',
    ibb: 'en',
    'ibb-NG': 'en',
    'id-ID': 'id',
    'ig-NG': 'ig',
    'ii-CN': 'ii',
    'is-IS': 'is',
    'it-IT': 'it',
    iu: 'en',
    'iu-Cans': 'en',
    'iu-Cans-CA': 'en',
    'iu-Latn': 'en',
    'iu-Latn-CA': 'en',
    'ja-JP': 'ja',
    'jgo-CM': 'jgo',
    'jmc-TZ': 'jmc',
    'jv-Java': 'jv',
    'jv-Java-ID': 'jv',
    'jv-Latn': 'jv',
    'jv-Latn-ID': 'jv',
    'ka-GE': 'ka',
    'kab-DZ': 'kab',
    'kam-KE': 'kam',
    'kde-TZ': 'kde',
    'kea-CV': 'kea',
    'khq-ML': 'khq',
    'ki-KE': 'ki',
    'kk-KZ': 'kk',
    'kkj-CM': 'kkj',
    'kl-GL': 'kl',
    'kln-KE': 'kln',
    'km-KH': 'km',
    'kn-IN': 'kn',
    'ko-KR': 'ko',
    'kok-IN': 'kok',
    kr: 'en',
    'kr-NG': 'en',
    'ks-Arab': 'ks',
    'ks-Arab-IN': 'ks',
    'ks-Deva': 'ks',
    'ks-Deva-IN': 'ks',
    'ksb-TZ': 'ksb',
    'ksf-CM': 'ksf',
    'ksh-DE': 'ksh',
    'ku-Arab': 'ku',
    'ku-Arab-IQ': 'ku',
    'ku-Arab-IR': 'ku',
    'kw-GB': 'kw',
    'ky-KG': 'ky',
    la: 'en',
    'la-001': 'en',
    'lag-TZ': 'lag',
    'lb-LU': 'lb',
    'lg-UG': 'lg',
    'lkt-US': 'lkt',
    'ln-CD': 'ln',
    'lo-LA': 'lo',
    'lrc-IR': 'lrc',
    'lt-LT': 'lt',
    'lu-CD': 'lu',
    'luo-KE': 'luo',
    'luy-KE': 'luy',
    'lv-LV': 'lv',
    'mas-KE': 'mas',
    'mer-KE': 'mer',
    'mfe-MU': 'mfe',
    'mg-MG': 'mg',
    'mgh-MZ': 'mgh',
    'mgo-CM': 'mgo',
    'mi-NZ': 'mi',
    'mk-MK': 'mk',
    'ml-IN': 'ml',
    'mn-Cyrl': 'mn',
    'mn-MN': 'mn',
    'mn-Mong': 'mn',
    'mn-Mong-CN': 'mn',
    'mn-Mong-MN': 'mn',
    mni: 'en',
    'mni-IN': 'en',
    moh: 'en',
    'moh-CA': 'en',
    'mr-IN': 'mr',
    'ms-MY': 'ms',
    'mt-MT': 'mt',
    'mua-CM': 'mua',
    'my-MM': 'my',
    'mzn-IR': 'mzn',
    'naq-NA': 'naq',
    'nb-NO': 'nb',
    'nd-ZW': 'nd',
    'ne-NP': 'ne',
    'nl-NL': 'nl',
    'nmg-CM': 'ngm',
    'nn-NO': 'nn',
    'nnh-CM': 'nnh',
    no: 'en',
    nqo: 'en',
    'nqo-GN': 'en',
    nr: 'en',
    'nr-ZA': 'en',
    nso: 'en',
    'nso-ZA': 'en',
    'nus-SS': 'nus',
    'nyn-UG': 'nyn',
    oc: 'en',
    'oc-FR': 'fr',
    'om-ET': 'om',
    'or-IN': 'or',
    'os-GE': 'os',
    'pa-Arab-PK': 'pa-Arab',
    'pa-IN': 'pa',
    pap: 'en',
    'pap-029': 'en',
    'pl-PL': 'pl',
    'prg-001': 'prg',
    prs: 'en',
    'prs-AF': 'en',
    'ps-AF': 'ps',
    'pt-BR': 'pt',
    quc: 'en',
    'quc-Latn': 'en',
    'quc-Latn-GT': 'en',
    quz: 'en',
    'quz-BO': 'en',
    'quz-EC': 'en',
    'quz-PE': 'en',
    'rm-CH': 'rm',
    'rn-BI': 'rn',
    'ro-RO': 'ro',
    'rof-TZ': 'rof',
    'ru-RU': 'ru',
    'rw-RW': 'rw',
    'rwk-TZ': 'rwk',
    sa: 'en',
    'sa-IN': 'en',
    'sah-RU': 'sah',
    'saq-KE': 'saq',
    'sbp-TZ': 'en',
    'sd-Arab': 'sd',
    'sd-Arab-PK': 'sd',
    'sd-Deva': 'sd',
    'sd-Deva-IN': 'sd',
    'se-NO': 'se',
    'seh-MZ': 'seh',
    'ses-ML': 'ses',
    'sg-CF': 'sg',
    'shi-Latn-MA': 'shi-Latn',
    'shi-Tfng-MA': 'shi-Tfng',
    'si-LK': 'si',
    'sk-SK': 'sk',
    'sl-SI': 'sl',
    sma: 'en',
    'sma-NO': 'en',
    'sma-SE': 'en',
    smj: 'en',
    'smj-NO': 'en',
    'smj-SE': 'en',
    'smn-FI': 'en',
    sms: 'en',
    'sms-FI': 'en',
    'sn-Latn': 'sn',
    'sn-Latn-ZW': 'sn',
    'so-SO': 'so',
    'sq-AL': 'so',
    'sr-Cyrl-RS': 'sr-Cryl',
    'sr-Latn-RS': 'sr-Latn',
    ss: 'en',
    'ss-SZ': 'en',
    'ss-ZA': 'en',
    ssy: 'en',
    'ssy-ER': 'en',
    st: 'en',
    'st-LS': 'en',
    'st-ZA': 'en',
    'sv-SE': 'sv',
    'sw-TZ': 'sw',
    syr: 'en',
    'syr-SY': 'en',
    'ta-IN': 'ta',
    'te-IN': 'te',
    'teo-UG': 'teo',
    'tg-Cyrl': 'tg',
    'tg-Cyrl-TJ': 'tg',
    'th-TH': 'th',
    'ti-ET': 'ti',
    tig: 'en',
    'tig-ER': 'en',
    'tk-TM': 'tk',
    tn: 'en',
    'tn-BW': 'en',
    'tn-ZA': 'en',
    'to-TO': 'to',
    'tr-TR': 'tr',
    ts: 'en',
    'ts-ZA': 'en',
    'tt-RU': 'tt',
    'twq-NE': 'twq',
    'tzm-Arab': 'tzm',
    'tzm-Arab-MA': 'tzm',
    'tzm-Latn': 'tzm',
    'tzm-Latn-DZ': 'tzm',
    'tzm-Latn-MA': 'tzm',
    'tzm-Tfng': 'tzm',
    'tzm-Tfng-MA': 'tzm',
    'ug-CN': 'ug',
    'uk-UA': 'uk',
    'ur-PK': 'ur',
    'uz-Arab-AF': 'uz-Arab',
    'uz-Cyrl-UZ': 'uz-Cyrl',
    'uz-Latn-UZ': 'uz-Latn',
    'vai-Latn-LR': 'vai-Latn',
    'vai-Vaii-LR': 'vai-Vaii',
    ve: 'en',
    've-ZA': 'en',
    'vi-VN': 'vi',
    'vo-001': 'vo',
    'vun-TZ': 'vun',
    'wae-CH': 'wae',
    wal: 'en',
    'wal-ET': 'en',
    'wo-SN': 'wo',
    'xh-ZA': 'xh',
    'xog-UG': 'xog',
    'yav-CM': 'yav',
    'yi-001': 'yi',
    'yo-NG': 'yo',
    'zgh-Tfng': 'zgh',
    'zgh-Tfng-MA': 'zgh',
    'zh-CN': 'zh',
    'zh-HK': 'zh',
    'zh-MO': 'zh',
    'zh-SG': 'zh',
    'zh-TW': 'zh',
    'zu-ZA': 'zu',
};

const DEFAULT_DYNAMIC_LAYOUTS = new Map([
    ["application" /* eLayoutType.application */, "Theme.ApplicationLayoutComponent" /* eThemeSharedComponents.ApplicationLayoutComponent */],
    ["account" /* eLayoutType.account */, "Theme.AccountLayoutComponent" /* eThemeSharedComponents.AccountLayoutComponent */],
    ["empty" /* eLayoutType.empty */, "Theme.EmptyLayoutComponent" /* eThemeSharedComponents.EmptyLayoutComponent */],
]);

class AutofocusDirective {
    constructor() {
        this.elRef = inject(ElementRef);
        this._delay = 0;
    }
    set delay(val) {
        this._delay = Number(val) || 0;
    }
    get delay() {
        return this._delay;
    }
    ngAfterViewInit() {
        setTimeout(() => this.elRef.nativeElement.focus(), this.delay);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AutofocusDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: AutofocusDirective, isStandalone: true, selector: "[autofocus]", inputs: { delay: ["autofocus", "delay"] }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AutofocusDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[autofocus]',
                }]
        }], propDecorators: { delay: [{
                type: Input,
                args: ['autofocus']
            }] } });

class InputEventDebounceDirective {
    constructor() {
        this.el = inject(ElementRef);
        this.subscription = inject(SubscriptionService);
        this.debounce = 300;
        this.debounceEvent = new EventEmitter();
    }
    ngOnInit() {
        const input$ = fromEvent(this.el.nativeElement, 'input').pipe(debounceTime(this.debounce));
        this.subscription.addOne(input$, (event) => {
            this.debounceEvent.emit(event);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: InputEventDebounceDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: InputEventDebounceDirective, isStandalone: true, selector: "[input.debounce]", inputs: { debounce: "debounce" }, outputs: { debounceEvent: "input.debounce" }, providers: [SubscriptionService], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: InputEventDebounceDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[input.debounce]',
                    providers: [SubscriptionService],
                }]
        }], propDecorators: { debounce: [{
                type: Input
            }], debounceEvent: [{
                type: Output,
                args: ['input.debounce']
            }] } });

class AbpForContext {
    constructor($implicit, index, count, list) {
        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
        this.list = list;
    }
}
class RecordView {
    constructor(record, view) {
        this.record = record;
        this.view = view;
    }
}
class ForDirective {
    constructor() {
        this.tempRef = inject(TemplateRef);
        this.vcRef = inject(ViewContainerRef);
        this.differs = inject(IterableDiffers);
    }
    get compareFn() {
        return this.compareBy || compare;
    }
    get trackByFn() {
        return this.trackBy || ((index, item) => item.id || index);
    }
    iterateOverAppliedOperations(changes) {
        const rw = [];
        changes.forEachOperation((record, previousIndex, currentIndex) => {
            if (record.previousIndex == null) {
                const view = this.vcRef.createEmbeddedView(this.tempRef, new AbpForContext(null, -1, -1, this.items), currentIndex || 0);
                rw.push(new RecordView(record, view));
            }
            else if (currentIndex == null && previousIndex !== null) {
                this.vcRef.remove(previousIndex);
            }
            else {
                if (previousIndex !== null) {
                    const view = this.vcRef.get(previousIndex);
                    if (view && currentIndex !== null) {
                        this.vcRef.move(view, currentIndex);
                        rw.push(new RecordView(record, view));
                    }
                }
            }
        });
        for (let i = 0, l = rw.length; i < l; i++) {
            rw[i].view.context.$implicit = rw[i].record.item;
        }
    }
    iterateOverAttachedViews(changes) {
        for (let i = 0, l = this.vcRef.length; i < l; i++) {
            const viewRef = this.vcRef.get(i);
            viewRef.context.index = i;
            viewRef.context.count = l;
            viewRef.context.list = this.items;
        }
        changes.forEachIdentityChange((record) => {
            if (record.currentIndex !== null) {
                const viewRef = this.vcRef.get(record.currentIndex);
                viewRef.context.$implicit = record.item;
            }
        });
    }
    projectItems(items) {
        if (!items.length && this.emptyRef) {
            this.vcRef.clear();
            this.vcRef.createEmbeddedView(this.emptyRef).rootNodes;
            this.isShowEmptyRef = true;
            this.differ = null;
            return;
        }
        if (this.emptyRef && this.isShowEmptyRef) {
            this.vcRef.clear();
            this.isShowEmptyRef = false;
        }
        if (!this.differ && items) {
            this.differ = this.differs.find(items).create(this.trackByFn);
        }
        if (this.differ) {
            const changes = this.differ.diff(items);
            if (changes) {
                this.iterateOverAppliedOperations(changes);
                this.iterateOverAttachedViews(changes);
            }
        }
    }
    sortItems(items) {
        const orderBy = this.orderBy;
        if (orderBy) {
            items.sort((a, b) => (a[orderBy] > b[orderBy] ? 1 : a[orderBy] < b[orderBy] ? -1 : 0));
        }
        else {
            items.sort();
        }
    }
    ngOnChanges() {
        let items = clone(this.items);
        if (!Array.isArray(items))
            return;
        const compareFn = this.compareFn;
        const filterBy = this.filterBy;
        if (typeof filterBy !== 'undefined' &&
            typeof this.filterVal !== 'undefined' &&
            this.filterVal !== '') {
            items = items.filter(item => compareFn(item[filterBy], this.filterVal));
        }
        switch (this.orderDir) {
            case 'ASC':
                this.sortItems(items);
                this.projectItems(items);
                break;
            case 'DESC':
                this.sortItems(items);
                items.reverse();
                this.projectItems(items);
                break;
            default:
                this.projectItems(items);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ForDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: ForDirective, isStandalone: true, selector: "[abpFor]", inputs: { items: ["abpForOf", "items"], orderBy: ["abpForOrderBy", "orderBy"], orderDir: ["abpForOrderDir", "orderDir"], filterBy: ["abpForFilterBy", "filterBy"], filterVal: ["abpForFilterVal", "filterVal"], trackBy: ["abpForTrackBy", "trackBy"], compareBy: ["abpForCompareBy", "compareBy"], emptyRef: ["abpForEmptyRef", "emptyRef"] }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ForDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpFor]',
                }]
        }], propDecorators: { items: [{
                type: Input,
                args: ['abpForOf']
            }], orderBy: [{
                type: Input,
                args: ['abpForOrderBy']
            }], orderDir: [{
                type: Input,
                args: ['abpForOrderDir']
            }], filterBy: [{
                type: Input,
                args: ['abpForFilterBy']
            }], filterVal: [{
                type: Input,
                args: ['abpForFilterVal']
            }], trackBy: [{
                type: Input,
                args: ['abpForTrackBy']
            }], compareBy: [{
                type: Input,
                args: ['abpForCompareBy']
            }], emptyRef: [{
                type: Input,
                args: ['abpForEmptyRef']
            }] } });

/**
 * @deprecated FormSubmitDirective will be removed in V7.0.0. Use `ngSubmit` instead.
 */
class FormSubmitDirective {
    constructor() {
        this.formGroupDirective = inject(FormGroupDirective, { self: true });
        this.host = inject(ElementRef);
        this.cdRef = inject(ChangeDetectorRef);
        this.subscription = inject(SubscriptionService);
        this.debounce = 200;
        this.markAsDirtyWhenSubmit = true;
        this.ngSubmit = new EventEmitter();
        this.executedNgSubmit = false;
    }
    ngOnInit() {
        this.subscription.addOne(this.formGroupDirective.ngSubmit, () => {
            if (this.markAsDirtyWhenSubmit) {
                this.markAsDirty();
            }
            this.executedNgSubmit = true;
        });
        const keyup$ = fromEvent(this.host.nativeElement, 'keyup').pipe(debounceTime(this.debounce), filter(event => !(event.target instanceof HTMLTextAreaElement)), filter(event => event && event.key === 'Enter'));
        this.subscription.addOne(keyup$, () => {
            if (!this.executedNgSubmit) {
                this.host.nativeElement.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
            }
            this.executedNgSubmit = false;
        });
    }
    markAsDirty() {
        const { form } = this.formGroupDirective;
        setDirty(form.controls);
        form.markAsDirty();
        this.cdRef.detectChanges();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: FormSubmitDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: FormSubmitDirective, isStandalone: true, selector: "form[ngSubmit][formGroup]", inputs: { debounce: "debounce", notValidateOnSubmit: "notValidateOnSubmit", markAsDirtyWhenSubmit: "markAsDirtyWhenSubmit" }, outputs: { ngSubmit: "ngSubmit" }, providers: [SubscriptionService], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: FormSubmitDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'form[ngSubmit][formGroup]',
                    providers: [SubscriptionService],
                }]
        }], propDecorators: { debounce: [{
                type: Input
            }], notValidateOnSubmit: [{
                type: Input
            }], markAsDirtyWhenSubmit: [{
                type: Input
            }], ngSubmit: [{
                type: Output
            }] } });
function setDirty(controls) {
    if (Array.isArray(controls)) {
        controls.forEach(group => {
            setDirty(group.controls);
        });
        return;
    }
    Object.keys(controls).forEach(key => {
        controls[key].markAsDirty();
        controls[key].updateValueAndValidity();
    });
}

class InitDirective {
    constructor() {
        this.elRef = inject(ElementRef);
        this.init = new EventEmitter();
    }
    ngAfterViewInit() {
        this.init.emit(this.elRef);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: InitDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: InitDirective, isStandalone: true, selector: "[abpInit]", outputs: { init: "abpInit" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: InitDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpInit]',
                }]
        }], propDecorators: { init: [{
                type: Output,
                args: ['abpInit']
            }] } });

class PermissionDirective {
    constructor() {
        this.templateRef = inject(TemplateRef, { optional: true });
        this.vcRef = inject(ViewContainerRef);
        this.permissionService = inject(PermissionService);
        this.cdRef = inject(ChangeDetectorRef);
        this.queue = inject(QUEUE_MANAGER);
        this.runChangeDetection = true;
        this.cdrSubject = new ReplaySubject();
        this.rendered = false;
    }
    check() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.subscription = this.permissionService
            .getGrantedPolicy$(this.condition || '')
            .pipe(distinctUntilChanged())
            .subscribe(isGranted => {
            this.vcRef.clear();
            if (isGranted)
                this.vcRef.createEmbeddedView(this.templateRef);
            if (this.runChangeDetection) {
                if (!this.rendered) {
                    this.cdrSubject.next();
                }
                else {
                    this.cdRef.detectChanges();
                }
            }
            else {
                this.cdRef.markForCheck();
            }
        });
    }
    ngOnDestroy() {
        if (this.subscription)
            this.subscription.unsubscribe();
    }
    ngOnChanges() {
        this.check();
    }
    ngAfterViewInit() {
        this.cdrSubject.pipe(take(1)).subscribe(() => this.queue.add(() => this.cdRef.detectChanges()));
        this.rendered = true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PermissionDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: PermissionDirective, isStandalone: true, selector: "[abpPermission]", inputs: { condition: ["abpPermission", "condition"], runChangeDetection: ["abpPermissionRunChangeDetection", "runChangeDetection"] }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PermissionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpPermission]',
                }]
        }], propDecorators: { condition: [{
                type: Input,
                args: ['abpPermission']
            }], runChangeDetection: [{
                type: Input,
                args: ['abpPermissionRunChangeDetection']
            }] } });

class ReplaceableTemplateDirective {
    constructor() {
        this.injector = inject(Injector);
        this.templateRef = inject(TemplateRef);
        this.vcRef = inject(ViewContainerRef);
        this.replaceableComponents = inject(ReplaceableComponentsService);
        this.subscription = inject(SubscriptionService);
        this.providedData = {
            inputs: {},
            outputs: {},
        };
        this.context = {};
        this.defaultComponentSubscriptions = {};
        this.initialized = false;
        this.context = {
            initTemplate: (ref) => {
                this.resetDefaultComponent();
                this.defaultComponentRef = ref;
                this.setDefaultComponentInputs();
            },
        };
    }
    ngOnInit() {
        const component$ = this.replaceableComponents
            .get$(this.data.componentKey)
            .pipe(filter((res = {}) => !this.initialized || !compare(res.component, this.externalComponent)));
        this.subscription.addOne(component$, (res = {}) => {
            this.vcRef.clear();
            this.externalComponent = res.component;
            if (this.defaultComponentRef) {
                this.resetDefaultComponent();
            }
            if (res.component) {
                this.setProvidedData();
                const customInjector = Injector.create({
                    providers: [{ provide: 'REPLACEABLE_DATA', useValue: this.providedData }],
                    parent: this.injector,
                });
                const ref = this.vcRef.createComponent(res.component, {
                    index: 0,
                    injector: customInjector,
                });
            }
            else {
                this.vcRef.createEmbeddedView(this.templateRef, this.context);
            }
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (changes?.data?.currentValue?.inputs && this.defaultComponentRef) {
            this.setDefaultComponentInputs();
        }
    }
    setDefaultComponentInputs() {
        if (!this.defaultComponentRef || (!this.data.inputs && !this.data.outputs))
            return;
        if (this.data.inputs) {
            for (const key in this.data.inputs) {
                if (Object.prototype.hasOwnProperty.call(this.data.inputs, key)) {
                    if (!compare(this.defaultComponentRef[key], this.data.inputs[key].value)) {
                        this.defaultComponentRef[key] = this.data.inputs[key].value;
                    }
                }
            }
        }
        if (this.data.outputs) {
            for (const key in this.data.outputs) {
                if (Object.prototype.hasOwnProperty.call(this.data.outputs, key)) {
                    if (!this.defaultComponentSubscriptions[key]) {
                        this.defaultComponentSubscriptions[key] = this.defaultComponentRef[key].subscribe((value) => {
                            this.data.outputs?.[key](value);
                        });
                    }
                }
            }
        }
    }
    setProvidedData() {
        this.providedData = { outputs: {}, ...this.data, inputs: {} };
        if (!this.data.inputs)
            return;
        Object.defineProperties(this.providedData.inputs, {
            ...Object.keys(this.data.inputs).reduce((acc, key) => ({
                ...acc,
                [key]: {
                    enumerable: true,
                    configurable: true,
                    get: () => this.data.inputs?.[key]?.value,
                    ...(this.data.inputs?.[key]?.twoWay && {
                        set: (newValue) => {
                            if (this.data.inputs?.[key]) {
                                this.data.inputs[key].value = newValue;
                            }
                            if (this.data.outputs?.[`${key}Change`]) {
                                this.data.outputs[`${key}Change`](newValue);
                            }
                        },
                    }),
                },
            }), {}),
        });
    }
    resetDefaultComponent() {
        Object.keys(this.defaultComponentSubscriptions).forEach(key => {
            this.defaultComponentSubscriptions[key].unsubscribe();
        });
        this.defaultComponentSubscriptions = {};
        this.defaultComponentRef = null;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ReplaceableTemplateDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: ReplaceableTemplateDirective, isStandalone: true, selector: "[abpReplaceableTemplate]", inputs: { data: ["abpReplaceableTemplate", "data"] }, providers: [SubscriptionService], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ReplaceableTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpReplaceableTemplate]',
                    providers: [SubscriptionService],
                }]
        }], ctorParameters: () => [], propDecorators: { data: [{
                type: Input,
                args: ['abpReplaceableTemplate']
            }] } });

class StopPropagationDirective {
    constructor() {
        this.el = inject(ElementRef);
        this.subscription = inject(SubscriptionService);
        this.stopPropEvent = new EventEmitter();
    }
    ngOnInit() {
        this.subscription.addOne(fromEvent(this.el.nativeElement, 'click'), event => {
            event.stopPropagation();
            this.stopPropEvent.emit(event);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: StopPropagationDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: StopPropagationDirective, isStandalone: true, selector: "[click.stop]", outputs: { stopPropEvent: "click.stop" }, providers: [SubscriptionService], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: StopPropagationDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[click.stop]',
                    providers: [SubscriptionService],
                }]
        }], propDecorators: { stopPropEvent: [{
                type: Output,
                args: ['click.stop']
            }] } });

class ShowPasswordDirective {
    constructor() {
        this.elementRef = inject(ElementRef);
    }
    set abpShowPassword(visible) {
        const element = this.elementRef.nativeElement;
        if (!element)
            return;
        element.type = visible ? 'text' : 'password';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ShowPasswordDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: ShowPasswordDirective, isStandalone: true, selector: "[abpShowPassword]", inputs: { abpShowPassword: "abpShowPassword" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ShowPasswordDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpShowPassword]',
                }]
        }], propDecorators: { abpShowPassword: [{
                type: Input
            }] } });

class TrackCapsLockDirective {
    constructor() {
        this.capsLock = new EventEmitter();
    }
    onKeyDown(event) {
        this.capsLock.emit(this.isCapsLockOpen(event));
    }
    onKeyUp(event) {
        this.capsLock.emit(this.isCapsLockOpen(event));
    }
    isCapsLockOpen(e) {
        const s = String.fromCharCode(e.which);
        if ((s.toUpperCase() === s && s.toLowerCase() !== s && e.shiftKey) ||
            (s.toUpperCase() !== s && s.toLowerCase() === s && e.shiftKey) ||
            (e.getModifierState && e.getModifierState('CapsLock'))) {
            return true;
        }
        return false;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TrackCapsLockDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: TrackCapsLockDirective, isStandalone: true, selector: "[abpCapsLock]", outputs: { capsLock: "abpCapsLock" }, host: { listeners: { "window:keydown": "onKeyDown($event)", "window:keyup": "onKeyUp($event)" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TrackCapsLockDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpCapsLock]',
                }]
        }], propDecorators: { capsLock: [{
                type: Output,
                args: ['abpCapsLock']
            }], onKeyDown: [{
                type: HostListener,
                args: ['window:keydown', ['$event']]
            }], onKeyUp: [{
                type: HostListener,
                args: ['window:keyup', ['$event']]
            }] } });

Date.prototype.toLocalISOString = function () {
    const timezoneOffset = this.getTimezoneOffset();
    return new Date(this.getTime() - timezoneOffset * 60000).toISOString();
};

function setLanguageToCookie() {
    const injector = inject(Injector);
    const platformId = injector.get(PLATFORM_ID);
    if (!isPlatformBrowser(platformId))
        return;
    const sessionState = injector.get(SessionStateService);
    const document = injector.get(DOCUMENT);
    const cookieLanguageKey = injector.get(COOKIE_LANGUAGE_KEY);
    sessionState.getLanguage$().subscribe(language => {
        const cookieValue = encodeURIComponent(`c=${language}|uic=${language}`);
        document.cookie = `${cookieLanguageKey}=${cookieValue}`;
    });
}
const CookieLanguageProvider = provideAppInitializer(() => {
    setLanguageToCookie();
});

class LocaleId extends String {
    constructor() {
        super();
        this.localizationService = inject(LocalizationService);
    }
    toString() {
        const { currentLang } = this.localizationService;
        if (checkHasProp(differentLocales, currentLang)) {
            return differentLocales[currentLang];
        }
        return currentLang;
    }
    valueOf() {
        return this.toString();
    }
}
const LocaleProvider = {
    provide: LOCALE_ID,
    useClass: LocaleId,
};

const IncludeLocalizationResourcesProvider = {
    provide: INCUDE_LOCALIZATION_RESOURCES_TOKEN,
    useValue: false,
};

class RoutesHandler {
    constructor() {
        this.routes = inject(RoutesService);
        this.router = inject(Router, { optional: true });
        this.addRoutes();
    }
    addRoutes() {
        this.router?.config?.forEach(({ path = '', data }) => {
            const routes = data?.routes;
            if (!routes)
                return;
            if (Array.isArray(routes)) {
                this.routes.add(routes);
            }
            else {
                const routesFlatten = flatRoutes([{ path, ...routes }], { path: '' });
                this.routes.add(routesFlatten);
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RoutesHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RoutesHandler, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RoutesHandler, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });
function flatRoutes(routes, parent) {
    if (!routes)
        return [];
    return routes.reduce((acc, route) => {
        const { children, ...current } = {
            ...route,
            parentName: parent.name,
            path: (parent.path + '/' + route.path).replace(/\/\//g, '/'),
        };
        acc.push(current, ...flatRoutes(children, current));
        return acc;
    }, []);
}

class ApiInterceptor {
    constructor() {
        this.httpWaitService = inject(HttpWaitService);
    }
    getAdditionalHeaders(existingHeaders) {
        return existingHeaders || new HttpHeaders();
    }
    intercept(request, next) {
        this.httpWaitService.addRequest(request);
        return next.handle(request).pipe(finalize(() => this.httpWaitService.deleteRequest(request)));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ApiInterceptor, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ApiInterceptor, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ApiInterceptor, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

const timezoneInterceptor = (req, next) => {
    const timezoneService = inject(TimezoneService);
    if (!timezoneService.isUtcClockEnabled) {
        return next(req);
    }
    const timezone = timezoneService.timezone;
    if (timezone) {
        req = req.clone({
            setHeaders: {
                __timezone: timezone,
            },
        });
    }
    return next(req);
};

const transferStateInterceptor = (req, next) => {
    const transferState = inject(TransferState);
    const platformId = inject(PLATFORM_ID);
    if (req.method !== 'GET') {
        return next(req);
    }
    const stateKey = makeStateKey(req.urlWithParams);
    if (isPlatformBrowser(platformId)) {
        const storedResponse = transferState.get(stateKey, null);
        if (storedResponse) {
            transferState.remove(stateKey);
            return of(new HttpResponse({ body: storedResponse, status: 200 }));
        }
    }
    return next(req).pipe(tap(event => {
        if (isPlatformServer(platformId) && event instanceof HttpResponse) {
            transferState.set(stateKey, event.body);
            console.log(`Interceptor: ${req.urlWithParams} is stored in TransferState.`);
        }
    }));
};

var CoreFeatureKind;
(function (CoreFeatureKind) {
    CoreFeatureKind[CoreFeatureKind["Options"] = 0] = "Options";
    CoreFeatureKind[CoreFeatureKind["CompareFunctionFactory"] = 1] = "CompareFunctionFactory";
    CoreFeatureKind[CoreFeatureKind["TitleStrategy"] = 2] = "TitleStrategy";
})(CoreFeatureKind || (CoreFeatureKind = {}));
function makeCoreFeature(kind, providers) {
    return {
        ɵkind: kind,
        ɵproviders: providers,
    };
}
function withOptions(options = {}) {
    return makeCoreFeature(CoreFeatureKind.Options, [
        {
            provide: 'CORE_OPTIONS',
            useValue: options,
        },
        {
            provide: CORE_OPTIONS,
            useFactory: coreOptionsFactory,
            deps: ['CORE_OPTIONS'],
        },
        { provide: TENANT_KEY, useValue: options.tenantKey || '__tenant' },
        {
            provide: LOCALIZATIONS,
            multi: true,
            useValue: localizationContributor(options.localizations),
            deps: [LocalizationService],
        },
        {
            provide: OTHERS_GROUP,
            useValue: options.othersGroup || 'AbpUi::OthersGroup',
        },
        {
            provide: DYNAMIC_LAYOUTS_TOKEN,
            useValue: options.dynamicLayouts || DEFAULT_DYNAMIC_LAYOUTS,
        },
    ]);
}
function withTitleStrategy(strategy) {
    return makeCoreFeature(CoreFeatureKind.TitleStrategy, [
        {
            provide: TitleStrategy,
            useExisting: strategy,
        },
    ]);
}
function withCompareFuncFactory(factory) {
    return makeCoreFeature(CoreFeatureKind.CompareFunctionFactory, [
        {
            provide: SORT_COMPARE_FUNC,
            useFactory: factory,
        },
    ]);
}
function provideAbpCore(...features) {
    const providers = [
        provideHttpClient(withInterceptorsFromDi(), withXsrfConfiguration({
            cookieName: 'XSRF-TOKEN',
            headerName: 'RequestVerificationToken',
        }), withFetch(), withInterceptors([transferStateInterceptor, timezoneInterceptor])),
        provideAppInitializer(async () => {
            inject(LocalizationService);
            inject(LocalStorageListenerService);
            inject(RoutesHandler);
            await getInitialData();
        }),
        LocaleProvider,
        CookieLanguageProvider,
        {
            provide: SORT_COMPARE_FUNC,
            useFactory: compareFuncFactory,
        },
        {
            provide: QUEUE_MANAGER,
            useClass: DefaultQueueManager,
        },
        AuthErrorFilterService,
        IncludeLocalizationResourcesProvider,
        {
            provide: TitleStrategy,
            useExisting: AbpTitleStrategy,
        },
    ];
    for (const feature of features) {
        providers.push(...feature.ɵproviders);
    }
    return makeEnvironmentProviders(providers);
}
function provideAbpCoreChild(options = {}) {
    return makeEnvironmentProviders([
        {
            provide: LOCALIZATIONS,
            multi: true,
            useValue: localizationContributor(options.localizations),
            deps: [LocalizationService],
        },
    ]);
}

class LocalizationPipe {
    constructor() {
        this.localization = inject(LocalizationService);
    }
    transform(value = '', ...interpolateParams) {
        const params = interpolateParams.reduce((acc, val) => {
            if (!acc) {
                return val;
            }
            if (!val) {
                return acc;
            }
            return Array.isArray(val) ? [...acc, ...val] : [...acc, val];
        }, []) || [];
        return this.localization.instant(value, ...params);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalizationPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: LocalizationPipe, isStandalone: true, name: "abpLocalization" }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalizationPipe }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalizationPipe, decorators: [{
            type: Injectable
        }, {
            type: Pipe,
            args: [{
                    name: 'abpLocalization',
                }]
        }] });

class SafeHtmlPipe {
    constructor() {
        this.sanitizer = inject(DomSanitizer);
    }
    transform(value) {
        if (typeof value !== 'string')
            return '';
        return this.sanitizer.sanitize(SecurityContext.HTML, value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SafeHtmlPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: SafeHtmlPipe, isStandalone: true, name: "abpSafeHtml" }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SafeHtmlPipe }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SafeHtmlPipe, decorators: [{
            type: Injectable
        }, {
            type: Pipe,
            args: [{
                    name: 'abpSafeHtml',
                }]
        }] });

class SortPipe {
    transform(value, sortOrder = 'asc', sortKey) {
        sortOrder = sortOrder && sortOrder.toLowerCase();
        if (!value || (sortOrder !== 'asc' && sortOrder !== 'desc'))
            return value;
        let numberArray = [];
        let stringArray = [];
        if (!sortKey) {
            numberArray = value.filter(item => typeof item === 'number').sort();
            stringArray = value.filter(item => typeof item === 'string').sort();
        }
        else {
            numberArray = value
                .filter(item => typeof item[sortKey] === 'number')
                .sort((a, b) => a[sortKey] - b[sortKey]);
            stringArray = value
                .filter(item => typeof item[sortKey] === 'string')
                .sort((a, b) => {
                if (a[sortKey] < b[sortKey])
                    return -1;
                else if (a[sortKey] > b[sortKey])
                    return 1;
                else
                    return 0;
            });
        }
        const sorted = [
            ...numberArray,
            ...stringArray,
            ...value.filter(item => typeof (sortKey ? item[sortKey] : item) !== 'number' &&
                typeof (sortKey ? item[sortKey] : item) !== 'string'),
        ];
        return sortOrder === 'asc' ? sorted : sorted.reverse();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SortPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: SortPipe, isStandalone: true, name: "abpSort" }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SortPipe }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SortPipe, decorators: [{
            type: Injectable
        }, {
            type: Pipe,
            args: [{
                    name: 'abpSort',
                }]
        }] });

const INJECTOR_PIPE_DATA_TOKEN = new InjectionToken('INJECTOR_PIPE_DATA_TOKEN');
class ToInjectorPipe {
    constructor() {
        this.injector = inject(Injector);
    }
    transform(value, token = INJECTOR_PIPE_DATA_TOKEN, name = 'ToInjectorPipe') {
        return Injector.create({
            providers: [
                {
                    provide: token,
                    useValue: value,
                },
            ],
            parent: this.injector,
            name,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ToInjectorPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: ToInjectorPipe, isStandalone: true, name: "toInjector" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ToInjectorPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'toInjector',
                }]
        }] });

class ShortDatePipe extends DatePipe {
    constructor() {
        const locale = inject(LOCALE_ID);
        const defaultTimezone = inject(DATE_PIPE_DEFAULT_TIMEZONE, { optional: true });
        super(locale, defaultTimezone);
        this.configStateService = inject(ConfigStateService);
    }
    transform(value, timezone, locale) {
        const format = getShortDateFormat(this.configStateService);
        return super.transform(value, format, timezone, locale);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ShortDatePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: ShortDatePipe, isStandalone: true, name: "shortDate" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ShortDatePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'shortDate',
                    pure: true,
                }]
        }], ctorParameters: () => [] });

class ShortTimePipe extends DatePipe {
    constructor() {
        const locale = inject(LOCALE_ID);
        const defaultTimezone = inject(DATE_PIPE_DEFAULT_TIMEZONE, { optional: true });
        super(locale, defaultTimezone);
        this.configStateService = inject(ConfigStateService);
    }
    transform(value, timezone, locale) {
        const format = getShortTimeFormat(this.configStateService);
        return super.transform(value, format, timezone, locale);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ShortTimePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: ShortTimePipe, isStandalone: true, name: "shortTime" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ShortTimePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'shortTime',
                    pure: true,
                }]
        }], ctorParameters: () => [] });

class ShortDateTimePipe extends DatePipe {
    constructor() {
        const locale = inject(LOCALE_ID);
        const defaultTimezone = inject(DATE_PIPE_DEFAULT_TIMEZONE, { optional: true });
        super(locale, defaultTimezone);
        this.configStateService = inject(ConfigStateService);
    }
    transform(value, timezone, locale) {
        const format = getShortDateShortTimeFormat(this.configStateService);
        return super.transform(value, format, timezone, locale);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ShortDateTimePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: ShortDateTimePipe, isStandalone: true, name: "shortDateTime" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ShortDateTimePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'shortDateTime',
                    pure: true,
                }]
        }], ctorParameters: () => [] });

class UtcToLocalPipe {
    constructor() {
        this.timezoneService = inject(TimezoneService);
        this.timeService = inject(TimeService);
        this.configState = inject(ConfigStateService);
        this.localizationService = inject(LocalizationService);
        this.locale = inject(LOCALE_ID);
    }
    transform(value, type) {
        if (!value)
            return '';
        const date = new Date(value);
        if (isNaN(date.getTime()))
            return '';
        const format = this.getFormat(type);
        try {
            if (this.timezoneService.isUtcClockEnabled) {
                const timeZone = this.timezoneService.timezone;
                return this.timeService.formatDateWithStandardOffset(date, format, timeZone);
            }
            else {
                return this.timeService.formatWithoutTimeZone(date, format);
            }
        }
        catch (err) {
            return value;
        }
    }
    getFormat(propType) {
        switch (propType) {
            case 'date':
                return getShortDateFormat(this.configState);
            case 'time':
                return getShortTimeFormat(this.configState);
            case 'datetime':
            default:
                return getShortDateShortTimeFormat(this.configState);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: UtcToLocalPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: UtcToLocalPipe, isStandalone: true, name: "abpUtcToLocal" }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: UtcToLocalPipe }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: UtcToLocalPipe, decorators: [{
            type: Injectable
        }, {
            type: Pipe,
            args: [{
                    name: 'abpUtcToLocal',
                }]
        }] });

class LazyLocalizationPipe {
    constructor() {
        this.localizationService = inject(LocalizationService);
        this.configStateService = inject(ConfigStateService);
    }
    transform(key, ...params) {
        if (!key) {
            return of('');
        }
        const flatParams = params.reduce((acc, val) => (Array.isArray(val) ? acc.concat(val) : [...acc, val]), []);
        return this.configStateService.getAll$().pipe(filter$1(config => !!config.localization), take$1(1), switchMap$1(() => this.localizationService.get(key, ...flatParams)), map$1(translation => (translation && translation !== key ? translation : '')), startWith(''), distinctUntilChanged$1());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LazyLocalizationPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: LazyLocalizationPipe, isStandalone: true, name: "abpLazyLocalization" }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LazyLocalizationPipe }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LazyLocalizationPipe, decorators: [{
            type: Injectable
        }, {
            type: Pipe,
            args: [{
                    name: 'abpLazyLocalization',
                }]
        }] });

class HtmlEncodePipe {
    transform(value) {
        if (!value) {
            return value;
        }
        return value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HtmlEncodePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: HtmlEncodePipe, isStandalone: true, name: "htmlEncode" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HtmlEncodePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'htmlEncode',
                }]
        }] });

const CORE_DIRECTIVES = [
    AutofocusDirective,
    InputEventDebounceDirective,
    ForDirective,
    FormSubmitDirective,
    InitDirective,
    PermissionDirective,
    ReplaceableTemplateDirective,
    StopPropagationDirective,
];
const CORE_PIPES = [
    LocalizationPipe,
    SortPipe,
    SafeHtmlPipe,
    ShortDateTimePipe,
    ShortTimePipe,
    ShortDatePipe,
    ToInjectorPipe,
    UtcToLocalPipe,
    LazyLocalizationPipe,
];
const CORE_COMPONENTS = [
    DynamicLayoutComponent,
    ReplaceableRouteContainerComponent,
    RouterOutletComponent,
    AbstractNgModelComponent,
];
/**
 * BaseCoreModule is the module that holds
 * all imports, declarations, exports, and entryComponents
 * but not the providers.
 * This module will be imported and exported by all others.
 */
class BaseCoreModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: BaseCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: BaseCoreModule, imports: [CommonModule,
            FormsModule,
            ReactiveFormsModule,
            RouterModule,
            NgxValidateCoreModule, AutofocusDirective,
            InputEventDebounceDirective,
            ForDirective,
            FormSubmitDirective,
            InitDirective,
            PermissionDirective,
            ReplaceableTemplateDirective,
            StopPropagationDirective, LocalizationPipe,
            SortPipe,
            SafeHtmlPipe,
            ShortDateTimePipe,
            ShortTimePipe,
            ShortDatePipe,
            ToInjectorPipe,
            UtcToLocalPipe,
            LazyLocalizationPipe, DynamicLayoutComponent,
            ReplaceableRouteContainerComponent,
            RouterOutletComponent,
            AbstractNgModelComponent], exports: [CommonModule,
            FormsModule,
            ReactiveFormsModule,
            RouterModule,
            NgxValidateCoreModule, AutofocusDirective,
            InputEventDebounceDirective,
            ForDirective,
            FormSubmitDirective,
            InitDirective,
            PermissionDirective,
            ReplaceableTemplateDirective,
            StopPropagationDirective, LocalizationPipe,
            SortPipe,
            SafeHtmlPipe,
            ShortDateTimePipe,
            ShortTimePipe,
            ShortDatePipe,
            ToInjectorPipe,
            UtcToLocalPipe,
            LazyLocalizationPipe, DynamicLayoutComponent,
            ReplaceableRouteContainerComponent,
            RouterOutletComponent,
            AbstractNgModelComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: BaseCoreModule, providers: [LocalizationPipe, provideHttpClient(withInterceptorsFromDi(), withFetch())], imports: [CommonModule,
            FormsModule,
            ReactiveFormsModule,
            RouterModule,
            NgxValidateCoreModule, CommonModule,
            FormsModule,
            ReactiveFormsModule,
            RouterModule,
            NgxValidateCoreModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: BaseCoreModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        RouterModule,
                        NgxValidateCoreModule,
                        ...CORE_DIRECTIVES,
                        ...CORE_PIPES,
                        ...CORE_COMPONENTS,
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        RouterModule,
                        NgxValidateCoreModule,
                        ...CORE_DIRECTIVES,
                        ...CORE_PIPES,
                        ...CORE_COMPONENTS,
                    ],
                    declarations: [],
                    providers: [LocalizationPipe, provideHttpClient(withInterceptorsFromDi(), withFetch())],
                }]
        }] });
/**
 * RootCoreModule is the module that will be used at root level
 * and it introduces imports useful at root level (e.g. NGXS)
 */
class RootCoreModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RootCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: RootCoreModule, imports: [BaseCoreModule], exports: [BaseCoreModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RootCoreModule, providers: [
            provideHttpClient(withXsrfConfiguration({
                cookieName: 'XSRF-TOKEN',
                headerName: 'RequestVerificationToken',
            })),
        ], imports: [BaseCoreModule, BaseCoreModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RootCoreModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [BaseCoreModule],
                    imports: [BaseCoreModule],
                    providers: [
                        provideHttpClient(withXsrfConfiguration({
                            cookieName: 'XSRF-TOKEN',
                            headerName: 'RequestVerificationToken',
                        })),
                    ],
                }]
        }] });
/**
 * CoreModule is the module that is publicly available
 */
class CoreModule {
    /**
     * @deprecated forRoot method is deprecated, use `provideAbpCore` *function* for config settings.
     */
    static forRoot(options = {}) {
        return {
            ngModule: RootCoreModule,
            providers: [provideAbpCore(withOptions(options))],
        };
    }
    /**
     * @deprecated forChild method is deprecated, use `provideAbpCoreChild` *function* for config settings.
     */
    static forChild(options = {}) {
        return {
            ngModule: RootCoreModule,
            providers: [provideAbpCoreChild(options)],
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: CoreModule, imports: [BaseCoreModule], exports: [BaseCoreModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CoreModule, imports: [BaseCoreModule, BaseCoreModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CoreModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [BaseCoreModule],
                    imports: [BaseCoreModule],
                }]
        }] });

/**
 * @deprecated Use `permissionGuard` *function* instead.
 */
class PermissionGuard {
    constructor() {
        this.router = inject(Router);
        this.routesService = inject(RoutesService);
        this.authService = inject(AuthService);
        this.permissionService = inject(PermissionService);
        this.httpErrorReporter = inject(HttpErrorReporterService);
        this.configStateService = inject(ConfigStateService);
    }
    canActivate(route, state) {
        let { requiredPolicy } = route.data || {};
        if (!requiredPolicy) {
            const routeFound = findRoute(this.routesService, getRoutePath(this.router, state.url));
            requiredPolicy = routeFound?.requiredPolicy;
        }
        if (!requiredPolicy) {
            return of(true);
        }
        return this.configStateService.getAll$().pipe(filter(config => !!config?.auth?.grantedPolicies), take(1), switchMap(() => this.permissionService.getGrantedPolicy$(requiredPolicy)), take(1), map(access => {
            if (access)
                return true;
            if (route.data?.['redirectUrl']) {
                return this.router.parseUrl(route.data['redirectUrl']);
            }
            if (this.authService.isAuthenticated) {
                this.httpErrorReporter.reportError({ status: 403 });
            }
            return false;
        }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PermissionGuard, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PermissionGuard, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PermissionGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
const permissionGuard = (route, state) => {
    const router = inject(Router);
    const routesService = inject(RoutesService);
    const authService = inject(AuthService);
    const permissionService = inject(PermissionService);
    const httpErrorReporter = inject(HttpErrorReporterService);
    const configStateService = inject(ConfigStateService);
    const platformId = inject(PLATFORM_ID);
    let { requiredPolicy } = route.data || {};
    if (!requiredPolicy) {
        const routeFound = findRoute(routesService, getRoutePath(router, state.url));
        requiredPolicy = routeFound?.requiredPolicy;
    }
    if (!requiredPolicy) {
        return of(true);
    }
    //TODO enable permission check on ssr
    if (isPlatformServer(platformId)) {
        return of(true);
    }
    return configStateService.getAll$().pipe(filter(config => !!config?.auth?.grantedPolicies), take(1), switchMap(() => permissionService.getGrantedPolicy$(requiredPolicy)), take(1), map(access => {
        if (access)
            return true;
        if (route.data?.['redirectUrl']) {
            return router.parseUrl(route.data['redirectUrl']);
        }
        if (authService.isAuthenticated) {
            httpErrorReporter.reportError({ status: 403 });
        }
        return false;
    }));
};

/**
 * @deprecated Use `LocalizationPipe` and `LazyLocalizationPipe` directly as a standalone pipe.
 * This module is no longer necessary for using the `LocalizationPipe` and `LazyLocalizationPipe` pipes.
 */
class LocalizationModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalizationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: LocalizationModule, imports: [LocalizationPipe, LazyLocalizationPipe], exports: [LocalizationPipe, LazyLocalizationPipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalizationModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LocalizationModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [LocalizationPipe, LazyLocalizationPipe],
                    imports: [LocalizationPipe, LazyLocalizationPipe],
                }]
        }] });

class ListResultDto {
    constructor(initialValues = {}) {
        for (const key in initialValues) {
            if (checkHasProp(initialValues, key)) {
                this[key] = initialValues[key];
            }
        }
    }
}
class PagedResultDto extends ListResultDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleObject {
    constructor(initialValues = {}) {
        for (const key in initialValues) {
            if (checkHasProp(initialValues, key) && initialValues[key] !== undefined) {
                this[key] = initialValues[key];
            }
        }
    }
}
class ExtensibleEntityDto extends ExtensibleObject {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class LimitedResultRequestDto {
    constructor(initialValues = {}) {
        this.maxResultCount = 10;
        for (const key in initialValues) {
            if (checkHasProp(initialValues, key) && initialValues[key] !== undefined) {
                this[key] = initialValues[key];
            }
        }
    }
}
class ExtensibleLimitedResultRequestDto extends ExtensibleEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
        this.maxResultCount = 10;
    }
}
class PagedResultRequestDto extends LimitedResultRequestDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensiblePagedResultRequestDto extends ExtensibleLimitedResultRequestDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class PagedAndSortedResultRequestDto extends PagedResultRequestDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensiblePagedAndSortedResultRequestDto extends ExtensiblePagedResultRequestDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class EntityDto {
    constructor(initialValues = {}) {
        for (const key in initialValues) {
            if (checkHasProp(initialValues, key)) {
                this[key] = initialValues[key];
            }
        }
    }
}
class CreationAuditedEntityDto extends EntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class CreationAuditedEntityWithUserDto extends CreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class AuditedEntityDto extends CreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
/** @deprecated the class signature will change in v8.0 */
class AuditedEntityWithUserDto extends AuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class FullAuditedEntityDto extends AuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
/** @deprecated the class signature will change in v8.0 */
class FullAuditedEntityWithUserDto extends FullAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleCreationAuditedEntityDto extends ExtensibleEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleAuditedEntityDto extends ExtensibleCreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleAuditedEntityWithUserDto extends ExtensibleAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleCreationAuditedEntityWithUserDto extends ExtensibleCreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleFullAuditedEntityDto extends ExtensibleAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleFullAuditedEntityWithUserDto extends ExtensibleFullAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}

class AuthEvent {
    constructor(type) {
        this.type = type;
        this.type = type;
    }
}
class AuthSuccessEvent extends AuthEvent {
    constructor(type, info) {
        super(type);
        this.type = type;
        this.info = info;
    }
}
class AuthInfoEvent extends AuthEvent {
    constructor(type, info) {
        super(type);
        this.type = type;
        this.info = info;
    }
}
class AuthErrorEvent extends AuthEvent {
    constructor(type, reason, params) {
        super(type);
        this.type = type;
        this.reason = reason;
        this.params = params;
    }
}

class AbpApiDefinitionService {
    constructor() {
        this.restService = inject(RestService);
        this.apiName = 'abp';
        this.getByModel = (model, config) => this.restService.request({
            method: 'GET',
            url: '/api/abp/api-definition',
            params: { includeTypes: model.includeTypes },
        }, { apiName: this.apiName, ...config });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpApiDefinitionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpApiDefinitionService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpApiDefinitionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

var index = /*#__PURE__*/Object.freeze({
    __proto__: null
});

function validateMinAge({ age = 18 } = {}) {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        return isValidMinAge(control.value, age) ? null : { minAge: { age } };
    };
}
function isValidMinAge(value, minAge) {
    const date = new Date();
    date.setFullYear(date.getFullYear() - minAge);
    date.setHours(23, 59, 59, 999);
    return Number(new Date(value)) <= date.valueOf();
}

function validateCreditCard() {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        return isValidCreditCard(String(control.value)) ? null : { creditCard: true };
    };
}
function isValidCreditCard(value) {
    value = value.replace(/[ -]/g, '');
    if (!/^[0-9]{13,19}$/.test(value))
        return false;
    let checksum = 0;
    let multiplier = 1;
    for (let i = value.length; i > 0; i--) {
        const digit = Number(value[i - 1]) * multiplier;
        checksum += (digit % 10) + ~~(digit / 10);
        multiplier = (multiplier * 2) % 3;
    }
    return checksum % 10 === 0;
}

function validateRange({ maximum = Infinity, minimum = 0 } = {}) {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        const value = Number(control.value);
        return getMinError(value, minimum, maximum) || getMaxError(value, maximum, minimum);
    };
}
function getMaxError(value, max, min) {
    return value > max ? { range: { max, min } } : null;
}
function getMinError(value, min, max) {
    return value < min ? { range: { min, max } } : null;
}

function validateRequired({ allowEmptyStrings } = {}) {
    // note: please do not remove name of the function, it is used in function compare with type 'RequiredError'
    const required = (control) => {
        return isValidRequired(control.value, allowEmptyStrings) ? null : { required: true };
    };
    return required;
}
function isValidRequired(value, allowEmptyStrings) {
    if (value || value === 0 || value === false)
        return true;
    if (allowEmptyStrings && value === '')
        return true;
    return false;
}

function validateStringLength({ maximumLength = Infinity, minimumLength = 0, } = {}) {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        const value = String(control.value);
        return getMinLengthError(value, minimumLength) || getMaxLengthError(value, maximumLength);
    };
}
function getMaxLengthError(value, requiredLength) {
    return value.length > requiredLength ? { maxlength: { requiredLength } } : null;
}
function getMinLengthError(value, requiredLength) {
    return value.length < requiredLength ? { minlength: { requiredLength } } : null;
}

function validateUniqueCharacter() {
    return (control) => {
        if (isNullOrEmpty(control.value))
            return null;
        return isUnqiueCharacter(control.value) ? null : { uniqueCharacter: true };
    };
}
function isUnqiueCharacter(value) {
    const set = new Set(value.split(''));
    return set.size == value.length;
}

function validateUrl() {
    return (control) => {
        if (isNullOrEmpty(control.value))
            return null;
        return isValidUrl(control.value) ? null : { url: true };
    };
}
function isValidUrl(value) {
    if (/^http(s)?:\/\/[^/]/.test(value) || /^ftp:\/\/[^/]/.test(value)) {
        const a = document.createElement('a');
        a.href = value;
        return !!a.host;
    }
    return false;
}

const onlyLetterAndNumberRegex = /^[a-zA-Z0-9]+$/;
function validateUsername({ pattern = /.*/ } = { pattern: onlyLetterAndNumberRegex }) {
    return (control) => {
        const isValid = isValidUserName(control.value, pattern);
        return isValid ? null : { usernamePattern: { actualValue: control.value } };
    };
}
function isValidUserName(value, pattern) {
    if (isNullOrEmpty(value))
        return true;
    return pattern.test(value);
}

const AbpValidators = {
    creditCard: validateCreditCard,
    emailAddress: () => Validators.email,
    minAge: validateMinAge,
    range: validateRange,
    required: validateRequired,
    stringLength: validateStringLength,
    url: validateUrl,
    username: validateUsername,
    uniqueCharacter: validateUniqueCharacter,
};

// export * from './lib/handlers';

/**
 * Generated bundle index. Do not edit.
 */

export { APP_INIT_ERROR_HANDLERS, APP_STARTED_WITH_SSR, AbpApiDefinitionService, AbpApplicationConfigurationService, AbpApplicationLocalizationService, AbpCookieStorageService, AbpLocalStorageService, AbpTenantService, AbpTitleStrategy, AbpValidators, AbpWindowService, AbstractAuthErrorFilter, AbstractNavTreeService, AbstractNgModelComponent, AbstractTreeService, ApiInterceptor, AuditedEntityDto, AuditedEntityWithUserDto, AuthErrorEvent, AuthErrorFilterService, AuthEvent, AuthGuard, AuthInfoEvent, AuthService, AuthSuccessEvent, AutofocusDirective, BaseCoreModule, BaseTreeNode, CHECK_AUTHENTICATION_STATE_FN_KEY, CONTAINER_STRATEGY, CONTENT_SECURITY_STRATEGY, CONTENT_STRATEGY, CONTEXT_STRATEGY, COOKIE_LANGUAGE_KEY, CORE_OPTIONS, CROSS_ORIGIN_STRATEGY, ClearContainerStrategy, ComponentContextStrategy, ComponentProjectionStrategy, ConfigStateService, ContainerStrategy, ContentProjectionService, ContentSecurityStrategy, ContentStrategy, ContextStrategy, CookieLanguageProvider, CoreFeatureKind, CoreModule, CreationAuditedEntityDto, CreationAuditedEntityWithUserDto, CrossOriginStrategy, DEFAULT_DYNAMIC_LAYOUTS, DISABLE_PROJECT_NAME, DOM_STRATEGY, DYNAMIC_LAYOUTS_TOKEN, DefaultQueueManager, DomInsertionService, DomStrategy, DomStrategyService, DynamicLayoutComponent, EntityDto, EnvironmentService, ExtensibleAuditedEntityDto, ExtensibleAuditedEntityWithUserDto, ExtensibleCreationAuditedEntityDto, ExtensibleCreationAuditedEntityWithUserDto, ExtensibleEntityDto, ExtensibleFullAuditedEntityDto, ExtensibleFullAuditedEntityWithUserDto, ExtensibleLimitedResultRequestDto, ExtensibleObject, ExtensiblePagedAndSortedResultRequestDto, ExtensiblePagedResultRequestDto, ExternalHttpClient, ForDirective, FormSubmitDirective, FullAuditedEntityDto, FullAuditedEntityWithUserDto, HtmlEncodePipe, HtmlEncodingService, HttpErrorReporterService, HttpWaitService, INCUDE_LOCALIZATION_RESOURCES_TOKEN, INJECTOR_PIPE_DATA_TOKEN, IS_EXTERNAL_REQUEST, IncludeLocalizationResourcesProvider, InitDirective, InputEventDebounceDirective, InsertIntoContainerStrategy, InternalStore, InternetConnectionService, LIST_QUERY_DEBOUNCE_TIME, LOADER_DELAY, LOADING_STRATEGY, LOCALIZATIONS, LazyLoadService, LazyLocalizationPipe, LazyModuleFactory, LimitedResultRequestDto, ListResultDto, ListService, LoadingStrategy, LocalStorageListenerService, LocaleId, LocaleProvider, LocalizationModule, LocalizationPipe, LocalizationService, LooseContentSecurityStrategy, MultiTenancyService, NAVIGATE_TO_MANAGE_PROFILE, NavigationEvent, NoContentSecurityStrategy, NoContextStrategy, NoCrossOriginStrategy, OTHERS_GROUP, index as ObjectExtending, PIPE_TO_LOGIN_FN_KEY, PROJECTION_STRATEGY, PagedAndSortedResultRequestDto, PagedResultDto, PagedResultRequestDto, PermissionDirective, PermissionGuard, PermissionService, ProjectionStrategy, QUEUE_MANAGER, ReplaceableComponentsService, ReplaceableRouteContainerComponent, ReplaceableTemplateDirective, ResourceWaitService, RestService, RootComponentProjectionStrategy, RootCoreModule, RouterEvents, RouterOutletComponent, RouterWaitService, RoutesService, SET_TOKEN_RESPONSE_TO_STORAGE_FN_KEY, SORT_COMPARE_FUNC, SSR_FLAG, SafeHtmlPipe, ScriptContentStrategy, ScriptLoadingStrategy, ServerCookieParser, SessionStateService, ShortDatePipe, ShortDateTimePipe, ShortTimePipe, ShowPasswordDirective, SortPipe, StopPropagationDirective, StyleContentStrategy, StyleLoadingStrategy, SubscriptionService, TENANT_KEY, TENANT_NOT_FOUND_BY_NAME, TemplateContextStrategy, TemplateProjectionStrategy, TimeService, TimezoneService, ToInjectorPipe, TrackByService, TrackCapsLockDirective, UtcToLocalPipe, WebHttpUrlEncodingCodec, asyncAuthGuard, authGuard, checkHasProp, compareFuncFactory, coreOptionsFactory, createGroupMap, createLocalizationPipeKeyGenerator, createLocalizer, createLocalizerWithFallback, createMapFromList, createTokenParser, createTreeFromList, createTreeNodeFilterCreator, deepMerge, differentLocales, downloadBlob, escapeHtmlChars, exists, featuresFactory, findRoute, fromLazyLoad, generateHash, generatePassword, getCurrentTenancyNameFromUrl, getInitialData, getLocaleDirection, getPathName, getRemoteEnv, getRoutePath, getShortDateFormat, getShortDateShortTimeFormat, getShortTimeFormat, interpolate, isArray, isNode, isNullOrEmpty, isNullOrUndefined, isNumber, isObject, isObjectAndNotArray, isObjectAndNotArrayNotNode, isUndefinedOrEmptyString, localeInitializer, localizationContributor, localizations$, mapEnumToOptions, noop, parseTenantFromUrl, permissionGuard, provideAbpCore, provideAbpCoreChild, pushValueTo, reloadRoute, setLanguageToCookie, timezoneInterceptor, trackBy, trackByDeep, transferStateInterceptor, uuid, validateCreditCard, validateMinAge, validateRange, validateRequired, validateStringLength, validateUniqueCharacter, validateUrl, withCompareFuncFactory, withOptions, withTitleStrategy };
//# sourceMappingURL=abp-ng.core.mjs.map
