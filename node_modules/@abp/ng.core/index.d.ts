import * as i3 from '@angular/router';
import { ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, CanActivateFn, Params, Routes, Router, RouterEvent, Event as Event$1, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, TitleStrategy, ActivatedRoute } from '@angular/router';
import * as rxjs from 'rxjs';
import { Observable, UnaryFunction, Subject, Subscription, PartialObserver, ReplaySubject, BehaviorSubject } from 'rxjs';
import * as i0 from '@angular/core';
import { ChangeDetectorRef, Injector, Type, EventEmitter, TemplateRef, OnDestroy, ComponentRef, ViewContainerRef, EmbeddedViewRef, TrackByFunction, OnInit, AfterViewInit, OnChanges, ElementRef, SimpleChanges, PipeTransform, InjectionToken, ModuleWithProviders, Provider, NgModuleFactory, NgModuleRef, NgZone } from '@angular/core';
import * as i2 from '@angular/forms';
import { ControlValueAccessor, ValidatorFn, Validators } from '@angular/forms';
import { HttpHeaders, HttpParameterCodec, HttpParams, HttpErrorResponse, HttpRequest, HttpClient, HttpContextToken, HttpInterceptor, HttpHandler, HttpEvent, HttpInterceptorFn } from '@angular/common/http';
import { AuthConfig } from 'angular-oauth2-oidc';
import * as i1 from '@angular/common';
import { DatePipe } from '@angular/common';
import * as i4 from '@ngx-validate/core';
export { NgxValidateCoreModule, Validation } from '@ngx-validate/core';
import * as _abp_ng_core from '@abp/ng.core';
import { DateTime } from 'luxon';
import { O as O$1 } from 'ts-toolbelt';
import { Title } from '@angular/platform-browser';

interface IAbpGuard {
    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;
}

declare class AbstractNgModelComponent<T = any, U = T> implements ControlValueAccessor {
    protected _value: T;
    protected cdRef: ChangeDetectorRef;
    onChange?: (value: T) => void;
    onTouched?: () => void;
    disabled?: boolean;
    readonly?: boolean;
    valueFn: (value: U, previousValue?: T) => T;
    valueLimitFn: (value: T, previousValue?: T) => any;
    set value(value: T);
    get value(): T;
    get defaultValue(): T;
    notifyValueChange(): void;
    writeValue(value: T): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    setDisabledState(isDisabled: boolean): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbstractNgModelComponent<any, any>, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AbstractNgModelComponent<any, any>, "ng-component", never, { "disabled": { "alias": "disabled"; "required": false; }; "readonly": { "alias": "readonly"; "required": false; }; "valueFn": { "alias": "valueFn"; "required": false; }; "valueLimitFn": { "alias": "valueLimitFn"; "required": false; }; "value": { "alias": "value"; "required": false; }; }, {}, never, never, true, never>;
}

/**
 * @deprecated Use `authGuard` *function* instead.
 */
declare class AuthGuard implements IAbpGuard {
    canActivate(): Observable<boolean> | boolean | UrlTree;
    static ɵfac: i0.ɵɵFactoryDeclaration<AuthGuard, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AuthGuard>;
}
declare const authGuard: CanActivateFn;
declare const asyncAuthGuard: CanActivateFn;

type EventType = 'discovery_document_loaded' | 'jwks_load_error' | 'invalid_nonce_in_state' | 'discovery_document_load_error' | 'discovery_document_validation_error' | 'user_profile_loaded' | 'user_profile_load_error' | 'token_received' | 'token_error' | 'code_error' | 'token_refreshed' | 'token_refresh_error' | 'silent_refresh_error' | 'silently_refreshed' | 'silent_refresh_timeout' | 'token_validation_error' | 'token_expires' | 'session_changed' | 'session_error' | 'session_terminated' | 'session_unchanged' | 'logout' | 'popup_closed' | 'popup_blocked' | 'token_revoke_error';
declare abstract class AuthEvent {
    readonly type: EventType;
    constructor(type: EventType);
}
declare class AuthSuccessEvent extends AuthEvent {
    readonly type: EventType;
    readonly info?: any;
    constructor(type: EventType, info?: any);
}
declare class AuthInfoEvent extends AuthEvent {
    readonly type: EventType;
    readonly info?: any;
    constructor(type: EventType, info?: any);
}
declare class AuthErrorEvent extends AuthEvent {
    readonly type: EventType;
    readonly reason: object;
    readonly params?: object;
    constructor(type: EventType, reason: object, params?: object);
}

interface LoginParams {
    username: string;
    password: string;
    rememberMe?: boolean;
    redirectUrl?: string;
}
type PipeToLoginFn = (params: Pick<LoginParams, 'redirectUrl' | 'rememberMe'>, injector: Injector) => UnaryFunction<any, any>;
/**
 * @deprecated The interface should not be used anymore.
 */
type SetTokenResponseToStorageFn<T = any> = (tokenRes: T) => void;
type CheckAuthenticationStateFn = (injector: Injector) => void;
interface AuthErrorFilter<T = AuthErrorEvent> {
    id: string;
    executable: boolean;
    execute: (event: T) => boolean;
}

interface AbpAuthResponse {
    access_token: string;
    id_token: string;
    token_type: string;
    expires_in: number;
    refresh_token: string;
    scope: string;
    state?: string;
    tenant_domain?: string;
}

/**
 * Abstract service for Authentication.
 */
declare class AuthService implements IAuthService {
    private warningMessage;
    get oidc(): boolean;
    set oidc(value: boolean);
    init(): Promise<any>;
    login(params: LoginParams): Observable<any>;
    logout(queryParams?: Params): Observable<any>;
    navigateToLogin(queryParams?: Params): void;
    get isInternalAuth(): boolean;
    get isAuthenticated(): boolean;
    loginUsingGrant(grantType: string, parameters: object, headers?: HttpHeaders): Promise<AbpAuthResponse>;
    getAccessTokenExpiration(): number;
    getRefreshToken(): string;
    getAccessToken(): string;
    refreshToken(): Promise<AbpAuthResponse>;
    static ɵfac: i0.ɵɵFactoryDeclaration<AuthService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AuthService>;
}
interface IAuthService {
    oidc: boolean;
    get isInternalAuth(): boolean;
    get isAuthenticated(): boolean;
    init(): Promise<any>;
    logout(queryParams?: Params): Observable<any>;
    navigateToLogin(queryParams?: Params): void;
    login(params: LoginParams): Observable<any>;
    loginUsingGrant(grantType: string, parameters: object, headers?: HttpHeaders): Promise<AbpAuthResponse>;
    getAccessTokenExpiration(): number;
    getRefreshToken(): string;
    getAccessToken(): string;
    refreshToken(): Promise<AbpAuthResponse | void>;
}

declare const enum eLayoutType {
    account = "account",
    application = "application",
    empty = "empty"
}
declare const enum eThemeSharedComponents {
    ApplicationLayoutComponent = "Theme.ApplicationLayoutComponent",
    AccountLayoutComponent = "Theme.AccountLayoutComponent",
    EmptyLayoutComponent = "Theme.EmptyLayoutComponent"
}

interface Environment {
    apis: Apis;
    application: ApplicationInfo;
    hmr?: boolean;
    test?: boolean;
    localization?: {
        defaultResourceName?: string;
    };
    oAuthConfig?: AuthConfig & {
        impersonation?: Impersonation;
        ssrAuthorizationUrl?: string;
    };
    production: boolean;
    remoteEnv?: RemoteEnv;
    [key: string]: any;
}
interface ApplicationInfo {
    name: string;
    baseUrl?: string;
    logoUrl?: string;
}
interface HasAdditional {
    [key: string]: string;
}
interface ApiConfig extends Partial<HasAdditional> {
    url: string;
    rootNamespace?: string;
}
interface Apis {
    [key: string]: Partial<ApiConfig>;
    default: ApiConfig;
}
type customMergeFn = (localEnv: Partial<Environment>, remoteEnv: any) => Environment;
interface RemoteEnv {
    url: string;
    mergeStrategy: 'deepmerge' | 'overwrite' | customMergeFn;
    method?: string;
    headers?: ABP.Dictionary<string>;
}
interface Impersonation {
    tenantImpersonation?: boolean;
    userImpersonation?: boolean;
}

declare namespace ABP {
    interface Root {
        environment: Partial<Environment>;
        registerLocaleFn: (locale: string) => Promise<any>;
        skipGetAppConfiguration?: boolean;
        skipInitAuthService?: boolean;
        sendNullsAsQueryParam?: boolean;
        tenantKey?: string;
        localizations?: Localization[];
        othersGroup?: string;
        dynamicLayouts?: Map<string, string>;
        disableProjectNameInTitle?: boolean;
    }
    interface Child {
        localizations?: Localization[];
    }
    interface Localization {
        culture: string;
        resources: LocalizationResource[];
    }
    interface LocalizationResource {
        resourceName: string;
        texts: Record<string, string>;
    }
    interface HasPolicy {
        requiredPolicy?: string;
    }
    interface Test extends Partial<Root> {
        baseHref?: string;
        listQueryDebounceTime?: number;
        routes?: Routes;
    }
    type PagedResponse<T> = {
        totalCount: number;
    } & PagedItemsResponse<T>;
    interface PagedItemsResponse<T> {
        items: T[];
    }
    interface PageQueryParams {
        filter?: string;
        sorting?: string;
        skipCount?: number;
        maxResultCount?: number;
    }
    interface Lookup {
        id: string;
        displayName: string;
    }
    interface Nav {
        name: string;
        parentName?: string;
        requiredPolicy?: string;
        order?: number;
        invisible?: boolean;
    }
    interface Route extends Nav {
        path?: string;
        layout?: eLayoutType;
        iconClass?: string;
        group?: string;
        breadcrumbText?: string;
    }
    interface Tab extends Nav {
        component: Type<any>;
    }
    interface BasicItem {
        id: string;
        name: string;
    }
    interface Option<T> {
        key: Extract<keyof T, string>;
        value: T[Extract<keyof T, string>];
    }
    interface Dictionary<T = any> {
        [key: string]: T;
    }
    type ExtractFromOutput<T extends EventEmitter<any> | Subject<any>> = T extends EventEmitter<infer X> ? X : T extends Subject<infer Y> ? Y : never;
}

declare class ListResultDto<T> {
    items?: T[];
    constructor(initialValues?: Partial<ListResultDto<T>>);
}
declare class PagedResultDto<T> extends ListResultDto<T> {
    totalCount?: number;
    constructor(initialValues?: Partial<PagedResultDto<T>>);
}
declare class ExtensibleObject {
    extraProperties?: ABP.Dictionary<any>;
    constructor(initialValues?: Partial<ExtensibleObject>);
}
declare class ExtensibleEntityDto<TKey = string> extends ExtensibleObject {
    id?: TKey;
    constructor(initialValues?: Partial<ExtensibleEntityDto<TKey>>);
}
declare class LimitedResultRequestDto {
    maxResultCount: number;
    constructor(initialValues?: Partial<LimitedResultRequestDto>);
}
declare class ExtensibleLimitedResultRequestDto extends ExtensibleEntityDto {
    maxResultCount: number;
    constructor(initialValues?: Partial<ExtensibleLimitedResultRequestDto>);
}
declare class PagedResultRequestDto extends LimitedResultRequestDto {
    skipCount?: number;
    constructor(initialValues?: Partial<PagedResultRequestDto>);
}
declare class ExtensiblePagedResultRequestDto extends ExtensibleLimitedResultRequestDto {
    skipCount?: number;
    constructor(initialValues?: Partial<ExtensiblePagedResultRequestDto>);
}
declare class PagedAndSortedResultRequestDto extends PagedResultRequestDto {
    sorting?: string;
    constructor(initialValues?: Partial<PagedAndSortedResultRequestDto>);
}
declare class ExtensiblePagedAndSortedResultRequestDto extends ExtensiblePagedResultRequestDto {
    sorting?: string;
    constructor(initialValues?: Partial<ExtensiblePagedAndSortedResultRequestDto>);
}
declare class EntityDto<TKey = string> {
    id?: TKey;
    constructor(initialValues?: Partial<EntityDto<TKey>>);
}
declare class CreationAuditedEntityDto<TPrimaryKey = string> extends EntityDto<TPrimaryKey> {
    creationTime?: string | Date;
    creatorId?: string;
    constructor(initialValues?: Partial<CreationAuditedEntityDto<TPrimaryKey>>);
}
declare class CreationAuditedEntityWithUserDto<TPrimaryKey = string, TUserDto = any> extends CreationAuditedEntityDto<TPrimaryKey> {
    creator?: TUserDto;
    constructor(initialValues?: Partial<CreationAuditedEntityWithUserDto<TPrimaryKey, TUserDto>>);
}
declare class AuditedEntityDto<TPrimaryKey = string> extends CreationAuditedEntityDto<TPrimaryKey> {
    lastModificationTime?: string | Date;
    lastModifierId?: string;
    constructor(initialValues?: Partial<AuditedEntityDto<TPrimaryKey>>);
}
/** @deprecated the class signature will change in v8.0 */
declare class AuditedEntityWithUserDto<TPrimaryKey = string, TUserDto = any> extends AuditedEntityDto<TPrimaryKey> {
    creator?: TUserDto;
    lastModifier?: TUserDto;
    constructor(initialValues?: Partial<AuditedEntityWithUserDto<TPrimaryKey, TUserDto>>);
}
declare class FullAuditedEntityDto<TPrimaryKey = string> extends AuditedEntityDto<TPrimaryKey> {
    isDeleted?: boolean;
    deleterId?: string;
    deletionTime?: Date | string;
    constructor(initialValues?: Partial<FullAuditedEntityDto<TPrimaryKey>>);
}
/** @deprecated the class signature will change in v8.0 */
declare class FullAuditedEntityWithUserDto<TPrimaryKey = string, TUserDto = any> extends FullAuditedEntityDto<TPrimaryKey> {
    creator?: TUserDto;
    lastModifier?: TUserDto;
    deleter?: TUserDto;
    constructor(initialValues?: Partial<FullAuditedEntityWithUserDto<TPrimaryKey, TUserDto>>);
}
declare class ExtensibleCreationAuditedEntityDto<TPrimaryKey = string> extends ExtensibleEntityDto<TPrimaryKey> {
    creationTime?: Date | string;
    creatorId?: string;
    constructor(initialValues?: Partial<ExtensibleCreationAuditedEntityDto<TPrimaryKey>>);
}
declare class ExtensibleAuditedEntityDto<TPrimaryKey = string> extends ExtensibleCreationAuditedEntityDto<TPrimaryKey> {
    lastModificationTime?: Date | string;
    lastModifierId?: string;
    constructor(initialValues?: Partial<ExtensibleAuditedEntityDto<TPrimaryKey>>);
}
declare class ExtensibleAuditedEntityWithUserDto<TPrimaryKey = string, TUserDto = any> extends ExtensibleAuditedEntityDto<TPrimaryKey> {
    creator?: TUserDto;
    lastModifier?: TUserDto;
    constructor(initialValues?: Partial<ExtensibleAuditedEntityWithUserDto<TPrimaryKey>>);
}
declare class ExtensibleCreationAuditedEntityWithUserDto<TPrimaryKey = string, TUserDto = any> extends ExtensibleCreationAuditedEntityDto<TPrimaryKey> {
    creator?: TUserDto;
    constructor(initialValues?: Partial<ExtensibleCreationAuditedEntityWithUserDto<TPrimaryKey>>);
}
declare class ExtensibleFullAuditedEntityDto<TPrimaryKey = string> extends ExtensibleAuditedEntityDto<TPrimaryKey> {
    isDeleted?: boolean;
    deleterId?: string;
    deletionTime?: Date | string;
    constructor(initialValues?: Partial<ExtensibleFullAuditedEntityDto<TPrimaryKey>>);
}
declare class ExtensibleFullAuditedEntityWithUserDto<TPrimaryKey = string, TUserDto = any> extends ExtensibleFullAuditedEntityDto<TPrimaryKey> {
    creator?: TUserDto;
    lastModifier?: TUserDto;
    deleter?: TUserDto;
    constructor(initialValues?: Partial<ExtensibleFullAuditedEntityWithUserDto<TPrimaryKey>>);
}

interface LocalizationWithDefault {
    key: string;
    defaultValue: string;
}
type LocalizationParam = string | LocalizationWithDefault;

declare namespace ReplaceableComponents {
    interface State {
        replaceableComponents: ReplaceableComponent[];
    }
    interface ReplaceableComponent {
        component: Type<any>;
        key: string;
    }
    interface ReplaceableTemplateDirectiveInput<I, O extends {
        [K in keyof O]: EventEmitter<any> | Subject<any>;
    }> {
        inputs?: {
            -readonly [K in keyof I]: {
                value: I[K];
                twoWay?: boolean;
            };
        };
        outputs?: {
            -readonly [K in keyof O]: (value: ABP.ExtractFromOutput<O[K]>) => void;
        };
        componentKey: string;
    }
    interface ReplaceableTemplateData<I, O extends {
        [K in keyof O]: EventEmitter<any> | Subject<any>;
    }> {
        inputs: ReplaceableTemplateInputs<I>;
        outputs: ReplaceableTemplateOutputs<O>;
        componentKey: string;
    }
    type ReplaceableTemplateInputs<T> = {
        [K in keyof T]: T[K];
    };
    type ReplaceableTemplateOutputs<T extends {
        [K in keyof T]: EventEmitter<any> | Subject<any>;
    }> = {
        [K in keyof T]: (value: ABP.ExtractFromOutput<T[K]>) => void;
    };
    interface RouteData<T = any> {
        key: string;
        defaultComponent: Type<T>;
    }
}

declare namespace Rest {
    type Config = Partial<{
        apiName: string;
        skipHandleError: boolean;
        skipAddingHeader: boolean;
        observe: Observe;
        httpParamEncoder?: HttpParameterCodec;
        responseType: ResponseType;
    }>;
    const enum Observe {
        Body = "body",
        Events = "events",
        Response = "response"
    }
    const enum ResponseType {
        ArrayBuffer = "arraybuffer",
        Blob = "blob",
        JSON = "json",
        Text = "text"
    }
    type Params = HttpParams | {
        [param: string]: any;
    };
    interface Request<T> {
        body?: T;
        headers?: HttpHeaders | {
            [header: string]: string | string[];
        };
        method: string;
        params?: Params;
        reportProgress?: boolean;
        responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';
        url: string;
        withCredentials?: boolean;
    }
}

interface FindTenantResultDto {
    success: boolean;
    tenantId?: string;
    name?: string;
    normalizedName?: string;
    isActive: boolean;
}
interface CurrentTenantDto {
    id?: string;
    name?: string;
    isAvailable: boolean;
}
interface MultiTenancyInfoDto {
    isEnabled: boolean;
}

declare namespace Session {
    interface State {
        language: string;
        tenant: CurrentTenantDto | null;
    }
}

type DeepPartial<T> = Partible<T> extends never ? T : {
    [K in keyof T]?: DeepPartial<T[K]>;
};
type Partible<T> = T extends Primitive | Array<any> | Node ? never : {
    [K in keyof T]: T[K] extends Function ? never : T[K];
} extends T ? T : never;
type Primitive = undefined | null | boolean | string | number | bigint | symbol;
type InferredInstanceOf<T> = T extends Type<infer U> ? U : never;
type InferredContextOf<T> = T extends TemplateRef<infer U> ? U : never;
type Strict<Class, Contract> = Class extends Contract ? {
    [K in keyof Class]: K extends keyof Contract ? Contract[K] : never;
} : Contract;

interface SortableItem {
    id?: string | number;
    name?: string;
    order?: number;
}

declare abstract class AbstractAuthErrorFilter<T, E> {
    abstract get(id: string): T;
    abstract add(filter: T): void;
    abstract patch(item: Partial<T>): void;
    abstract remove(id: string): void;
    abstract run(event: E): boolean;
}
declare class AuthErrorFilterService<T = AuthErrorFilter, E = AuthErrorEvent> extends AbstractAuthErrorFilter<T, E> {
    private warningMessage;
    get(id: string): T;
    add(filter: T): void;
    patch(item: Partial<T>): void;
    remove(id: string): void;
    run(event: E): boolean;
}

interface EntityExtensionDto {
    properties: Record<string, ExtensionPropertyDto>;
    configuration: Record<string, object>;
}
interface ExtensionEnumDto {
    fields: ExtensionEnumFieldDto[];
    localizationResource?: string;
}
interface ExtensionEnumFieldDto {
    name?: string;
    value: object;
}
interface ExtensionPropertyApiCreateDto {
    isAvailable: boolean;
}
interface ExtensionPropertyApiDto {
    onGet: ExtensionPropertyApiGetDto;
    onCreate: ExtensionPropertyApiCreateDto;
    onUpdate: ExtensionPropertyApiUpdateDto;
}
interface ExtensionPropertyApiGetDto {
    isAvailable: boolean;
}
interface ExtensionPropertyApiUpdateDto {
    isAvailable: boolean;
}
interface ExtensionPropertyAttributeDto {
    typeSimple?: string;
    config: Record<string, object>;
}
interface ExtensionPropertyDto {
    type?: string;
    typeSimple?: string;
    displayName: LocalizableStringDto;
    api: ExtensionPropertyApiDto;
    ui: ExtensionPropertyUiDto;
    attributes: ExtensionPropertyAttributeDto[];
    configuration: Record<string, object>;
    defaultValue: object;
}
interface ExtensionPropertyUiDto {
    onTable: ExtensionPropertyUiTableDto;
    onCreateForm: ExtensionPropertyUiFormDto;
    onEditForm: ExtensionPropertyUiFormDto;
    lookup: ExtensionPropertyUiLookupDto;
}
interface ExtensionPropertyUiFormDto {
    isVisible: boolean;
}
interface ExtensionPropertyUiLookupDto {
    url?: string;
    resultListPropertyName?: string;
    displayPropertyName?: string;
    valuePropertyName?: string;
    filterParamName?: string;
}
interface ExtensionPropertyUiTableDto {
    isVisible: boolean;
}
interface LocalizableStringDto {
    name?: string;
    resource?: string;
}
interface ModuleExtensionDto {
    entities: Record<string, EntityExtensionDto>;
    configuration: Record<string, object>;
}
interface ObjectExtensionsDto {
    modules: Record<string, ModuleExtensionDto>;
    enums: Record<string, ExtensionEnumDto>;
}

interface LanguageInfo {
    cultureName?: string;
    uiCultureName?: string;
    displayName?: string;
    twoLetterISOLanguageName?: string;
    flagIcon?: string;
}

interface NameValue<T = string> {
    name?: string;
    value: T;
}

interface ApplicationAuthConfigurationDto {
    grantedPolicies: Record<string, boolean>;
}
interface ApplicationConfigurationDto {
    localization: ApplicationLocalizationConfigurationDto;
    auth: ApplicationAuthConfigurationDto;
    setting: ApplicationSettingConfigurationDto;
    currentUser: CurrentUserDto;
    features: ApplicationFeatureConfigurationDto;
    globalFeatures: ApplicationGlobalFeatureConfigurationDto;
    multiTenancy: MultiTenancyInfoDto;
    currentTenant: CurrentTenantDto;
    timing: TimingDto;
    clock: ClockDto;
    objectExtensions: ObjectExtensionsDto;
    extraProperties: Record<string, object>;
}
interface ApplicationConfigurationRequestOptions {
    includeLocalizationResources: boolean;
}
interface ApplicationFeatureConfigurationDto {
    values: Record<string, string>;
}
interface ApplicationGlobalFeatureConfigurationDto {
    enabledFeatures: string[];
}
interface ApplicationLocalizationConfigurationDto {
    values: Record<string, Record<string, string>>;
    resources: Record<string, ApplicationLocalizationResourceDto>;
    languages: LanguageInfo[];
    currentCulture: CurrentCultureDto;
    defaultResourceName?: string;
    languagesMap: Record<string, NameValue[]>;
    languageFilesMap: Record<string, NameValue[]>;
}
interface ApplicationLocalizationDto {
    resources: Record<string, ApplicationLocalizationResourceDto>;
    currentCulture: CurrentCultureDto;
}
interface ApplicationLocalizationRequestDto {
    cultureName: string;
    onlyDynamics: boolean;
}
interface ApplicationLocalizationResourceDto {
    texts: Record<string, string>;
    baseResources: string[];
}
interface ApplicationSettingConfigurationDto {
    values: Record<string, string>;
}
interface ClockDto {
    kind?: string;
}
interface CurrentCultureDto {
    displayName?: string;
    englishName?: string;
    threeLetterIsoLanguageName?: string;
    twoLetterIsoLanguageName?: string;
    isRightToLeft: boolean;
    cultureName?: string;
    name?: string;
    nativeName?: string;
    dateTimeFormat: DateTimeFormatDto;
}
interface CurrentUserDto {
    isAuthenticated: boolean;
    id?: string;
    tenantId?: string;
    impersonatorUserId?: string;
    impersonatorTenantId?: string;
    impersonatorUserName?: string;
    impersonatorTenantName?: string;
    userName?: string;
    name?: string;
    surName?: string;
    email?: string;
    emailVerified: boolean;
    phoneNumber?: string;
    phoneNumberVerified: boolean;
    roles: string[];
}
interface DateTimeFormatDto {
    calendarAlgorithmType?: string;
    dateTimeFormatLong?: string;
    shortDatePattern?: string;
    fullDateTimePattern?: string;
    dateSeparator?: string;
    shortTimePattern?: string;
    longTimePattern?: string;
}
interface IanaTimeZone {
    timeZoneName?: string;
}
interface TimeZone {
    iana: IanaTimeZone;
    windows: WindowsTimeZone;
}
interface TimingDto {
    timeZone: TimeZone;
}
interface WindowsTimeZone {
    timeZoneId?: string;
}

declare class LocalizationService {
    private sessionState;
    private injector;
    private configState;
    private latestLang;
    private _languageChange$;
    private uiLocalizations$;
    private localizations$;
    /**
     * Returns currently selected language
     * Even though this looks like it's redundant to return the same value as `getLanguage()`,
     * it's actually not. This could be invoked any time, and the latestLang could be different from the
     * sessionState.getLanguage() value.
     */
    get currentLang(): string;
    get currentLang$(): Observable<string>;
    get languageChange$(): Observable<string>;
    constructor();
    private initLocalizationValues;
    addLocalization(localizations?: ABP.Localization[]): void;
    private listenToSetLanguage;
    registerLocale(locale: string): Promise<void>;
    /**
     * Returns an observable localized text with the given interpolation parameters in current language.
     * @param key Localizaton key to replace with localized text
     * @param interpolateParams Values to interpolate
     */
    get(key: string | LocalizationWithDefault, ...interpolateParams: string[]): Observable<string>;
    getResource(resourceName: string): Record<string, string>;
    getResource$(resourceName: string): Observable<Record<string, string>>;
    /**
     * Returns localized text with the given interpolation parameters in current language.
     * @param key Localization key to replace with localized text
     * @param interpolateParams Values to intepolate.
     */
    instant(key: string | LocalizationWithDefault, ...interpolateParams: string[]): string;
    localize(resourceName: string, key: string, defaultValue: string): Observable<string | null>;
    localizeSync(resourceName: string, key: string, defaultValue: string): string | null;
    localizeWithFallback(resourceNames: string[], keys: string[], defaultValue: string): Observable<string>;
    localizeWithFallbackSync(resourceNames: string[], keys: string[], defaultValue: string): string;
    private getLocalization;
    static ɵfac: i0.ɵɵFactoryDeclaration<LocalizationService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<LocalizationService>;
}
type LegacyLanguageDto = Record<string, Record<string, string>>;
type ResourceDto = Record<string, ApplicationLocalizationResourceDto>;

declare class ReplaceableComponentsService {
    private ngZone;
    private router;
    private readonly store;
    get replaceableComponents$(): Observable<ReplaceableComponents.ReplaceableComponent[]>;
    get replaceableComponents(): ReplaceableComponents.ReplaceableComponent[];
    get onUpdate$(): Observable<ReplaceableComponents.ReplaceableComponent[]>;
    constructor();
    add(replaceableComponent: ReplaceableComponents.ReplaceableComponent, reload?: boolean): void;
    get(replaceableComponentKey: string): ReplaceableComponents.ReplaceableComponent | undefined;
    get$(replaceableComponentKey: string): Observable<ReplaceableComponents.ReplaceableComponent | undefined>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ReplaceableComponentsService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ReplaceableComponentsService>;
}

declare const NavigationEvent: {
    Cancel: typeof NavigationCancel;
    End: typeof NavigationEnd;
    Error: typeof NavigationError;
    Start: typeof NavigationStart;
};
declare class RouterEvents {
    #private;
    protected readonly router: Router;
    previousNavigation: i0.Signal<string>;
    currentNavigation: i0.Signal<string>;
    constructor();
    protected listenToNavigation(): void;
    getEvents<T extends RouterEventConstructors>(...eventTypes: T): Observable<Event$1>;
    getNavigationEvents<T extends NavigationEventKeys>(...navigationEventKeys: T): Observable<T extends (infer Key)[] ? Key extends "Cancel" | "End" | "Error" | "Start" ? InstanceType<{
        Cancel: typeof NavigationCancel;
        End: typeof NavigationEnd;
        Error: typeof NavigationError;
        Start: typeof NavigationStart;
    }[Key]> : never : never>;
    getAllEvents(): Observable<Event$1>;
    getAllNavigationEvents(): Observable<NavigationStart | NavigationEnd | NavigationCancel | NavigationError>;
    static ɵfac: i0.ɵɵFactoryDeclaration<RouterEvents, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<RouterEvents>;
}
type RouterEventConstructors = [Type<RouterEvent>, ...Type<RouterEvent>[]];
type NavigationEventKeys = [NavigationEventKey, ...NavigationEventKey[]];
type NavigationEventType = typeof NavigationEvent;
type NavigationEventKey = keyof NavigationEventType;

declare class BaseTreeNode<T extends object> {
    children: TreeNode<T>[];
    isLeaf: boolean;
    parent?: TreeNode<T>;
    constructor(props: T);
    static create<T extends object>(props: T): TreeNode<T>;
}
declare function createTreeFromList<T extends object, R>(list: T[], keySelector: (item: T) => NodeKey, parentKeySelector: typeof keySelector, valueMapper: (item: T) => R): R[];
declare function createMapFromList<T extends object, R>(list: T[], keySelector: (item: T) => NodeKey, valueMapper: (item: T) => R): Map<NodeKey, R>;
declare function createTreeNodeFilterCreator<T extends object>(key: keyof T, mapperFn: (value: any) => string): (search: string) => (nodes: TreeNode<T>[], matches?: TreeNode<T>[]) => TreeNode<T>[];
declare function createGroupMap<T extends {
    group?: string;
}>(list: TreeNode<T>[], othersGroupKey: string): Map<string, TreeNode<T>[]>;
type TreeNode<T extends object> = {
    [K in keyof T]: T[K];
} & {
    children: TreeNode<T>[];
    isLeaf: boolean;
    parent?: TreeNode<T>;
};
type RouteGroup<T extends object> = {
    readonly group: string;
    readonly items: TreeNode<T>[];
};
type NodeKey = number | string | symbol | undefined | null;
type NodeValue<T extends object, F extends (...args: any) => any> = F extends undefined ? TreeNode<T> : ReturnType<F>;

declare abstract class AbstractTreeService<T extends {
    [key: string | number | symbol]: any;
}> {
    abstract id: string;
    abstract parentId: string;
    abstract hide: (item: T) => boolean;
    abstract sort: (a: T, b: T) => number;
    private _flat$;
    private _tree$;
    private _visible$;
    protected othersGroup: string;
    protected shouldSingularizeRoutes: boolean;
    get flat(): T[];
    get flat$(): Observable<T[]>;
    get tree(): TreeNode<T>[];
    get tree$(): Observable<TreeNode<T>[]>;
    get visible(): TreeNode<T>[];
    get visible$(): Observable<TreeNode<T>[]>;
    private filterWith;
    private findItemsToRemove;
    private publish;
    protected createTree(items: T[]): TreeNode<T>[];
    protected createGroupedTree(list: TreeNode<T>[]): RouteGroup<T>[] | undefined;
    add(items: T[]): T[];
    find(predicate: (item: TreeNode<T>) => boolean, tree?: TreeNode<T>[]): TreeNode<T> | null;
    patch(identifier: string, props: Partial<T>): T[] | false;
    refresh(): T[];
    remove(identifiers: string[]): T[];
    removeByParam(params: Partial<T>): T[] | null;
    search(params: Partial<T>, tree?: TreeNode<T>[]): TreeNode<T> | null;
    setSingularizeStatus(singularize?: boolean): void;
}
declare abstract class AbstractNavTreeService<T extends ABP.Nav> extends AbstractTreeService<T> implements OnDestroy {
    protected injector: Injector;
    private subscription;
    private permissionService;
    private compareFunc;
    readonly id = "name";
    readonly parentId = "parentName";
    readonly hide: (item: T) => boolean;
    readonly sort: (a: T, b: T) => any;
    constructor();
    protected isGranted({ requiredPolicy }: T): boolean;
    hasChildren(identifier: string): boolean;
    hasInvisibleChild(identifier: string): boolean;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbstractNavTreeService<any>, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AbstractNavTreeService<any>>;
}
declare class RoutesService extends AbstractNavTreeService<ABP.Route> {
    private hasPathOrChild;
    get groupedVisible(): RouteGroup<ABP.Route>[] | undefined;
    get groupedVisible$(): Observable<RouteGroup<ABP.Route>[] | undefined>;
    static ɵfac: i0.ɵɵFactoryDeclaration<RoutesService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<RoutesService>;
}

declare class SubscriptionService implements OnDestroy {
    private subscription;
    get isClosed(): boolean;
    addOne<T>(source$: Observable<T>, next?: (value: T) => void, error?: (error: any) => void): Subscription;
    addOne<T>(source$: Observable<T>, observer?: PartialObserver<T>): Subscription;
    closeAll(): void;
    closeOne(subscription: Subscription | undefined | null): void;
    ngOnDestroy(): void;
    removeOne(subscription: Subscription | undefined | null): void;
    reset(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<SubscriptionService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<SubscriptionService>;
}

declare class ConfigStateService {
    private abpConfigService;
    private abpApplicationLocalizationService;
    private readonly includeLocalizationResources;
    private updateSubject;
    private readonly store;
    uiCultureFromAuthCodeFlow: string;
    setState(config: ApplicationConfigurationDto): void;
    get createOnUpdateStream(): <Slice>(selector: (state: {
        localization?: {
            values?: {
                [x: string]: {
                    [x: string]: string;
                };
            };
            resources?: {
                [x: string]: {
                    texts?: {
                        [x: string]: string;
                    };
                    baseResources?: string[];
                };
            };
            languages?: _abp_ng_core.LanguageInfo[];
            currentCulture?: {
                displayName?: string;
                englishName?: string;
                threeLetterIsoLanguageName?: string;
                twoLetterIsoLanguageName?: string;
                isRightToLeft?: boolean;
                cultureName?: string;
                name?: string;
                nativeName?: string;
                dateTimeFormat?: {
                    calendarAlgorithmType?: string;
                    dateTimeFormatLong?: string;
                    shortDatePattern?: string;
                    fullDateTimePattern?: string;
                    dateSeparator?: string;
                    shortTimePattern?: string;
                    longTimePattern?: string;
                };
            };
            defaultResourceName?: string;
            languagesMap?: {
                [x: string]: _abp_ng_core.NameValue<string>[];
            };
            languageFilesMap?: {
                [x: string]: _abp_ng_core.NameValue<string>[];
            };
        };
        auth?: {
            grantedPolicies?: {
                [x: string]: boolean;
            };
        };
        setting?: {
            values?: {
                [x: string]: string;
            };
        };
        currentUser?: {
            isAuthenticated?: boolean;
            id?: string;
            tenantId?: string;
            impersonatorUserId?: string;
            impersonatorTenantId?: string;
            impersonatorUserName?: string;
            impersonatorTenantName?: string;
            userName?: string;
            name?: string;
            surName?: string;
            email?: string;
            emailVerified?: boolean;
            phoneNumber?: string;
            phoneNumberVerified?: boolean;
            roles?: string[];
        };
        features?: {
            values?: {
                [x: string]: string;
            };
        };
        globalFeatures?: {
            enabledFeatures?: string[];
        };
        multiTenancy?: {
            isEnabled?: boolean;
        };
        currentTenant?: {
            id?: string;
            name?: string;
            isAvailable?: boolean;
        };
        timing?: {
            timeZone?: {
                iana?: {
                    timeZoneName?: string;
                };
                windows?: {
                    timeZoneId?: string;
                };
            };
        };
        clock?: {
            kind?: string;
        };
        objectExtensions?: {
            modules?: {
                [x: string]: {
                    entities?: {
                        [x: string]: {
                            properties?: {
                                [x: string]: {
                                    type?: string;
                                    typeSimple?: string;
                                    displayName?: {
                                        name?: string;
                                        resource?: string;
                                    };
                                    api?: {
                                        onGet?: {
                                            isAvailable?: boolean;
                                        };
                                        onCreate?: {
                                            isAvailable?: boolean;
                                        };
                                        onUpdate?: {
                                            isAvailable?: boolean;
                                        };
                                    };
                                    ui?: {
                                        onTable?: {
                                            isVisible?: boolean;
                                        };
                                        onCreateForm?: {
                                            isVisible?: boolean;
                                        };
                                        onEditForm?: {
                                            isVisible?: boolean;
                                        };
                                        lookup?: {
                                            url?: string;
                                            resultListPropertyName?: string;
                                            displayPropertyName?: string;
                                            valuePropertyName?: string;
                                            filterParamName?: string;
                                        };
                                    };
                                    attributes?: _abp_ng_core.ExtensionPropertyAttributeDto[];
                                    configuration?: {
                                        [x: string]: object;
                                    };
                                    defaultValue?: object;
                                };
                            };
                            configuration?: {
                                [x: string]: object;
                            };
                        };
                    };
                    configuration?: {
                        [x: string]: object;
                    };
                };
            };
            enums?: {
                [x: string]: {
                    fields?: _abp_ng_core.ExtensionEnumFieldDto[];
                    localizationResource?: string;
                };
            };
        };
        extraProperties?: {
            [x: string]: object;
        };
    }) => Slice, filterFn?: (x: Slice) => boolean) => Observable<Slice>;
    constructor();
    private initUpdateStream;
    private getLocalizationAndCombineWithAppState;
    private getlocalizationResource;
    refreshAppState(): Observable<{
        localization?: {
            values?: {
                [x: string]: {
                    [x: string]: string;
                };
            };
            resources?: {
                [x: string]: {
                    texts?: {
                        [x: string]: string;
                    };
                    baseResources?: string[];
                };
            };
            languages?: _abp_ng_core.LanguageInfo[];
            currentCulture?: {
                displayName?: string;
                englishName?: string;
                threeLetterIsoLanguageName?: string;
                twoLetterIsoLanguageName?: string;
                isRightToLeft?: boolean;
                cultureName?: string;
                name?: string;
                nativeName?: string;
                dateTimeFormat?: {
                    calendarAlgorithmType?: string;
                    dateTimeFormatLong?: string;
                    shortDatePattern?: string;
                    fullDateTimePattern?: string;
                    dateSeparator?: string;
                    shortTimePattern?: string;
                    longTimePattern?: string;
                };
            };
            defaultResourceName?: string;
            languagesMap?: {
                [x: string]: _abp_ng_core.NameValue<string>[];
            };
            languageFilesMap?: {
                [x: string]: _abp_ng_core.NameValue<string>[];
            };
        };
        auth?: {
            grantedPolicies?: {
                [x: string]: boolean;
            };
        };
        setting?: {
            values?: {
                [x: string]: string;
            };
        };
        currentUser?: {
            isAuthenticated?: boolean;
            id?: string;
            tenantId?: string;
            impersonatorUserId?: string;
            impersonatorTenantId?: string;
            impersonatorUserName?: string;
            impersonatorTenantName?: string;
            userName?: string;
            name?: string;
            surName?: string;
            email?: string;
            emailVerified?: boolean;
            phoneNumber?: string;
            phoneNumberVerified?: boolean;
            roles?: string[];
        };
        features?: {
            values?: {
                [x: string]: string;
            };
        };
        globalFeatures?: {
            enabledFeatures?: string[];
        };
        multiTenancy?: {
            isEnabled?: boolean;
        };
        currentTenant?: {
            id?: string;
            name?: string;
            isAvailable?: boolean;
        };
        timing?: {
            timeZone?: {
                iana?: {
                    timeZoneName?: string;
                };
                windows?: {
                    timeZoneId?: string;
                };
            };
        };
        clock?: {
            kind?: string;
        };
        objectExtensions?: {
            modules?: {
                [x: string]: {
                    entities?: {
                        [x: string]: {
                            properties?: {
                                [x: string]: {
                                    type?: string;
                                    typeSimple?: string;
                                    displayName?: {
                                        name?: string;
                                        resource?: string;
                                    };
                                    api?: {
                                        onGet?: {
                                            isAvailable?: boolean;
                                        };
                                        onCreate?: {
                                            isAvailable?: boolean;
                                        };
                                        onUpdate?: {
                                            isAvailable?: boolean;
                                        };
                                    };
                                    ui?: {
                                        onTable?: {
                                            isVisible?: boolean;
                                        };
                                        onCreateForm?: {
                                            isVisible?: boolean;
                                        };
                                        onEditForm?: {
                                            isVisible?: boolean;
                                        };
                                        lookup?: {
                                            url?: string;
                                            resultListPropertyName?: string;
                                            displayPropertyName?: string;
                                            valuePropertyName?: string;
                                            filterParamName?: string;
                                        };
                                    };
                                    attributes?: _abp_ng_core.ExtensionPropertyAttributeDto[];
                                    configuration?: {
                                        [x: string]: object;
                                    };
                                    defaultValue?: object;
                                };
                            };
                            configuration?: {
                                [x: string]: object;
                            };
                        };
                    };
                    configuration?: {
                        [x: string]: object;
                    };
                };
            };
            enums?: {
                [x: string]: {
                    fields?: _abp_ng_core.ExtensionEnumFieldDto[];
                    localizationResource?: string;
                };
            };
        };
        extraProperties?: {
            [x: string]: object;
        };
    }>;
    refreshLocalization(lang: string): Observable<null>;
    getOne$<K extends keyof ApplicationConfigurationDto>(key: K): Observable<ApplicationConfigurationDto[K]>;
    getOne<K extends keyof ApplicationConfigurationDto>(key: K): ApplicationConfigurationDto[K];
    getAll$(): Observable<ApplicationConfigurationDto>;
    getAll(): ApplicationConfigurationDto;
    getDeep$(keys: string[] | string): Observable<any>;
    getDeep(keys: string[] | string): any;
    getFeature(key: string): string;
    getFeature$(key: string): Observable<string>;
    getFeatures(keys: string[]): {};
    getFeatures$(keys: string[]): Observable<{
        [key: string]: string;
    } | undefined>;
    private isFeatureEnabled;
    getFeatureIsEnabled(key: string): boolean;
    getFeatureIsEnabled$(key: string): Observable<boolean>;
    getSetting(key: string): string;
    getSetting$(key: string): Observable<string>;
    getSettings(keyword?: string): Record<string, string>;
    getSettings$(keyword?: string): Observable<Record<string, string>>;
    getGlobalFeatures(): ApplicationGlobalFeatureConfigurationDto;
    getGlobalFeatures$(): Observable<ApplicationGlobalFeatureConfigurationDto>;
    private isGlobalFeatureEnabled;
    getGlobalFeatureIsEnabled(key: string): boolean;
    getGlobalFeatureIsEnabled$(key: string): Observable<boolean>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ConfigStateService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ConfigStateService>;
}

declare abstract class ContextStrategy<T = any> {
    context: Partial<ContextType<T>>;
    constructor(context: Partial<ContextType<T>>);
    setContext(componentRef?: ComponentRef<InferredInstanceOf<T>>): Partial<ContextType<T>>;
}
declare class NoContextStrategy<T extends Type<any> | TemplateRef<any> = any> extends ContextStrategy<T> {
    constructor();
}
declare class ComponentContextStrategy<T extends Type<any> = any> extends ContextStrategy<T> {
    setContext(componentRef: ComponentRef<InferredInstanceOf<T>>): Partial<InferredInstanceOf<T>>;
}
declare class TemplateContextStrategy<T extends TemplateRef<any> = any> extends ContextStrategy<T> {
    setContext(): Partial<InferredContextOf<T>>;
}
declare const CONTEXT_STRATEGY: {
    None<T extends Type<any> | TemplateRef<any> = any>(): NoContextStrategy<T>;
    Component<T extends Type<any> = any>(context: Partial<InferredInstanceOf<T>>): ComponentContextStrategy<T>;
    Template<T extends TemplateRef<any> = any>(context: Partial<InferredContextOf<T>>): TemplateContextStrategy<T>;
};
type ContextType<T> = T extends Type<infer U> | TemplateRef<infer U> ? U : never;

declare abstract class ContainerStrategy {
    containerRef: ViewContainerRef;
    constructor(containerRef: ViewContainerRef);
    abstract getIndex(): number;
    prepare(): void;
}
declare class ClearContainerStrategy extends ContainerStrategy {
    getIndex(): number;
    prepare(): void;
}
declare class InsertIntoContainerStrategy extends ContainerStrategy {
    private index;
    constructor(containerRef: ViewContainerRef, index: number);
    getIndex(): number;
}
declare const CONTAINER_STRATEGY: {
    Clear(containerRef: ViewContainerRef): ClearContainerStrategy;
    Append(containerRef: ViewContainerRef): InsertIntoContainerStrategy;
    Prepend(containerRef: ViewContainerRef): InsertIntoContainerStrategy;
    Insert(containerRef: ViewContainerRef, index: number): InsertIntoContainerStrategy;
};

declare class DomStrategy {
    private getTarget;
    position: InsertPosition;
    constructor(getTarget: () => HTMLElement, position?: InsertPosition);
    insertElement<T extends HTMLElement>(element: T): void;
}
declare const DOM_STRATEGY: {
    AfterElement(element: HTMLElement): DomStrategy;
    AppendToBody(): DomStrategy;
    AppendToHead(): DomStrategy;
    BeforeElement(element: HTMLElement): DomStrategy;
    PrependToHead(): DomStrategy;
};

declare abstract class ProjectionStrategy<T = any> {
    content: T;
    constructor(content: T);
    abstract injectContent(injector: Injector): ComponentRefOrEmbeddedViewRef<T>;
}
declare class ComponentProjectionStrategy<T extends Type<any>> extends ProjectionStrategy<T> {
    private containerStrategy;
    private contextStrategy;
    constructor(component: T, containerStrategy: ContainerStrategy, contextStrategy?: ContextStrategy);
    injectContent(injector: Injector): ComponentRefOrEmbeddedViewRef<T>;
}
declare class RootComponentProjectionStrategy<T extends Type<any>> extends ProjectionStrategy<T> {
    private contextStrategy;
    private domStrategy;
    constructor(component: T, contextStrategy?: ContextStrategy, domStrategy?: DomStrategy);
    injectContent(injector: Injector): ComponentRefOrEmbeddedViewRef<T>;
}
declare class TemplateProjectionStrategy<T extends TemplateRef<any>> extends ProjectionStrategy<T> {
    private containerStrategy;
    private contextStrategy;
    constructor(templateRef: T, containerStrategy: ContainerStrategy, contextStrategy?: NoContextStrategy<any>);
    injectContent(): ComponentRefOrEmbeddedViewRef<T>;
}
declare const PROJECTION_STRATEGY: {
    AppendComponentToBody<T extends Type<unknown>>(component: T, context?: Partial<InferredInstanceOf<T>>): RootComponentProjectionStrategy<T>;
    AppendComponentToContainer<T extends Type<unknown>>(component: T, containerRef: ViewContainerRef, context?: Partial<InferredInstanceOf<T>>): ComponentProjectionStrategy<T>;
    AppendTemplateToContainer<T extends TemplateRef<unknown>>(templateRef: T, containerRef: ViewContainerRef, context?: Partial<InferredContextOf<T>>): TemplateProjectionStrategy<T>;
    PrependComponentToContainer<T extends Type<unknown>>(component: T, containerRef: ViewContainerRef, context?: Partial<InferredInstanceOf<T>>): ComponentProjectionStrategy<T>;
    PrependTemplateToContainer<T extends TemplateRef<unknown>>(templateRef: T, containerRef: ViewContainerRef, context?: Partial<InferredContextOf<T>>): TemplateProjectionStrategy<T>;
    ProjectComponentToContainer<T extends Type<unknown>>(component: T, containerRef: ViewContainerRef, context?: Partial<InferredInstanceOf<T>>): ComponentProjectionStrategy<T>;
    ProjectTemplateToContainer<T extends TemplateRef<unknown>>(templateRef: T, containerRef: ViewContainerRef, context?: Partial<InferredContextOf<T>>): TemplateProjectionStrategy<T>;
};
type ComponentRefOrEmbeddedViewRef<T> = T extends Type<infer U> ? ComponentRef<U> : T extends TemplateRef<infer C> ? EmbeddedViewRef<C> : never;

declare class ContentProjectionService {
    private injector;
    projectContent<T extends Type<any> | TemplateRef<any>>(projectionStrategy: ProjectionStrategy<T>, injector?: Injector): T extends Type<infer U> ? i0.ComponentRef<U> : T extends TemplateRef<infer C> ? i0.EmbeddedViewRef<C> : never;
    static ɵfac: i0.ɵɵFactoryDeclaration<ContentProjectionService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ContentProjectionService>;
}

declare abstract class ContentSecurityStrategy {
    nonce?: string;
    constructor(nonce?: string);
    abstract applyCSP(element: HTMLScriptElement | HTMLStyleElement): void;
}
declare class LooseContentSecurityStrategy extends ContentSecurityStrategy {
    constructor(nonce: string);
    applyCSP(element: HTMLScriptElement | HTMLStyleElement): void;
}
declare class NoContentSecurityStrategy extends ContentSecurityStrategy {
    constructor();
    applyCSP(_: HTMLScriptElement | HTMLStyleElement): void;
}
declare const CONTENT_SECURITY_STRATEGY: {
    Loose(nonce: string): LooseContentSecurityStrategy;
    None(): NoContentSecurityStrategy;
};

type ElementOptions<T extends HTMLScriptElement | HTMLStyleElement = any> = Partial<{
    [key in keyof T]: T[key];
}>;
declare abstract class ContentStrategy<T extends HTMLScriptElement | HTMLStyleElement = any> {
    content: string;
    protected domStrategy: DomStrategy;
    protected contentSecurityStrategy: ContentSecurityStrategy;
    protected options: ElementOptions<T>;
    constructor(content: string, domStrategy?: DomStrategy, contentSecurityStrategy?: ContentSecurityStrategy, options?: ElementOptions<T>);
    abstract createElement(): T;
    insertElement(): T;
}
declare class StyleContentStrategy extends ContentStrategy<HTMLStyleElement> {
    createElement(): HTMLStyleElement;
}
declare class ScriptContentStrategy extends ContentStrategy<HTMLScriptElement> {
    createElement(): HTMLScriptElement;
}
declare const CONTENT_STRATEGY: {
    AppendScriptToBody(content: string, options?: ElementOptions<HTMLScriptElement>): ScriptContentStrategy;
    AppendScriptToHead(content: string, options?: ElementOptions<HTMLScriptElement>): ScriptContentStrategy;
    AppendStyleToHead(content: string, options?: ElementOptions<HTMLStyleElement>): StyleContentStrategy;
    PrependStyleToHead(content: string, options?: ElementOptions<HTMLStyleElement>): StyleContentStrategy;
};

declare class DomInsertionService {
    private readonly inserted;
    insertContent<T extends HTMLScriptElement | HTMLStyleElement>(contentStrategy: ContentStrategy<T>): T | undefined;
    removeContent(element: HTMLScriptElement | HTMLStyleElement): void;
    has(content: string): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<DomInsertionService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<DomInsertionService>;
}

declare class EnvironmentService {
    private readonly store;
    get createOnUpdateStream(): <Slice>(selector: (state: {
        [x: string]: any;
        apis?: {
            [x: string]: {
                [x: string]: string;
                url?: string;
                rootNamespace?: string;
            };
            default?: {
                [x: string]: string;
                url?: string;
                rootNamespace?: string;
            };
        };
        application?: {
            name?: string;
            baseUrl?: string;
            logoUrl?: string;
        };
        hmr?: boolean;
        test?: boolean;
        localization?: {
            defaultResourceName?: string;
        };
        oAuthConfig?: {
            clientId?: string;
            redirectUri?: string;
            postLogoutRedirectUri?: string;
            redirectUriAsPostLogoutRedirectUriFallback?: boolean;
            loginUrl?: string;
            scope?: string;
            resource?: string;
            rngUrl?: string;
            oidc?: boolean;
            requestAccessToken?: boolean;
            options?: any;
            issuer?: string;
            logoutUrl?: string;
            clearHashAfterLogin?: boolean;
            tokenEndpoint?: string;
            revocationEndpoint?: string;
            customTokenParameters?: string[];
            userinfoEndpoint?: string;
            responseType?: string;
            showDebugInformation?: boolean;
            silentRefreshRedirectUri?: string;
            silentRefreshMessagePrefix?: string;
            silentRefreshShowIFrame?: boolean;
            siletRefreshTimeout?: number;
            silentRefreshTimeout?: number;
            dummyClientSecret?: string;
            requireHttps?: boolean | "remoteOnly";
            strictDiscoveryDocumentValidation?: boolean;
            jwks?: object;
            customQueryParams?: object;
            silentRefreshIFrameName?: string;
            timeoutFactor?: number;
            sessionChecksEnabled?: boolean;
            sessionCheckIntervall?: number;
            sessionCheckIFrameUrl?: string;
            sessionCheckIFrameName?: string;
            disableAtHashCheck?: boolean;
            skipSubjectCheck?: boolean;
            useIdTokenHintForSilentRefresh?: boolean;
            skipIssuerCheck?: boolean;
            fallbackAccessTokenExpirationTimeInSec?: number;
            nonceStateSeparator?: string;
            useHttpBasicAuth?: boolean;
            clockSkewInSec?: number;
            decreaseExpirationBySec?: number;
            waitForTokenInMsec?: number;
            useSilentRefresh?: any;
            disablePKCE?: boolean;
            preserveRequestedRoute?: boolean;
            disableIdTokenTimer?: boolean;
            checkOrigin?: boolean;
            openUri?: (uri: string) => void;
            impersonation?: {
                tenantImpersonation?: boolean;
                userImpersonation?: boolean;
            };
            ssrAuthorizationUrl?: string;
        };
        production?: boolean;
        remoteEnv?: {
            url?: string;
            mergeStrategy?: "deepmerge" | "overwrite" | customMergeFn;
            method?: string;
            headers?: {
                [x: string]: string;
            };
        };
    }) => Slice, filterFn?: (x: Slice) => boolean) => Observable<Slice>;
    getEnvironment$(): Observable<Environment>;
    getEnvironment(): Environment;
    getApiUrl(key: string | undefined): string;
    getApiUrl$(key: string): Observable<string>;
    setState(environment: Environment): void;
    getIssuer(): string;
    getIssuer$(): Observable<string>;
    getImpersonation(): Impersonation;
    getImpersonation$(): Observable<Impersonation>;
    static ɵfac: i0.ɵɵFactoryDeclaration<EnvironmentService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<EnvironmentService>;
}

declare class HtmlEncodingService {
    encode(value: string): string;
    decode(value: string): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<HtmlEncodingService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<HtmlEncodingService>;
}

declare class HttpErrorReporterService {
    private _reporter$;
    private _errors$;
    get reporter$(): rxjs.Observable<HttpErrorResponse>;
    get errors$(): rxjs.Observable<HttpErrorResponse[]>;
    get errors(): HttpErrorResponse[];
    reportError(error: HttpErrorResponse): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<HttpErrorReporterService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<HttpErrorReporterService>;
}

declare class InternalStore<State> {
    private initialState;
    private state$;
    private update$;
    get state(): State;
    sliceState: <Slice>(selector: (state: State) => Slice, compareFn?: (s1: Slice, s2: Slice) => boolean) => rxjs.Observable<Slice>;
    sliceUpdate: <Slice>(selector: (state: DeepPartial<State>) => Slice, filterFn?: (x: Slice) => boolean) => rxjs.Observable<Slice>;
    constructor(initialState: State);
    patch(state: Partial<State>): void;
    deepPatch(state: DeepPartial<State>): void;
    set(state: State): void;
    reset(): void;
}

interface HttpWaitState {
    requests: HttpRequest<any>[];
    filteredRequests: Array<HttpRequestInfo>;
}
interface HttpRequestInfo {
    method: string;
    endpoint: string;
}
declare class HttpWaitService {
    protected store: InternalStore<HttpWaitState>;
    private delay;
    private destroy$;
    constructor();
    getLoading(): boolean;
    getLoading$(): rxjs.Observable<boolean>;
    updateLoading$(): rxjs.Observable<boolean>;
    clearLoading(): void;
    addRequest(request: HttpRequest<any>): void;
    deleteRequest(request: HttpRequest<any>): void;
    addFilter(request: HttpRequestInfo | HttpRequestInfo[]): void;
    removeFilter(request: HttpRequestInfo | HttpRequestInfo[]): void;
    private applyFilter;
    private isSameRequest;
    static ɵfac: i0.ɵɵFactoryDeclaration<HttpWaitService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<HttpWaitService>;
}

declare class CrossOriginStrategy {
    crossorigin: 'anonymous' | 'use-credentials' | null;
    integrity?: string;
    constructor(crossorigin: 'anonymous' | 'use-credentials' | null, integrity?: string);
    setCrossOrigin<T extends HTMLElement>(element: T): void;
}
declare class NoCrossOriginStrategy extends CrossOriginStrategy {
    setCrossOrigin(): void;
}
declare const CROSS_ORIGIN_STRATEGY: {
    Anonymous(integrity?: string): CrossOriginStrategy;
    UseCredentials(integrity?: string): CrossOriginStrategy;
    None(): NoCrossOriginStrategy;
};

declare abstract class LoadingStrategy<T extends HTMLScriptElement | HTMLLinkElement = any> {
    path: string;
    protected domStrategy: DomStrategy;
    protected crossOriginStrategy: CrossOriginStrategy;
    element: T;
    constructor(path: string, domStrategy?: DomStrategy, crossOriginStrategy?: CrossOriginStrategy);
    abstract createElement(): T;
    createStream<E extends Event>(): Observable<E>;
}
declare class ScriptLoadingStrategy extends LoadingStrategy<HTMLScriptElement> {
    constructor(src: string, domStrategy?: DomStrategy, crossOriginStrategy?: CrossOriginStrategy);
    createElement(): HTMLScriptElement;
}
declare class StyleLoadingStrategy extends LoadingStrategy<HTMLLinkElement> {
    constructor(href: string, domStrategy?: DomStrategy, crossOriginStrategy?: CrossOriginStrategy);
    createElement(): HTMLLinkElement;
}
declare const LOADING_STRATEGY: {
    AppendScriptToBody(src: string): ScriptLoadingStrategy;
    AppendAnonymousScriptToBody(src: string, integrity?: string): ScriptLoadingStrategy;
    AppendAnonymousScriptToHead(src: string, integrity?: string): ScriptLoadingStrategy;
    AppendAnonymousStyleToHead(src: string, integrity?: string): StyleLoadingStrategy;
    PrependAnonymousScriptToHead(src: string, integrity?: string): ScriptLoadingStrategy;
    PrependAnonymousStyleToHead(src: string, integrity?: string): StyleLoadingStrategy;
};

declare class LazyLoadService {
    private resourceWaitService;
    readonly loaded: Map<string, HTMLScriptElement | HTMLLinkElement>;
    load(strategy: LoadingStrategy, retryTimes?: number, retryDelay?: number): Observable<Event>;
    remove(path: string): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<LazyLoadService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<LazyLoadService>;
}

type RequestStatus = 'idle' | 'loading' | 'success' | 'error';
declare class ListService<QueryParamsType = ABP.PageQueryParams | any> implements OnDestroy {
    private _filter;
    set filter(value: string);
    get filter(): string;
    private _maxResultCount;
    set maxResultCount(value: number);
    get maxResultCount(): number;
    private _page;
    set page(value: number);
    get page(): number;
    private _totalCount;
    set totalCount(value: number);
    get totalCount(): number;
    private _sortKey;
    set sortKey(value: string | number);
    get sortKey(): string | number;
    private _sortOrder;
    set sortOrder(value: string);
    get sortOrder(): string;
    private _query$;
    get query$(): Observable<QueryParamsType>;
    private _isLoading$;
    private _requestStatus;
    private destroy$;
    private delay;
    /**
     * @deprecated Use `requestStatus$` instead.
     */
    get isLoading$(): Observable<boolean>;
    get requestStatus$(): Observable<RequestStatus>;
    get: () => void;
    getWithoutPageReset: () => void;
    constructor();
    hookToQuery<T>(streamCreatorCallback: QueryStreamCreatorCallback<T, QueryParamsType>): Observable<PagedResultDto<T>>;
    ngOnDestroy(): void;
    private resetPageWhenUnchanged;
    private next;
    static ɵfac: i0.ɵɵFactoryDeclaration<ListService<any>, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ListService<any>>;
}
type QueryStreamCreatorCallback<T, QueryParamsType = ABP.PageQueryParams> = (query: QueryParamsType) => Observable<PagedResultDto<T>>;

declare class MultiTenancyService {
    private sessionState;
    private tenantService;
    private configStateService;
    tenantKey: string;
    domainTenant: CurrentTenantDto | null;
    isTenantBoxVisible: boolean;
    apiName: string;
    private setTenantToState;
    setTenantByName(tenantName: string): rxjs.Observable<FindTenantResultDto>;
    setTenantById(tenantId: string): rxjs.Observable<FindTenantResultDto>;
    static ɵfac: i0.ɵɵFactoryDeclaration<MultiTenancyService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<MultiTenancyService>;
}

declare class PermissionService {
    protected configState: ConfigStateService;
    getGrantedPolicy$(key: string): rxjs.Observable<boolean>;
    getGrantedPolicy(key: string | undefined): boolean;
    filterItemsByPolicy<T extends ABP.HasPolicy>(items: Array<T>): T[];
    filterItemsByPolicy$<T extends ABP.HasPolicy>(items: Array<T>): rxjs.Observable<T[]>;
    protected isPolicyGranted(key: string | undefined, grantedPolicies: Record<string, boolean>): boolean;
    protected getStream(): rxjs.Observable<Record<string, boolean>>;
    protected getSnapshot(): Record<string, boolean>;
    protected mapToPolicies(applicationConfiguration: ApplicationConfigurationDto): Record<string, boolean>;
    protected getPolicy(key: string, grantedPolicies: Record<string, boolean>): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<PermissionService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<PermissionService>;
}

interface ResourceWaitState {
    resources: Set<string>;
}
declare class ResourceWaitService {
    private store;
    getLoading(): boolean;
    getLoading$(): rxjs.Observable<boolean>;
    updateLoading$(): rxjs.Observable<boolean>;
    clearLoading(): void;
    addResource(resource: string): void;
    deleteResource(resource: string): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ResourceWaitService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ResourceWaitService>;
}

declare class ExternalHttpClient extends HttpClient {
    #private;
    request(first: string | HttpRequest<any>, url?: string, options?: RequestOptions): Observable<any>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ExternalHttpClient, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ExternalHttpClient>;
}
type RequestOptions = Parameters<HttpClient['request']>[2];

declare class RestService {
    protected options: ABP.Root;
    protected http: HttpClient;
    protected externalHttp: ExternalHttpClient;
    protected environment: EnvironmentService;
    protected httpErrorReporter: HttpErrorReporterService;
    protected getApiFromStore(apiName: string | undefined): string;
    handleError(err: any): Observable<any>;
    request<T, R>(request: HttpRequest<T> | Rest.Request<T>, config?: Rest.Config, api?: string): Observable<R>;
    private getHttpClient;
    private getParams;
    private removeDuplicateSlashes;
    static ɵfac: i0.ɵɵFactoryDeclaration<RestService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<RestService>;
}

interface RouterWaitState {
    loading: boolean;
}
declare class RouterWaitService {
    private routerEvents;
    private store;
    private destroy$;
    private delay;
    constructor();
    private updateLoadingStatusOnNavigationEvents;
    getLoading(): boolean;
    getLoading$(): rxjs.Observable<boolean>;
    updateLoading$(): rxjs.Observable<boolean>;
    setLoading(loading: boolean): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<RouterWaitService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<RouterWaitService>;
}

declare class SessionStateService {
    private configState;
    private localStorageService;
    private appStartedWithSSR;
    private cookieStorageService;
    private readonly store;
    protected readonly document: Document;
    private updateLocalStorage;
    constructor();
    private init;
    private setInitialLanguage;
    onLanguageChange$(): rxjs.Observable<string>;
    onTenantChange$(): rxjs.Observable<{
        id?: string;
        name?: string;
        isAvailable?: boolean;
    }>;
    getLanguage(): string;
    getLanguage$(): rxjs.Observable<string>;
    getTenant(): CurrentTenantDto;
    getTenant$(): rxjs.Observable<CurrentTenantDto>;
    setTenant(tenant: CurrentTenantDto | null): void;
    setLanguage(language: string): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<SessionStateService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<SessionStateService>;
}

declare const trackBy: <T = any>(key: keyof T) => TrackByFunction<T>;
declare const trackByDeep: <T = any>(...keys: T extends object ? O$1.Paths<T> : never) => TrackByFunction<T>;
declare class TrackByService<ItemType = any> {
    by: <T = any>(key: keyof T) => TrackByFunction<T>;
    byDeep: <T = any>(...keys: T extends object ? O$1.Paths<T> : never) => TrackByFunction<T>;
    static ɵfac: i0.ɵɵFactoryDeclaration<TrackByService<any>, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TrackByService<any>>;
}

declare class AbpLocalStorageService implements Storage {
    private platformId;
    constructor();
    [name: string]: any;
    get length(): number;
    clear(): void;
    getItem(key: string): string | null;
    key(index: number): string | null;
    removeItem(key: string): void;
    setItem(key: string, value: string): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbpLocalStorageService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AbpLocalStorageService>;
}

declare class AbpWindowService {
    readonly document: Document;
    readonly window: Window & typeof globalThis;
    readonly navigator: Navigator;
    copyToClipboard(text: string): Promise<void>;
    open(url?: string | URL, target?: string, features?: string): Window;
    reloadPage(): void;
    downloadBlob(blob: Blob, fileName: string): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbpWindowService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AbpWindowService>;
}

declare class InternetConnectionService {
    readonly document: Document;
    readonly window: Window & typeof globalThis;
    readonly navigator: Navigator;
    private status$;
    private status;
    networkStatus: i0.Signal<boolean>;
    constructor();
    setStatus(val: boolean): void;
    get networkStatus$(): rxjs.Observable<boolean>;
    static ɵfac: i0.ɵɵFactoryDeclaration<InternetConnectionService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<InternetConnectionService>;
}

declare class LocalStorageListenerService {
    protected readonly window: Window & typeof globalThis;
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<LocalStorageListenerService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<LocalStorageListenerService>;
}

declare class AbpTitleStrategy extends TitleStrategy {
    protected readonly title: Title;
    protected readonly localizationService: LocalizationService;
    protected readonly disableProjectName: boolean;
    protected routerState: RouterStateSnapshot;
    langugageChange: i0.Signal<string>;
    constructor();
    updateTitle(routerState: RouterStateSnapshot): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbpTitleStrategy, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AbpTitleStrategy>;
}

declare class TimezoneService {
    protected readonly configState: ConfigStateService;
    protected readonly document: Document;
    private readonly cookieKey;
    private timeZoneNameFromSettings;
    isUtcClockEnabled: boolean | undefined;
    constructor();
    /**
     * Returns the effective timezone to be used across the application.
     *
     * This value is determined based on the clock kind setting in the configuration:
     * - If clock kind is not equal to Utc, the browser's local timezone is returned.
     * - If clock kind is equal to Utc, the configured timezone (`timeZoneNameFromSettings`) is returned if available;
     *   otherwise, the browser's timezone is used as a fallback.
     *
     * @returns The IANA timezone name (e.g., 'Europe/Istanbul', 'America/New_York').
     */
    get timezone(): string;
    /**
     * Retrieves the browser's local timezone based on the user's system settings.
     *
     * @returns The IANA timezone name (e.g., 'Europe/Istanbul', 'America/New_York').
     */
    getBrowserTimezone(): string;
    /**
     * Sets the application's timezone in a cookie to persist the user's selected timezone.
     *
     * This method sets the cookie only if the clock kind setting is set to UTC.
     * The cookie is stored using the key defined by `this.cookieKey` and applied to the root path (`/`).
     *
     * @param timezone - The IANA timezone name to be stored (e.g., 'Europe/Istanbul').
     */
    setTimezone(timezone: string): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TimezoneService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TimezoneService>;
}

declare class TimeService {
    private locale;
    /**
     * Returns the current date and time in the specified timezone.
     *
     * @param zone - An IANA timezone name (e.g., 'Europe/Istanbul', 'UTC'); defaults to the system's local timezone.
     * @returns A Luxon DateTime instance representing the current time in the given timezone.
     */
    now(zone?: string): DateTime;
    /**
     * Converts the input date to the specified timezone, applying any timezone and daylight saving time (DST) adjustments.
     *
     * This method:
     * 1. Parses the input value into a Luxon DateTime object.
     * 2. Applies the specified IANA timezone, including any DST shifts based on the given date.
     *
     * @param value - The ISO string or Date object to convert.
     * @param zone - An IANA timezone name (e.g., 'America/New_York').
     * @returns A Luxon DateTime instance adjusted to the specified timezone and DST rules.
     */
    toZone(value: string | Date, zone: string): DateTime;
    /**
     * Formats the input date by applying timezone and daylight saving time (DST) adjustments.
     *
     * This method:
     * 1. Converts the input date to the specified timezone.
     * 2. Formats the result using the given format and locale, reflecting any timezone or DST shifts.
     *
     * @param value - The ISO string or Date object to format.
     * @param format - The format string (default: 'ff').
     * @param zone - Optional IANA timezone name (e.g., 'America/New_York'); defaults to the system's local timezone.
     * @returns A formatted date string adjusted for the given timezone and DST rules.
     */
    format(value: string | Date, format?: string, zone?: string): string;
    /**
     * Formats a date using the standard time offset (ignoring daylight saving time) for the specified timezone.
     *
     * This method:
     * 1. Converts the input date to UTC.
     * 2. Calculates the standard UTC offset for the given timezone (based on January 1st to avoid DST).
     * 3. Applies the standard offset manually to the UTC time.
     * 4. Formats the result using the specified format and locale, without applying additional timezone shifts.
     *
     * @param value - The ISO string or Date object to format.
     * @param format - The Luxon format string (default: 'ff').
     * @param zone - Optional IANA timezone name (e.g., 'America/New_York'); if omitted, system local timezone is used.
     * @returns A formatted date string adjusted by standard time (non-DST).
     */
    formatDateWithStandardOffset(value: string | Date, format?: string, zone?: string): string;
    /**
     * Formats the input date using its original clock time, without converting based on timezone or DST
     *
     * This method:
     * 1. Converts the input date to ISO string.
     * 2. Calculates the date time in UTC, keeping the local time.
     * 3. Formats the result using the specified format and locale, without shifting timezones.
     *
     * @param value - The ISO string or Date object to format.
     * @param format - The format string (default: 'ff').
     * @returns A formatted date string without applying timezone.
     */
    formatWithoutTimeZone(value: string | Date, format?: string): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<TimeService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TimeService>;
}

declare class AbpCookieStorageService implements Storage {
    private platformId;
    private document;
    private request;
    get length(): number;
    clear(): void;
    getItem(key: string): string | null;
    key(index: number): string | null;
    removeItem(key: string): void;
    setItem(key: string, value: string): void;
    setItemWithExpiry(key: string, value: string, seconds: number): void;
    private keys;
    private setCookie;
    private getCookiesFromRequest;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbpCookieStorageService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AbpCookieStorageService>;
}

declare class DomStrategyService {
    private document;
    afterElement(el: HTMLElement): DomStrategy;
    beforeElement(el: HTMLElement): DomStrategy;
    appendToBody(): DomStrategy;
    appendToHead(): DomStrategy;
    prependToHead(): DomStrategy;
    static ɵfac: i0.ɵɵFactoryDeclaration<DomStrategyService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<DomStrategyService>;
}

declare class DynamicLayoutComponent {
    layout?: Type<any>;
    layoutKey?: eLayoutType;
    readonly layouts: Map<string, string>;
    isLayoutVisible: boolean;
    readonly defaultLayout: i0.InputSignal<eLayoutType>;
    protected readonly router: Router;
    protected readonly route: ActivatedRoute;
    protected readonly routes: RoutesService;
    protected readonly localizationService: LocalizationService;
    protected readonly replaceableComponents: ReplaceableComponentsService;
    protected readonly subscription: SubscriptionService;
    protected readonly routerEvents: RouterEvents;
    protected readonly environment: EnvironmentService;
    constructor();
    private checkLayoutOnNavigationEnd;
    private getLayout;
    private getExtractedLayout;
    showLayoutNotFoundError(layoutName: string): void;
    private listenToLanguageChange;
    private getComponent;
    private listenToEnvironmentChange;
    static ɵfac: i0.ɵɵFactoryDeclaration<DynamicLayoutComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DynamicLayoutComponent, "abp-dynamic-layout", never, { "defaultLayout": { "alias": "defaultLayout"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

declare class ReplaceableRouteContainerComponent implements OnInit {
    private route;
    private replaceableComponents;
    private subscription;
    defaultComponent: Type<any>;
    componentKey: string;
    externalComponent?: Type<any>;
    ngOnInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ReplaceableRouteContainerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ReplaceableRouteContainerComponent, "abp-replaceable-route-container", never, {}, {}, never, never, true, never>;
}

declare class RouterOutletComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<RouterOutletComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<RouterOutletComponent, "abp-router-outlet", never, {}, {}, never, never, true, never>;
}

declare const differentLocales: {
    aa: string;
    'aa-DJ': string;
    'aa-ER': string;
    'aa-ET': string;
    'af-ZA': string;
    'agq-CM': string;
    'ak-GH': string;
    'am-ET': string;
    'ar-001': string;
    arn: string;
    'arn-CL': string;
    'as-IN': string;
    'asa-TZ': string;
    'ast-ES': string;
    'az-Cyrl-AZ': string;
    'az-Latn-AZ': string;
    ba: string;
    'ba-RU': string;
    'bas-CM': string;
    'be-BY': string;
    'bem-ZM': string;
    'bez-TZ': string;
    'bg-BG': string;
    bin: string;
    'bin-NG': string;
    'bm-Latn': string;
    'bm-Latn-ML': string;
    'bn-BD': string;
    'bo-CN': string;
    'br-FR': string;
    'brx-IN': string;
    'bs-Cyrl-BA': string;
    'bs-Latn-BA': string;
    byn: string;
    'byn-ER': string;
    'ca-ES': string;
    'ca-ES-valencia': string;
    'ce-RU': string;
    'cgg-UG': string;
    'chr-Cher': string;
    'chr-Cher-US': string;
    co: string;
    'co-FR': string;
    'cs-CZ': string;
    'cu-RU': string;
    'cy-GB': string;
    'da-DK': string;
    'dav-KE': string;
    'de-DE': string;
    'dje-NE': string;
    'dsb-DE': string;
    'dua-CM': string;
    dv: string;
    'dv-MV': string;
    'dyo-SN': string;
    'dz-BT': string;
    'ebu-KE': string;
    'ee-GH': string;
    'el-GR': string;
    'en-029': string;
    'en-ID': string;
    'en-US': string;
    'eo-001': string;
    'es-ES': string;
    'et-EE': string;
    'eu-ES': string;
    'ewo-CM': string;
    'fa-IR': string;
    'ff-Latn-SN': string;
    'ff-NG': string;
    'fi-FI': string;
    'fil-PH': string;
    'fo-FO': string;
    'fr-029': string;
    'fr-FR': string;
    'fur-IT': string;
    'fy-NL': string;
    'ga-IE': string;
    'gd-GB': string;
    'gl-ES': string;
    gn: string;
    'gn-PY': string;
    'gsw-CH': string;
    'gu-IN': string;
    'guz-KE': string;
    'gv-IM': string;
    'ha-Latn': string;
    'ha-Latn-GH': string;
    'ha-Latn-NE': string;
    'ha-Latn-NG': string;
    'haw-US': string;
    'he-IL': string;
    'hi-IN': string;
    'hr-HR': string;
    'hsb-DE': string;
    'hu-HU': string;
    'hy-AM': string;
    'ia-001': string;
    'ia-FR': string;
    ibb: string;
    'ibb-NG': string;
    'id-ID': string;
    'ig-NG': string;
    'ii-CN': string;
    'is-IS': string;
    'it-IT': string;
    iu: string;
    'iu-Cans': string;
    'iu-Cans-CA': string;
    'iu-Latn': string;
    'iu-Latn-CA': string;
    'ja-JP': string;
    'jgo-CM': string;
    'jmc-TZ': string;
    'jv-Java': string;
    'jv-Java-ID': string;
    'jv-Latn': string;
    'jv-Latn-ID': string;
    'ka-GE': string;
    'kab-DZ': string;
    'kam-KE': string;
    'kde-TZ': string;
    'kea-CV': string;
    'khq-ML': string;
    'ki-KE': string;
    'kk-KZ': string;
    'kkj-CM': string;
    'kl-GL': string;
    'kln-KE': string;
    'km-KH': string;
    'kn-IN': string;
    'ko-KR': string;
    'kok-IN': string;
    kr: string;
    'kr-NG': string;
    'ks-Arab': string;
    'ks-Arab-IN': string;
    'ks-Deva': string;
    'ks-Deva-IN': string;
    'ksb-TZ': string;
    'ksf-CM': string;
    'ksh-DE': string;
    'ku-Arab': string;
    'ku-Arab-IQ': string;
    'ku-Arab-IR': string;
    'kw-GB': string;
    'ky-KG': string;
    la: string;
    'la-001': string;
    'lag-TZ': string;
    'lb-LU': string;
    'lg-UG': string;
    'lkt-US': string;
    'ln-CD': string;
    'lo-LA': string;
    'lrc-IR': string;
    'lt-LT': string;
    'lu-CD': string;
    'luo-KE': string;
    'luy-KE': string;
    'lv-LV': string;
    'mas-KE': string;
    'mer-KE': string;
    'mfe-MU': string;
    'mg-MG': string;
    'mgh-MZ': string;
    'mgo-CM': string;
    'mi-NZ': string;
    'mk-MK': string;
    'ml-IN': string;
    'mn-Cyrl': string;
    'mn-MN': string;
    'mn-Mong': string;
    'mn-Mong-CN': string;
    'mn-Mong-MN': string;
    mni: string;
    'mni-IN': string;
    moh: string;
    'moh-CA': string;
    'mr-IN': string;
    'ms-MY': string;
    'mt-MT': string;
    'mua-CM': string;
    'my-MM': string;
    'mzn-IR': string;
    'naq-NA': string;
    'nb-NO': string;
    'nd-ZW': string;
    'ne-NP': string;
    'nl-NL': string;
    'nmg-CM': string;
    'nn-NO': string;
    'nnh-CM': string;
    no: string;
    nqo: string;
    'nqo-GN': string;
    nr: string;
    'nr-ZA': string;
    nso: string;
    'nso-ZA': string;
    'nus-SS': string;
    'nyn-UG': string;
    oc: string;
    'oc-FR': string;
    'om-ET': string;
    'or-IN': string;
    'os-GE': string;
    'pa-Arab-PK': string;
    'pa-IN': string;
    pap: string;
    'pap-029': string;
    'pl-PL': string;
    'prg-001': string;
    prs: string;
    'prs-AF': string;
    'ps-AF': string;
    'pt-BR': string;
    quc: string;
    'quc-Latn': string;
    'quc-Latn-GT': string;
    quz: string;
    'quz-BO': string;
    'quz-EC': string;
    'quz-PE': string;
    'rm-CH': string;
    'rn-BI': string;
    'ro-RO': string;
    'rof-TZ': string;
    'ru-RU': string;
    'rw-RW': string;
    'rwk-TZ': string;
    sa: string;
    'sa-IN': string;
    'sah-RU': string;
    'saq-KE': string;
    'sbp-TZ': string;
    'sd-Arab': string;
    'sd-Arab-PK': string;
    'sd-Deva': string;
    'sd-Deva-IN': string;
    'se-NO': string;
    'seh-MZ': string;
    'ses-ML': string;
    'sg-CF': string;
    'shi-Latn-MA': string;
    'shi-Tfng-MA': string;
    'si-LK': string;
    'sk-SK': string;
    'sl-SI': string;
    sma: string;
    'sma-NO': string;
    'sma-SE': string;
    smj: string;
    'smj-NO': string;
    'smj-SE': string;
    'smn-FI': string;
    sms: string;
    'sms-FI': string;
    'sn-Latn': string;
    'sn-Latn-ZW': string;
    'so-SO': string;
    'sq-AL': string;
    'sr-Cyrl-RS': string;
    'sr-Latn-RS': string;
    ss: string;
    'ss-SZ': string;
    'ss-ZA': string;
    ssy: string;
    'ssy-ER': string;
    st: string;
    'st-LS': string;
    'st-ZA': string;
    'sv-SE': string;
    'sw-TZ': string;
    syr: string;
    'syr-SY': string;
    'ta-IN': string;
    'te-IN': string;
    'teo-UG': string;
    'tg-Cyrl': string;
    'tg-Cyrl-TJ': string;
    'th-TH': string;
    'ti-ET': string;
    tig: string;
    'tig-ER': string;
    'tk-TM': string;
    tn: string;
    'tn-BW': string;
    'tn-ZA': string;
    'to-TO': string;
    'tr-TR': string;
    ts: string;
    'ts-ZA': string;
    'tt-RU': string;
    'twq-NE': string;
    'tzm-Arab': string;
    'tzm-Arab-MA': string;
    'tzm-Latn': string;
    'tzm-Latn-DZ': string;
    'tzm-Latn-MA': string;
    'tzm-Tfng': string;
    'tzm-Tfng-MA': string;
    'ug-CN': string;
    'uk-UA': string;
    'ur-PK': string;
    'uz-Arab-AF': string;
    'uz-Cyrl-UZ': string;
    'uz-Latn-UZ': string;
    'vai-Latn-LR': string;
    'vai-Vaii-LR': string;
    ve: string;
    've-ZA': string;
    'vi-VN': string;
    'vo-001': string;
    'vun-TZ': string;
    'wae-CH': string;
    wal: string;
    'wal-ET': string;
    'wo-SN': string;
    'xh-ZA': string;
    'xog-UG': string;
    'yav-CM': string;
    'yi-001': string;
    'yo-NG': string;
    'zgh-Tfng': string;
    'zgh-Tfng-MA': string;
    'zh-CN': string;
    'zh-HK': string;
    'zh-MO': string;
    'zh-SG': string;
    'zh-TW': string;
    'zu-ZA': string;
};

declare const DEFAULT_DYNAMIC_LAYOUTS: Map<string, string>;

declare global {
    interface Date {
        toLocalISOString?: () => string;
    }
}

declare class AutofocusDirective implements AfterViewInit {
    private elRef;
    private _delay;
    set delay(val: number | string | undefined);
    get delay(): number | string | undefined;
    ngAfterViewInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AutofocusDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<AutofocusDirective, "[autofocus]", never, { "delay": { "alias": "autofocus"; "required": false; }; }, {}, never, never, true, never>;
}

declare class InputEventDebounceDirective implements OnInit {
    private el;
    private subscription;
    debounce: number;
    readonly debounceEvent: EventEmitter<Event>;
    ngOnInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<InputEventDebounceDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<InputEventDebounceDirective, "[input.debounce]", never, { "debounce": { "alias": "debounce"; "required": false; }; }, { "debounceEvent": "input.debounce"; }, never, never, true, never>;
}

type CompareFn<T = any> = (value: T, comparison: T) => boolean;
declare class ForDirective implements OnChanges {
    private tempRef;
    private vcRef;
    private differs;
    items: any[];
    orderBy?: string;
    orderDir?: 'ASC' | 'DESC';
    filterBy?: string;
    filterVal: any;
    trackBy?: TrackByFunction<any>;
    compareBy?: CompareFn;
    emptyRef?: TemplateRef<any>;
    private differ;
    private isShowEmptyRef;
    get compareFn(): CompareFn;
    get trackByFn(): TrackByFunction<any>;
    private iterateOverAppliedOperations;
    private iterateOverAttachedViews;
    private projectItems;
    private sortItems;
    ngOnChanges(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ForDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ForDirective, "[abpFor]", never, { "items": { "alias": "abpForOf"; "required": false; }; "orderBy": { "alias": "abpForOrderBy"; "required": false; }; "orderDir": { "alias": "abpForOrderDir"; "required": false; }; "filterBy": { "alias": "abpForFilterBy"; "required": false; }; "filterVal": { "alias": "abpForFilterVal"; "required": false; }; "trackBy": { "alias": "abpForTrackBy"; "required": false; }; "compareBy": { "alias": "abpForCompareBy"; "required": false; }; "emptyRef": { "alias": "abpForEmptyRef"; "required": false; }; }, {}, never, never, true, never>;
}

/**
 * @deprecated FormSubmitDirective will be removed in V7.0.0. Use `ngSubmit` instead.
 */
declare class FormSubmitDirective implements OnInit {
    private formGroupDirective;
    private host;
    private cdRef;
    private subscription;
    debounce: number;
    notValidateOnSubmit?: string | boolean;
    markAsDirtyWhenSubmit: boolean;
    readonly ngSubmit: EventEmitter<any>;
    executedNgSubmit: boolean;
    ngOnInit(): void;
    markAsDirty(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<FormSubmitDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<FormSubmitDirective, "form[ngSubmit][formGroup]", never, { "debounce": { "alias": "debounce"; "required": false; }; "notValidateOnSubmit": { "alias": "notValidateOnSubmit"; "required": false; }; "markAsDirtyWhenSubmit": { "alias": "markAsDirtyWhenSubmit"; "required": false; }; }, { "ngSubmit": "ngSubmit"; }, never, never, true, never>;
}

declare class InitDirective implements AfterViewInit {
    private elRef;
    readonly init: EventEmitter<ElementRef<any>>;
    ngAfterViewInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<InitDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<InitDirective, "[abpInit]", never, {}, { "init": "abpInit"; }, never, never, true, never>;
}

interface QueueManager {
    add(fn: () => void): void;
    init(interval: number, stackSize: number): void;
}
declare class DefaultQueueManager implements QueueManager {
    private queue;
    private isRunning;
    private stack;
    private interval;
    private stackSize;
    init(interval: number, stackSize: number): void;
    add(fn: () => void): void;
    private run;
}

declare class PermissionDirective implements OnDestroy, OnChanges, AfterViewInit {
    private templateRef;
    private vcRef;
    private permissionService;
    private cdRef;
    queue: QueueManager;
    condition: string | undefined;
    runChangeDetection: boolean;
    subscription: Subscription;
    cdrSubject: ReplaySubject<void>;
    rendered: boolean;
    private check;
    ngOnDestroy(): void;
    ngOnChanges(): void;
    ngAfterViewInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<PermissionDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<PermissionDirective, "[abpPermission]", never, { "condition": { "alias": "abpPermission"; "required": false; }; "runChangeDetection": { "alias": "abpPermissionRunChangeDetection"; "required": false; }; }, {}, never, never, true, never>;
}

declare class ReplaceableTemplateDirective implements OnInit, OnChanges {
    private injector;
    private templateRef;
    private vcRef;
    private replaceableComponents;
    private subscription;
    data: ReplaceableComponents.ReplaceableTemplateDirectiveInput<any, any>;
    providedData: ReplaceableComponents.ReplaceableTemplateData<any, any>;
    context: any;
    externalComponent: Type<any>;
    defaultComponentRef: any;
    defaultComponentSubscriptions: ABP.Dictionary<Subscription>;
    initialized: boolean;
    constructor();
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    setDefaultComponentInputs(): void;
    setProvidedData(): void;
    resetDefaultComponent(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ReplaceableTemplateDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ReplaceableTemplateDirective, "[abpReplaceableTemplate]", never, { "data": { "alias": "abpReplaceableTemplate"; "required": false; }; }, {}, never, never, true, never>;
}

declare class StopPropagationDirective implements OnInit {
    private el;
    private subscription;
    readonly stopPropEvent: EventEmitter<MouseEvent>;
    ngOnInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<StopPropagationDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<StopPropagationDirective, "[click.stop]", never, {}, { "stopPropEvent": "click.stop"; }, never, never, true, never>;
}

declare class LocalizationPipe implements PipeTransform {
    private localization;
    transform(value?: string | LocalizationWithDefault, ...interpolateParams: (string | string[] | undefined)[]): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<LocalizationPipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<LocalizationPipe, "abpLocalization", true>;
    static ɵprov: i0.ɵɵInjectableDeclaration<LocalizationPipe>;
}

type SortOrder = 'asc' | 'desc';
declare class SortPipe implements PipeTransform {
    transform(value: any[], sortOrder?: SortOrder | string, sortKey?: string | number): any;
    static ɵfac: i0.ɵɵFactoryDeclaration<SortPipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<SortPipe, "abpSort", true>;
    static ɵprov: i0.ɵɵInjectableDeclaration<SortPipe>;
}

declare class SafeHtmlPipe implements PipeTransform {
    private readonly sanitizer;
    transform(value: string): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<SafeHtmlPipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<SafeHtmlPipe, "abpSafeHtml", true>;
    static ɵprov: i0.ɵɵInjectableDeclaration<SafeHtmlPipe>;
}

declare class ShortDateTimePipe extends DatePipe implements PipeTransform {
    private configStateService;
    constructor();
    transform(value: Date | string | number, format?: string, timezone?: string, locale?: string): string | null;
    transform(value: null | undefined, format?: string, timezone?: string, locale?: string): null;
    static ɵfac: i0.ɵɵFactoryDeclaration<ShortDateTimePipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<ShortDateTimePipe, "shortDateTime", true>;
}

declare class ShortTimePipe extends DatePipe implements PipeTransform {
    private configStateService;
    constructor();
    transform(value: Date | string | number, format?: string, timezone?: string, locale?: string): string | null;
    transform(value: null | undefined, format?: string, timezone?: string, locale?: string): null;
    static ɵfac: i0.ɵɵFactoryDeclaration<ShortTimePipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<ShortTimePipe, "shortTime", true>;
}

declare class ShortDatePipe extends DatePipe implements PipeTransform {
    private configStateService;
    constructor();
    transform(value: Date | string | number, format?: string, timezone?: string, locale?: string): string | null;
    transform(value: null | undefined, format?: string, timezone?: string, locale?: string): null;
    static ɵfac: i0.ɵɵFactoryDeclaration<ShortDatePipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<ShortDatePipe, "shortDate", true>;
}

declare const INJECTOR_PIPE_DATA_TOKEN: InjectionToken<PipeTransform>;
declare class ToInjectorPipe implements PipeTransform {
    private injector;
    transform(value: any, token?: InjectionToken<any>, name?: string): Injector;
    static ɵfac: i0.ɵɵFactoryDeclaration<ToInjectorPipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<ToInjectorPipe, "toInjector", true>;
}

declare class UtcToLocalPipe implements PipeTransform {
    protected readonly timezoneService: TimezoneService;
    protected readonly timeService: TimeService;
    protected readonly configState: ConfigStateService;
    protected readonly localizationService: LocalizationService;
    protected readonly locale: string;
    transform(value: string | Date | null | undefined, type: 'date' | 'datetime' | 'time'): string | Date;
    private getFormat;
    static ɵfac: i0.ɵɵFactoryDeclaration<UtcToLocalPipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<UtcToLocalPipe, "abpUtcToLocal", true>;
    static ɵprov: i0.ɵɵInjectableDeclaration<UtcToLocalPipe>;
}

declare class LazyLocalizationPipe implements PipeTransform {
    private localizationService;
    private configStateService;
    transform(key: string, ...params: (string | string[])[]): Observable<string>;
    static ɵfac: i0.ɵɵFactoryDeclaration<LazyLocalizationPipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<LazyLocalizationPipe, "abpLazyLocalization", true>;
    static ɵprov: i0.ɵɵInjectableDeclaration<LazyLocalizationPipe>;
}

/**
 * BaseCoreModule is the module that holds
 * all imports, declarations, exports, and entryComponents
 * but not the providers.
 * This module will be imported and exported by all others.
 */
declare class BaseCoreModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<BaseCoreModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<BaseCoreModule, never, [typeof i1.CommonModule, typeof i2.FormsModule, typeof i2.ReactiveFormsModule, typeof i3.RouterModule, typeof i4.NgxValidateCoreModule, typeof AutofocusDirective, typeof InputEventDebounceDirective, typeof ForDirective, typeof FormSubmitDirective, typeof InitDirective, typeof PermissionDirective, typeof ReplaceableTemplateDirective, typeof StopPropagationDirective, typeof LocalizationPipe, typeof SortPipe, typeof SafeHtmlPipe, typeof ShortDateTimePipe, typeof ShortTimePipe, typeof ShortDatePipe, typeof ToInjectorPipe, typeof UtcToLocalPipe, typeof LazyLocalizationPipe, typeof DynamicLayoutComponent, typeof ReplaceableRouteContainerComponent, typeof RouterOutletComponent, typeof AbstractNgModelComponent], [typeof i1.CommonModule, typeof i2.FormsModule, typeof i2.ReactiveFormsModule, typeof i3.RouterModule, typeof i4.NgxValidateCoreModule, typeof AutofocusDirective, typeof InputEventDebounceDirective, typeof ForDirective, typeof FormSubmitDirective, typeof InitDirective, typeof PermissionDirective, typeof ReplaceableTemplateDirective, typeof StopPropagationDirective, typeof LocalizationPipe, typeof SortPipe, typeof SafeHtmlPipe, typeof ShortDateTimePipe, typeof ShortTimePipe, typeof ShortDatePipe, typeof ToInjectorPipe, typeof UtcToLocalPipe, typeof LazyLocalizationPipe, typeof DynamicLayoutComponent, typeof ReplaceableRouteContainerComponent, typeof RouterOutletComponent, typeof AbstractNgModelComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<BaseCoreModule>;
}
/**
 * RootCoreModule is the module that will be used at root level
 * and it introduces imports useful at root level (e.g. NGXS)
 */
declare class RootCoreModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<RootCoreModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<RootCoreModule, never, [typeof BaseCoreModule], [typeof BaseCoreModule]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<RootCoreModule>;
}
/**
 * CoreModule is the module that is publicly available
 */
declare class CoreModule {
    /**
     * @deprecated forRoot method is deprecated, use `provideAbpCore` *function* for config settings.
     */
    static forRoot(options?: ABP.Root): ModuleWithProviders<RootCoreModule>;
    /**
     * @deprecated forChild method is deprecated, use `provideAbpCoreChild` *function* for config settings.
     */
    static forChild(options?: ABP.Child): ModuleWithProviders<RootCoreModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<CoreModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<CoreModule, never, [typeof BaseCoreModule], [typeof BaseCoreModule]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<CoreModule>;
}

declare class ShowPasswordDirective {
    protected readonly elementRef: ElementRef<any>;
    set abpShowPassword(visible: boolean);
    static ɵfac: i0.ɵɵFactoryDeclaration<ShowPasswordDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ShowPasswordDirective, "[abpShowPassword]", never, { "abpShowPassword": { "alias": "abpShowPassword"; "required": false; }; }, {}, never, never, true, never>;
}

declare class TrackCapsLockDirective {
    capsLock: EventEmitter<boolean>;
    onKeyDown(event: KeyboardEvent): void;
    onKeyUp(event: KeyboardEvent): void;
    isCapsLockOpen(e: any): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<TrackCapsLockDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TrackCapsLockDirective, "[abpCapsLock]", never, {}, { "capsLock": "abpCapsLock"; }, never, never, true, never>;
}

/**
 * @deprecated Use `permissionGuard` *function* instead.
 */
declare class PermissionGuard implements IAbpGuard {
    protected readonly router: Router;
    protected readonly routesService: RoutesService;
    protected readonly authService: AuthService;
    protected readonly permissionService: PermissionService;
    protected readonly httpErrorReporter: HttpErrorReporterService;
    protected readonly configStateService: ConfigStateService;
    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree>;
    static ɵfac: i0.ɵɵFactoryDeclaration<PermissionGuard, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<PermissionGuard>;
}
declare const permissionGuard: CanActivateFn;

/**
 * @deprecated Use `LocalizationPipe` and `LazyLocalizationPipe` directly as a standalone pipe.
 * This module is no longer necessary for using the `LocalizationPipe` and `LazyLocalizationPipe` pipes.
 */
declare class LocalizationModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<LocalizationModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<LocalizationModule, never, [typeof LocalizationPipe, typeof LazyLocalizationPipe], [typeof LocalizationPipe, typeof LazyLocalizationPipe]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<LocalizationModule>;
}

declare class HtmlEncodePipe implements PipeTransform {
    transform(value: string): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<HtmlEncodePipe, never>;
    static ɵpipe: i0.ɵɵPipeDeclaration<HtmlEncodePipe, "htmlEncode", true>;
}

declare function setLanguageToCookie(): void;
declare const CookieLanguageProvider: i0.EnvironmentProviders;

declare class LocaleId extends String {
    private localizationService;
    constructor();
    toString(): string;
    valueOf(): string;
}
declare const LocaleProvider: Provider;

declare const IncludeLocalizationResourcesProvider: Provider;

declare enum CoreFeatureKind {
    Options = 0,
    CompareFunctionFactory = 1,
    TitleStrategy = 2
}
interface CoreFeature<KindT extends CoreFeatureKind> {
    ɵkind: KindT;
    ɵproviders: Provider[];
}
declare function withOptions(options?: ABP.Root): CoreFeature<CoreFeatureKind.Options>;
declare function withTitleStrategy(strategy: unknown): CoreFeature<CoreFeatureKind.TitleStrategy>;
declare function withCompareFuncFactory(factory: (a: SortableItem, b: SortableItem) => 1 | -1 | 0): CoreFeature<CoreFeatureKind.CompareFunctionFactory>;
declare function provideAbpCore(...features: CoreFeature<CoreFeatureKind>[]): i0.EnvironmentProviders;
declare function provideAbpCoreChild(options?: ABP.Child): i0.EnvironmentProviders;

declare class AbpTenantService {
    private restService;
    apiName: string;
    findTenantById: (id: string, config?: Partial<Rest.Config>) => rxjs.Observable<FindTenantResultDto>;
    findTenantByName: (name: string, config?: Partial<Rest.Config>) => rxjs.Observable<FindTenantResultDto>;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbpTenantService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AbpTenantService>;
}

interface ActionApiDescriptionModel {
    uniqueName?: string;
    name?: string;
    httpMethod?: string;
    url?: string;
    supportedVersions: string[];
    parametersOnMethod: MethodParameterApiDescriptionModel[];
    parameters: ParameterApiDescriptionModel[];
    returnValue: ReturnValueApiDescriptionModel;
    allowAnonymous?: boolean;
    implementFrom?: string;
}
interface ApplicationApiDescriptionModel {
    modules: Record<string, ModuleApiDescriptionModel>;
    types: Record<string, TypeApiDescriptionModel>;
}
interface ApplicationApiDescriptionModelRequestDto {
    includeTypes: boolean;
}
interface ControllerApiDescriptionModel {
    controllerName?: string;
    controllerGroupName?: string;
    isRemoteService: boolean;
    isIntegrationService: boolean;
    apiVersion?: string;
    type?: string;
    interfaces: ControllerInterfaceApiDescriptionModel[];
    actions: Record<string, ActionApiDescriptionModel>;
}
interface ControllerInterfaceApiDescriptionModel {
    type?: string;
    name?: string;
    methods: InterfaceMethodApiDescriptionModel[];
}
interface InterfaceMethodApiDescriptionModel {
    name?: string;
    parametersOnMethod: MethodParameterApiDescriptionModel[];
    returnValue: ReturnValueApiDescriptionModel;
}
interface MethodParameterApiDescriptionModel {
    name?: string;
    typeAsString?: string;
    type?: string;
    typeSimple?: string;
    isOptional: boolean;
    defaultValue: object;
}
interface ModuleApiDescriptionModel {
    rootPath?: string;
    remoteServiceName?: string;
    controllers: Record<string, ControllerApiDescriptionModel>;
}
interface ParameterApiDescriptionModel {
    nameOnMethod?: string;
    name?: string;
    jsonName?: string;
    type?: string;
    typeSimple?: string;
    isOptional: boolean;
    defaultValue: object;
    constraintTypes: string[];
    bindingSourceId?: string;
    descriptorName?: string;
}
interface PropertyApiDescriptionModel {
    name?: string;
    jsonName?: string;
    type?: string;
    typeSimple?: string;
    isRequired: boolean;
    minLength?: number;
    maxLength?: number;
    minimum?: string;
    maximum?: string;
    regex?: string;
}
interface ReturnValueApiDescriptionModel {
    type?: string;
    typeSimple?: string;
}
interface TypeApiDescriptionModel {
    baseType?: string;
    isEnum: boolean;
    enumNames: string[];
    enumValues: object[];
    genericArguments: string[];
    properties: PropertyApiDescriptionModel[];
}

declare class AbpApiDefinitionService {
    private restService;
    apiName: string;
    getByModel: (model: ApplicationApiDescriptionModelRequestDto, config?: Partial<Rest.Config>) => rxjs.Observable<ApplicationApiDescriptionModel>;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbpApiDefinitionService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AbpApiDefinitionService>;
}

type index_d_EntityExtensionDto = EntityExtensionDto;
type index_d_ExtensionEnumDto = ExtensionEnumDto;
type index_d_ExtensionEnumFieldDto = ExtensionEnumFieldDto;
type index_d_ExtensionPropertyApiCreateDto = ExtensionPropertyApiCreateDto;
type index_d_ExtensionPropertyApiDto = ExtensionPropertyApiDto;
type index_d_ExtensionPropertyApiGetDto = ExtensionPropertyApiGetDto;
type index_d_ExtensionPropertyApiUpdateDto = ExtensionPropertyApiUpdateDto;
type index_d_ExtensionPropertyAttributeDto = ExtensionPropertyAttributeDto;
type index_d_ExtensionPropertyDto = ExtensionPropertyDto;
type index_d_ExtensionPropertyUiDto = ExtensionPropertyUiDto;
type index_d_ExtensionPropertyUiFormDto = ExtensionPropertyUiFormDto;
type index_d_ExtensionPropertyUiLookupDto = ExtensionPropertyUiLookupDto;
type index_d_ExtensionPropertyUiTableDto = ExtensionPropertyUiTableDto;
type index_d_LocalizableStringDto = LocalizableStringDto;
type index_d_ModuleExtensionDto = ModuleExtensionDto;
type index_d_ObjectExtensionsDto = ObjectExtensionsDto;
declare namespace index_d {
  export type { index_d_EntityExtensionDto as EntityExtensionDto, index_d_ExtensionEnumDto as ExtensionEnumDto, index_d_ExtensionEnumFieldDto as ExtensionEnumFieldDto, index_d_ExtensionPropertyApiCreateDto as ExtensionPropertyApiCreateDto, index_d_ExtensionPropertyApiDto as ExtensionPropertyApiDto, index_d_ExtensionPropertyApiGetDto as ExtensionPropertyApiGetDto, index_d_ExtensionPropertyApiUpdateDto as ExtensionPropertyApiUpdateDto, index_d_ExtensionPropertyAttributeDto as ExtensionPropertyAttributeDto, index_d_ExtensionPropertyDto as ExtensionPropertyDto, index_d_ExtensionPropertyUiDto as ExtensionPropertyUiDto, index_d_ExtensionPropertyUiFormDto as ExtensionPropertyUiFormDto, index_d_ExtensionPropertyUiLookupDto as ExtensionPropertyUiLookupDto, index_d_ExtensionPropertyUiTableDto as ExtensionPropertyUiTableDto, index_d_LocalizableStringDto as LocalizableStringDto, index_d_ModuleExtensionDto as ModuleExtensionDto, index_d_ObjectExtensionsDto as ObjectExtensionsDto };
}

declare class AbpApplicationConfigurationService {
    private restService;
    apiName: string;
    get: (options: ApplicationConfigurationRequestOptions, config?: Partial<Rest.Config>) => rxjs.Observable<ApplicationConfigurationDto>;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbpApplicationConfigurationService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AbpApplicationConfigurationService>;
}

declare class AbpApplicationLocalizationService {
    private restService;
    apiName: string;
    get: (input: ApplicationLocalizationRequestDto, config?: Partial<Rest.Config>) => rxjs.Observable<ApplicationLocalizationDto>;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbpApplicationLocalizationService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AbpApplicationLocalizationService>;
}

type AppInitErrorFn = (error: any) => void;
declare const APP_INIT_ERROR_HANDLERS: InjectionToken<AppInitErrorFn[]>;

declare const COOKIE_LANGUAGE_KEY: InjectionToken<string>;

declare const LIST_QUERY_DEBOUNCE_TIME: InjectionToken<number>;

declare const LOCALIZATIONS: InjectionToken<unknown>;
declare function localizationContributor(localizations?: ABP.Localization[]): void;
declare const localizations$: BehaviorSubject<ABP.Localization[]>;

declare const LOADER_DELAY: InjectionToken<number>;

declare const NAVIGATE_TO_MANAGE_PROFILE: InjectionToken<() => void>;

declare const CORE_OPTIONS: InjectionToken<ABP.Root>;
declare function coreOptionsFactory({ ...options }: ABP.Root): ABP.Root;

declare const QUEUE_MANAGER: InjectionToken<QueueManager>;

declare const TENANT_KEY: InjectionToken<string>;

declare const INCUDE_LOCALIZATION_RESOURCES_TOKEN: InjectionToken<boolean>;

declare const PIPE_TO_LOGIN_FN_KEY: InjectionToken<PipeToLoginFn>;

/**
 * @deprecated The token should not be used anymore.
 */
declare const SET_TOKEN_RESPONSE_TO_STORAGE_FN_KEY: InjectionToken<SetTokenResponseToStorageFn>;

declare const CHECK_AUTHENTICATION_STATE_FN_KEY: InjectionToken<CheckAuthenticationStateFn>;

declare const IS_EXTERNAL_REQUEST: HttpContextToken<boolean>;

declare const OTHERS_GROUP: InjectionToken<string>;

declare const TENANT_NOT_FOUND_BY_NAME: InjectionToken<(HttpErrorResponse: HttpErrorResponse) => void>;

declare const SORT_COMPARE_FUNC: InjectionToken<(a: SortableItem, b: SortableItem) => number>;
declare function compareFuncFactory(): (a: SortableItem, b: SortableItem) => 0 | 1 | -1;

declare const DYNAMIC_LAYOUTS_TOKEN: InjectionToken<Map<string, string>>;

declare const DISABLE_PROJECT_NAME: InjectionToken<boolean>;

declare const SSR_FLAG: i0.StateKey<boolean>;
declare const APP_STARTED_WITH_SSR: InjectionToken<boolean>;

declare function pushValueTo<T>(array: T[]): (element: T) => T[];

declare function noop(): () => void;
declare function isUndefinedOrEmptyString(value: unknown): boolean;
declare function isNullOrUndefined<T>(obj: T): boolean;
declare function isNullOrEmpty<T>(obj: T): boolean;
declare function exists<T>(obj: T): obj is T;
declare function isObject<T>(obj: T): boolean;
declare function isArray<T>(obj: T): boolean;
declare function isObjectAndNotArray<T>(obj: T): boolean;
declare function isNode<T>(obj: T): boolean;
declare function isObjectAndNotArrayNotNode<T>(obj: T): boolean;
declare function checkHasProp<T>(object: T, key: string | keyof T): key is keyof T;

declare function getShortDateFormat(configStateService: ConfigStateService): string;
declare function getShortTimeFormat(configStateService: ConfigStateService): string;
declare function getShortDateShortTimeFormat(configStateService: ConfigStateService): string;

declare function getRemoteEnv(injector: Injector, environment: Partial<Environment>): Promise<void> | Promise<Environment>;

declare class LazyModuleFactory<T> extends NgModuleFactory<T> {
    private moduleWithProviders;
    get moduleType(): Type<T>;
    constructor(moduleWithProviders: ModuleWithProviders<T>);
    create(parentInjector: Injector | null): NgModuleRef<T>;
}
declare function featuresFactory(configState: ConfigStateService, featureKeys: string[], mapFn?: (features: {
    [key: string]: string;
}) => any): rxjs.Observable<any>;

/** @deprecated the method will change in v8.0 */
declare function downloadBlob(blob: Blob, filename: string): void;

declare function mapEnumToOptions<T>(_enum: T): ABP.Option<T>[];

declare function uuid(a?: any): string;
declare function generateHash(value: string): number;
declare function generatePassword(injector?: Injector, length?: number): string;

declare function getPathName(url: string): string;
declare class WebHttpUrlEncodingCodec implements HttpParameterCodec {
    encodeKey(k: string): string;
    encodeValue(v: string): string;
    decodeKey(k: string): string;
    decodeValue(v: string): string;
}

declare function getInitialData(): Promise<void>;
declare function localeInitializer(injector?: Injector): Promise<unknown>;

declare function fromLazyLoad<T extends Event>(element: HTMLScriptElement | HTMLLinkElement, domStrategy?: DomStrategy, crossOriginStrategy?: CrossOriginStrategy): Observable<T>;

declare function getLocaleDirection(locale: string): 'ltr' | 'rtl';
declare function createLocalizer(localization: ApplicationLocalizationConfigurationDto): (resourceName: string, key: string, defaultValue: string | null) => string;
declare function createLocalizerWithFallback(localization: ApplicationLocalizationConfigurationDto): (resourceNames: string[], keys: string[], defaultValue: string) => string;
declare function createLocalizationPipeKeyGenerator(localization: ApplicationLocalizationConfigurationDto): (resourceNames: string[], keys: string[], defaultKey: string | undefined) => string;

declare function getCurrentTenancyNameFromUrl(tenantKey: string, injector: any): string | null;
declare function parseTenantFromUrl(injector: Injector): Promise<void | FindTenantResultDto>;

declare function isNumber(value: string | number): boolean;

declare function deepMerge<T>(target: DeepPartial<T> | T, source: DeepPartial<T> | T): DeepPartial<T> | T;

declare function findRoute(routesService: RoutesService, path: string): TreeNode<ABP.Route> | null;
declare function getRoutePath(router: Router, url?: string): string;
declare function reloadRoute(router: Router, ngZone: NgZone): void;

declare function createTokenParser(format: string): (str: string) => Record<string, string[]>;
declare function interpolate(text: string, params: string[]): string;
declare function escapeHtmlChars(value: any): any;

declare class ServerCookieParser {
    static parse(cookieHeader: string): {
        [key: string]: string;
    };
    static middleware(): (req: any, res: any, next: any) => void;
    static getCookie(req: any, name: string): string | undefined;
}

interface MinAgeError {
    minAge: {
        age: number;
    };
}
interface MinAgeOptions {
    age?: number;
}
declare function validateMinAge({ age }?: MinAgeOptions): ValidatorFn;

interface CreditCardError {
    creditCard: true;
}
declare function validateCreditCard(): ValidatorFn;

interface RangeError {
    range: {
        max: number;
        min: number;
    };
}
interface RangeOptions {
    maximum?: number;
    minimum?: number;
}
declare function validateRange({ maximum, minimum }?: RangeOptions): ValidatorFn;

interface RequiredError {
    required: true;
}
interface RequiredOptions {
    allowEmptyStrings?: boolean;
}
declare function validateRequired({ allowEmptyStrings }?: RequiredOptions): ValidatorFn;

interface StringLengthError {
    maxlength?: {
        requiredLength: number;
    };
    minlength?: {
        requiredLength: number;
    };
}
interface StringLengthOptions {
    maximumLength?: number;
    minimumLength?: number;
}
declare function validateStringLength({ maximumLength, minimumLength, }?: StringLengthOptions): ValidatorFn;

interface UniqueCharacterError {
    uniqueCharacter: true;
}
declare function validateUniqueCharacter(): ValidatorFn;

interface UrlError {
    url: true;
}
declare function validateUrl(): ValidatorFn;

interface UsernameOptions {
    pattern?: RegExp;
}
declare function validateUsername({ pattern }?: UsernameOptions): ValidatorFn;

declare const AbpValidators: {
    creditCard: typeof validateCreditCard;
    emailAddress: () => typeof Validators.email;
    minAge: typeof validateMinAge;
    range: typeof validateRange;
    required: typeof validateRequired;
    stringLength: typeof validateStringLength;
    url: typeof validateUrl;
    username: typeof validateUsername;
    uniqueCharacter: typeof validateUniqueCharacter;
};

declare class ApiInterceptor implements IApiInterceptor {
    private httpWaitService;
    getAdditionalHeaders(existingHeaders?: HttpHeaders): HttpHeaders;
    intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ApiInterceptor, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ApiInterceptor>;
}
interface IApiInterceptor extends HttpInterceptor {
    getAdditionalHeaders(existingHeaders?: HttpHeaders): HttpHeaders;
}

declare const timezoneInterceptor: HttpInterceptorFn;

declare const transferStateInterceptor: HttpInterceptorFn;

export { ABP, APP_INIT_ERROR_HANDLERS, APP_STARTED_WITH_SSR, AbpApiDefinitionService, AbpApplicationConfigurationService, AbpApplicationLocalizationService, AbpCookieStorageService, AbpLocalStorageService, AbpTenantService, AbpTitleStrategy, AbpValidators, AbpWindowService, AbstractAuthErrorFilter, AbstractNavTreeService, AbstractNgModelComponent, AbstractTreeService, ApiInterceptor, AuditedEntityDto, AuditedEntityWithUserDto, AuthErrorEvent, AuthErrorFilterService, AuthEvent, AuthGuard, AuthInfoEvent, AuthService, AuthSuccessEvent, AutofocusDirective, BaseCoreModule, BaseTreeNode, CHECK_AUTHENTICATION_STATE_FN_KEY, CONTAINER_STRATEGY, CONTENT_SECURITY_STRATEGY, CONTENT_STRATEGY, CONTEXT_STRATEGY, COOKIE_LANGUAGE_KEY, CORE_OPTIONS, CROSS_ORIGIN_STRATEGY, ClearContainerStrategy, ComponentContextStrategy, ComponentProjectionStrategy, ConfigStateService, ContainerStrategy, ContentProjectionService, ContentSecurityStrategy, ContentStrategy, ContextStrategy, CookieLanguageProvider, CoreFeatureKind, CoreModule, CreationAuditedEntityDto, CreationAuditedEntityWithUserDto, CrossOriginStrategy, DEFAULT_DYNAMIC_LAYOUTS, DISABLE_PROJECT_NAME, DOM_STRATEGY, DYNAMIC_LAYOUTS_TOKEN, DefaultQueueManager, DomInsertionService, DomStrategy, DomStrategyService, DynamicLayoutComponent, EntityDto, EnvironmentService, ExtensibleAuditedEntityDto, ExtensibleAuditedEntityWithUserDto, ExtensibleCreationAuditedEntityDto, ExtensibleCreationAuditedEntityWithUserDto, ExtensibleEntityDto, ExtensibleFullAuditedEntityDto, ExtensibleFullAuditedEntityWithUserDto, ExtensibleLimitedResultRequestDto, ExtensibleObject, ExtensiblePagedAndSortedResultRequestDto, ExtensiblePagedResultRequestDto, ExternalHttpClient, ForDirective, FormSubmitDirective, FullAuditedEntityDto, FullAuditedEntityWithUserDto, HtmlEncodePipe, HtmlEncodingService, HttpErrorReporterService, HttpWaitService, INCUDE_LOCALIZATION_RESOURCES_TOKEN, INJECTOR_PIPE_DATA_TOKEN, IS_EXTERNAL_REQUEST, IncludeLocalizationResourcesProvider, InitDirective, InputEventDebounceDirective, InsertIntoContainerStrategy, InternalStore, InternetConnectionService, LIST_QUERY_DEBOUNCE_TIME, LOADER_DELAY, LOADING_STRATEGY, LOCALIZATIONS, LazyLoadService, LazyLocalizationPipe, LazyModuleFactory, LimitedResultRequestDto, ListResultDto, ListService, LoadingStrategy, LocalStorageListenerService, LocaleId, LocaleProvider, LocalizationModule, LocalizationPipe, LocalizationService, LooseContentSecurityStrategy, MultiTenancyService, NAVIGATE_TO_MANAGE_PROFILE, NavigationEvent, NoContentSecurityStrategy, NoContextStrategy, NoCrossOriginStrategy, OTHERS_GROUP, index_d as ObjectExtending, PIPE_TO_LOGIN_FN_KEY, PROJECTION_STRATEGY, PagedAndSortedResultRequestDto, PagedResultDto, PagedResultRequestDto, PermissionDirective, PermissionGuard, PermissionService, ProjectionStrategy, QUEUE_MANAGER, ReplaceableComponents, ReplaceableComponentsService, ReplaceableRouteContainerComponent, ReplaceableTemplateDirective, ResourceWaitService, Rest, RestService, RootComponentProjectionStrategy, RootCoreModule, RouterEvents, RouterOutletComponent, RouterWaitService, RoutesService, SET_TOKEN_RESPONSE_TO_STORAGE_FN_KEY, SORT_COMPARE_FUNC, SSR_FLAG, SafeHtmlPipe, ScriptContentStrategy, ScriptLoadingStrategy, ServerCookieParser, Session, SessionStateService, ShortDatePipe, ShortDateTimePipe, ShortTimePipe, ShowPasswordDirective, SortPipe, StopPropagationDirective, StyleContentStrategy, StyleLoadingStrategy, SubscriptionService, TENANT_KEY, TENANT_NOT_FOUND_BY_NAME, TemplateContextStrategy, TemplateProjectionStrategy, TimeService, TimezoneService, ToInjectorPipe, TrackByService, TrackCapsLockDirective, UtcToLocalPipe, WebHttpUrlEncodingCodec, asyncAuthGuard, authGuard, checkHasProp, compareFuncFactory, coreOptionsFactory, createGroupMap, createLocalizationPipeKeyGenerator, createLocalizer, createLocalizerWithFallback, createMapFromList, createTokenParser, createTreeFromList, createTreeNodeFilterCreator, deepMerge, differentLocales, downloadBlob, eLayoutType, eThemeSharedComponents, escapeHtmlChars, exists, featuresFactory, findRoute, fromLazyLoad, generateHash, generatePassword, getCurrentTenancyNameFromUrl, getInitialData, getLocaleDirection, getPathName, getRemoteEnv, getRoutePath, getShortDateFormat, getShortDateShortTimeFormat, getShortTimeFormat, interpolate, isArray, isNode, isNullOrEmpty, isNullOrUndefined, isNumber, isObject, isObjectAndNotArray, isObjectAndNotArrayNotNode, isUndefinedOrEmptyString, localeInitializer, localizationContributor, localizations$, mapEnumToOptions, noop, parseTenantFromUrl, permissionGuard, provideAbpCore, provideAbpCoreChild, pushValueTo, reloadRoute, setLanguageToCookie, timezoneInterceptor, trackBy, trackByDeep, transferStateInterceptor, uuid, validateCreditCard, validateMinAge, validateRange, validateRequired, validateStringLength, validateUniqueCharacter, validateUrl, withCompareFuncFactory, withOptions, withTitleStrategy };
export type { AbpAuthResponse, ActionApiDescriptionModel, ApiConfig, Apis, AppInitErrorFn, ApplicationApiDescriptionModel, ApplicationApiDescriptionModelRequestDto, ApplicationAuthConfigurationDto, ApplicationConfigurationDto, ApplicationConfigurationRequestOptions, ApplicationFeatureConfigurationDto, ApplicationGlobalFeatureConfigurationDto, ApplicationInfo, ApplicationLocalizationConfigurationDto, ApplicationLocalizationDto, ApplicationLocalizationRequestDto, ApplicationLocalizationResourceDto, ApplicationSettingConfigurationDto, AuthErrorFilter, CheckAuthenticationStateFn, ClockDto, CompareFn, ControllerApiDescriptionModel, ControllerInterfaceApiDescriptionModel, CoreFeature, CreditCardError, CurrentCultureDto, CurrentTenantDto, CurrentUserDto, DateTimeFormatDto, DeepPartial, ElementOptions, EntityExtensionDto, Environment, EventType, ExtensionEnumDto, ExtensionEnumFieldDto, ExtensionPropertyApiCreateDto, ExtensionPropertyApiDto, ExtensionPropertyApiGetDto, ExtensionPropertyApiUpdateDto, ExtensionPropertyAttributeDto, ExtensionPropertyDto, ExtensionPropertyUiDto, ExtensionPropertyUiFormDto, ExtensionPropertyUiLookupDto, ExtensionPropertyUiTableDto, FindTenantResultDto, HasAdditional, HttpRequestInfo, HttpWaitState, IAbpGuard, IApiInterceptor, IAuthService, IanaTimeZone, Impersonation, InferredContextOf, InferredInstanceOf, InterfaceMethodApiDescriptionModel, LanguageInfo, LegacyLanguageDto, LocalizableStringDto, LocalizationParam, LocalizationWithDefault, LoginParams, MethodParameterApiDescriptionModel, MinAgeError, MinAgeOptions, ModuleApiDescriptionModel, ModuleExtensionDto, MultiTenancyInfoDto, NameValue, NavigationEventKey, NodeKey, NodeValue, ObjectExtensionsDto, ParameterApiDescriptionModel, PipeToLoginFn, Primitive, PropertyApiDescriptionModel, QueryStreamCreatorCallback, QueueManager, RangeError, RangeOptions, RemoteEnv, RequestStatus, RequiredError, RequiredOptions, ResourceDto, ResourceWaitState, ReturnValueApiDescriptionModel, RouteGroup, RouterWaitState, SetTokenResponseToStorageFn, SortOrder, SortableItem, Strict, StringLengthError, StringLengthOptions, TimeZone, TimingDto, TreeNode, TypeApiDescriptionModel, UniqueCharacterError, UrlError, WindowsTimeZone, customMergeFn };
