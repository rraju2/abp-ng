import * as i0 from '@angular/core';
import { Injectable, inject, LOCALE_ID, Input, Component, ChangeDetectorRef, ChangeDetectionStrategy, Renderer2, EventEmitter, ViewChild, Output, InjectionToken, DestroyRef, createComponent, ViewEncapsulation, HostListener, RendererFactory2, Injector, EnvironmentInjector, ApplicationRef, model, input, viewChild, contentChild, output, effect, Directive, forwardRef, HostBinding, NgModule, ElementRef, ComponentFactoryResolver, PLATFORM_ID, ViewContainerRef, TemplateRef, provideAppInitializer, makeEnvironmentProviders } from '@angular/core';
import * as i1 from '@angular/common';
import { formatDate, NgTemplateOutlet, CommonModule, NgClass, AsyncPipe, DOCUMENT, NgStyle, isPlatformBrowser } from '@angular/common';
import { NgbDateAdapter, NgbDatepickerI18n, NgbTimeAdapter, NgbTimepickerI18n, NgbModal, NgbTooltip, NgbInputDatepickerConfig, NgbTypeaheadConfig, NgbDateParserFormatter } from '@ng-bootstrap/ng-bootstrap';
import { ConfigStateService, LocalizationPipe, RoutesService, SubscriptionService, RouterEvents, getRoutePath, StopPropagationDirective, HttpWaitService, RouterWaitService, ContentProjectionService, PROJECTION_STRATEGY, SORT_COMPARE_FUNC, InternalStore, AuthService, SessionStateService, DomInsertionService, CONTENT_STRATEGY, uuid, AbstractNgModelComponent, InternetConnectionService, LocalizationService, getLocaleDirection, HttpErrorReporterService, TENANT_NOT_FOUND_BY_NAME } from '@abp/ng.core';
import { animation, style, animate, keyframes, trigger, state, transition, useAnimation, query } from '@angular/animations';
import { RouterLink, Router, ResolveEnd } from '@angular/router';
import { startWith, map, debounceTime, filter, takeUntil, take, switchMap } from 'rxjs/operators';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { fromEvent, Subscription, combineLatest, timer, ReplaySubject, Subject, BehaviorSubject, distinctUntilChanged, of, from, Observable, EMPTY } from 'rxjs';
import { HttpErrorResponse } from '@angular/common/http';
import * as i1$1 from '@angular/forms';
import { FormsModule, NG_VALUE_ACCESSOR, NgControl, Validators } from '@angular/forms';
import * as i2 from '@ngx-validate/core';
import { NgxValidateCoreModule, normalizeDiacritics, VALIDATION_BLUEPRINTS, defaultMapErrorsFn, VALIDATION_MAP_ERRORS_FN, VALIDATION_VALIDATE_ON_SUBMIT } from '@ngx-validate/core';
import { DatatableComponent, ColumnMode, NgxDatatableModule } from '@swimlane/ngx-datatable';

class DateTimeAdapter {
    fromModel(value) {
        if (!value) {
            return null;
        }
        const date = new Date(value);
        if (isNaN(date)) {
            return null;
        }
        this.value = {
            year: date.getFullYear(),
            month: date.getMonth() + 1,
            day: date.getDate(),
            hour: date.getHours(),
            minute: date.getMinutes(),
            second: date.getSeconds(),
        };
        return this.value;
    }
    toModel(value) {
        if (!value) {
            return '';
        }
        const now = new Date();
        const newValue = {
            year: now.getUTCFullYear(),
            month: now.getMonth() + 1,
            day: now.getDate(),
            hour: 0,
            minute: 0,
            second: 0,
            ...this.value,
            ...value,
        };
        const date = new Date(Date.UTC(newValue.year, newValue.month - 1, newValue.day, newValue.hour, newValue.minute, newValue.second));
        return date.toISOString().replace('Z', '');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DateTimeAdapter, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DateTimeAdapter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DateTimeAdapter, decorators: [{
            type: Injectable
        }] });

class DateAdapter extends NgbDateAdapter {
    fromModel(value) {
        if (!value)
            return null;
        let date;
        if (typeof value === 'string') {
            date = this.dateOf(value);
        }
        else {
            date = new Date(value);
        }
        if (isNaN(date))
            return null;
        return {
            day: date.getDate(),
            month: date.getMonth() + 1,
            year: date.getFullYear(),
        };
    }
    toModel(value) {
        if (!value)
            return '';
        const date = new Date(value.year, value.month - 1, value.day);
        const formattedDate = formatDate(date, 'yyyy-MM-dd', 'en');
        return formattedDate;
    }
    dateOf(value) {
        const dateUtc = new Date(Date.parse(value));
        return new Date(dateUtc.getTime() + Math.abs(dateUtc.getTimezoneOffset() * 60000));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DateAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DateAdapter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DateAdapter, decorators: [{
            type: Injectable
        }] });

class DatepickerI18nAdapter extends NgbDatepickerI18n {
    constructor() {
        super(...arguments);
        this.configState = inject(ConfigStateService, { optional: true });
        this.defaultLocale = inject(LOCALE_ID);
    }
    get locale() {
        return this.configState?.getDeep('localization.currentCulture.cultureName') || this.defaultLocale;
    }
    getWeekdayLabel(weekday) {
        const date = new Date(2017, 0, weekday + 1); // Monday = 1
        return formatDate(date, 'EEEEE', this.locale);
    }
    getWeekLabel() {
        return '';
    }
    getMonthShortName(month) {
        const date = new Date(2017, month - 1, 1);
        return formatDate(date, 'MMM', this.locale);
    }
    getMonthFullName(month) {
        const date = new Date(2017, month - 1, 1);
        return formatDate(date, 'MMMM', this.locale);
    }
    getDayAriaLabel(date) {
        const d = new Date(date.year, date.month - 1, date.day);
        return formatDate(d, 'fullDate', this.locale);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DatepickerI18nAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DatepickerI18nAdapter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DatepickerI18nAdapter, decorators: [{
            type: Injectable
        }] });

class TimeAdapter extends NgbTimeAdapter {
    fromModel(value) {
        if (!value)
            return null;
        const date = isTimeStr(value)
            ? new Date(0, 0, 1, ...value.split(':').map(Number))
            : new Date(value);
        if (isNaN(date))
            return null;
        return {
            hour: date.getHours(),
            minute: date.getMinutes(),
            second: date.getSeconds(),
        };
    }
    toModel(value) {
        if (!value) {
            return null;
        }
        const date = new Date(0, 0, 1, value.hour, value.minute, value.second);
        const formattedDate = formatDate(date, 'HH:mm:ss', 'en');
        return formattedDate;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimeAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimeAdapter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimeAdapter, decorators: [{
            type: Injectable
        }] });
function isTimeStr(value) {
    return /^((2[123])|[01][0-9])(:[0-5][0-9]){1,2}$/.test(String(value));
}

class TimepickerI18nAdapter extends NgbTimepickerI18n {
    constructor() {
        super(...arguments);
        this.configState = inject(ConfigStateService, { optional: true });
        this.defaultLocale = inject(LOCALE_ID);
    }
    get locale() {
        return this.configState?.getDeep('localization.currentCulture.cultureName') || this.defaultLocale;
    }
    getMorningPeriod() {
        const date = new Date(2000, 0, 1, 10, 0, 0);
        return formatDate(date, 'a', this.locale);
    }
    getAfternoonPeriod() {
        const date = new Date(2000, 0, 1, 22, 0, 0);
        return formatDate(date, 'a', this.locale);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimepickerI18nAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimepickerI18nAdapter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TimepickerI18nAdapter, decorators: [{
            type: Injectable
        }] });

const bounceIn = animation([
    style({ opacity: '0', display: '{{ display }}' }),
    animate('{{ time}} {{ easing }}', keyframes([
        style({ opacity: '0', transform: '{{ transform }} scale(0.0)', offset: 0 }),
        style({ opacity: '0', transform: '{{ transform }} scale(0.8)', offset: 0.5 }),
        style({ opacity: '1', transform: '{{ transform }} scale(1.0)', offset: 1 }),
    ])),
], {
    params: {
        time: '350ms',
        easing: 'cubic-bezier(.7,.31,.72,1.47)',
        display: 'block',
        transform: 'translate(-50%, -50%)',
    },
});

const collapseY = animation([
    style({ height: '*', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ height: '0', padding: '0px' })),
], { params: { time: '350ms', easing: 'ease' } });
const collapseYWithMargin = animation([
    style({ 'margin-top': '0' }),
    animate('{{ time }} {{ easing }}', style({ 'margin-left': '-100%' })),
], {
    params: { time: '500ms', easing: 'ease' },
});
const collapseX = animation([
    style({ width: '*', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ width: '0', padding: '0px' })),
], { params: { time: '350ms', easing: 'ease' } });
const expandY = animation([
    style({ height: '0', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ height: '*', padding: '*' })),
], { params: { time: '350ms', easing: 'ease' } });
const expandYWithMargin = animation([
    style({ 'margin-top': '-100%' }),
    animate('{{ time }} {{ easing }}', style({ 'margin-top': '0' })),
], {
    params: { time: '500ms', easing: 'ease' },
});
const expandX = animation([
    style({ width: '0', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ width: '*', padding: '*' })),
], { params: { time: '350ms', easing: 'ease' } });
const collapse = trigger('collapse', [
    state('collapsed', style({ height: '0', overflow: 'hidden' })),
    state('expanded', style({ height: '*', overflow: 'hidden' })),
    transition('expanded => collapsed', useAnimation(collapseY)),
    transition('collapsed => expanded', useAnimation(expandY)),
]);
const collapseWithMargin = trigger('collapseWithMargin', [
    state('collapsed', style({ 'margin-top': '-100%' })),
    state('expanded', style({ 'margin-top': '0' })),
    transition('expanded => collapsed', useAnimation(collapseYWithMargin), {
        params: { time: '400ms', easing: 'linear' },
    }),
    transition('collapsed => expanded', useAnimation(expandYWithMargin)),
]);
const collapseLinearWithMargin = trigger('collapseLinearWithMargin', [
    state('collapsed', style({ 'margin-top': '-100vh' })),
    state('expanded', style({ 'margin-top': '0' })),
    transition('expanded => collapsed', useAnimation(collapseYWithMargin, { params: { time: '200ms', easing: 'linear' } })),
    transition('collapsed => expanded', useAnimation(expandYWithMargin, { params: { time: '250ms', easing: 'linear' } })),
]);

const fadeIn = animation([style({ opacity: '0' }), animate('{{ time}} {{ easing }}', style({ opacity: '1' }))], {
    params: { time: '350ms', easing: 'ease' },
});
const fadeOut = animation([style({ opacity: '1' }), animate('{{ time}} {{ easing }}', style({ opacity: '0' }))], { params: { time: '350ms', easing: 'ease' } });
const fadeInDown = animation([
    style({ opacity: '0', transform: '{{ transform }} translateY(-20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateY(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeInUp = animation([
    style({ opacity: '0', transform: '{{ transform }} translateY(20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateY(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeInLeft = animation([
    style({ opacity: '0', transform: '{{ transform }} translateX(20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateX(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeInRight = animation([
    style({ opacity: '0', transform: '{{ transform }} translateX(-20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateX(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutDown = animation([
    style({ opacity: '1', transform: '{{ transform }} translateY(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateY(20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutUp = animation([
    style({ opacity: '1', transform: '{{ transform }} translateY(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateY(-20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutLeft = animation([
    style({ opacity: '1', transform: '{{ transform }} translateX(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateX(20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutRight = animation([
    style({ opacity: '1', transform: '{{ transform }} translateX(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateX(-20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });

const fadeAnimation = trigger('fade', [
    transition(':enter', useAnimation(fadeIn)),
    transition(':leave', useAnimation(fadeOut)),
]);
const dialogAnimation = trigger('dialog', [
    transition(':enter', useAnimation(fadeInDown)),
    transition(':leave', useAnimation(fadeOut)),
]);

const slideFromBottom = trigger('slideFromBottom', [
    transition('* <=> *', [
        style({ 'margin-top': '20px', opacity: '0' }),
        animate('0.2s ease-out', style({ opacity: '1', 'margin-top': '0px' })),
    ]),
]);

const toastInOut = trigger('toastInOut', [
    transition('* <=> *', [
        query(':enter', [
            style({ opacity: 0, transform: 'translateY(20px)' }),
            animate('350ms ease', style({ opacity: 1, transform: 'translateY(0)' })),
        ], { optional: true }),
        query(':leave', animate('450ms ease', style({ opacity: 0 })), {
            optional: true,
        }),
    ]),
]);

class BreadcrumbItemsComponent {
    constructor() {
        this.items = [];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: BreadcrumbItemsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.7", type: BreadcrumbItemsComponent, isStandalone: true, selector: "abp-breadcrumb-items", inputs: { items: "items" }, ngImport: i0, template: "@if (items.length) {\r\n  <ol class=\"breadcrumb\">\r\n    <li class=\"breadcrumb-item\">\r\n      <a routerLink=\"/\"><i class=\"fa fa-home\" aria-hidden=\"true\"></i> </a>\r\n    </li>\r\n    @for (item of items; track $index; let last = $last) {\r\n      <li class=\"breadcrumb-item\" [class.active]=\"last\" aria-current=\"page\">\r\n        <ng-container\r\n          *ngTemplateOutlet=\"item.path ? linkTemplate : textTemplate; context: { $implicit: item }\"\r\n        ></ng-container>\r\n      </li>\r\n    }\r\n  </ol>\r\n}\r\n\r\n<ng-template #linkTemplate let-item>\r\n  <a [routerLink]=\"item.path\"> {{ item.name | abpLocalization }}</a>\r\n</ng-template>\r\n\r\n<ng-template #textTemplate let-item>\r\n  {{ item.name | abpLocalization }}\r\n</ng-template>\r\n", dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "info", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "pipe", type: LocalizationPipe, name: "abpLocalization" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: BreadcrumbItemsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-breadcrumb-items', imports: [NgTemplateOutlet, RouterLink, LocalizationPipe], template: "@if (items.length) {\r\n  <ol class=\"breadcrumb\">\r\n    <li class=\"breadcrumb-item\">\r\n      <a routerLink=\"/\"><i class=\"fa fa-home\" aria-hidden=\"true\"></i> </a>\r\n    </li>\r\n    @for (item of items; track $index; let last = $last) {\r\n      <li class=\"breadcrumb-item\" [class.active]=\"last\" aria-current=\"page\">\r\n        <ng-container\r\n          *ngTemplateOutlet=\"item.path ? linkTemplate : textTemplate; context: { $implicit: item }\"\r\n        ></ng-container>\r\n      </li>\r\n    }\r\n  </ol>\r\n}\r\n\r\n<ng-template #linkTemplate let-item>\r\n  <a [routerLink]=\"item.path\"> {{ item.name | abpLocalization }}</a>\r\n</ng-template>\r\n\r\n<ng-template #textTemplate let-item>\r\n  {{ item.name | abpLocalization }}\r\n</ng-template>\r\n" }]
        }], propDecorators: { items: [{
                type: Input
            }] } });

class BreadcrumbComponent {
    constructor() {
        this.cdRef = inject(ChangeDetectorRef);
        this.router = inject(Router);
        this.routes = inject(RoutesService);
        this.subscription = inject(SubscriptionService);
        this.routerEvents = inject(RouterEvents);
        this.segments = [];
    }
    ngOnInit() {
        this.subscription.addOne(this.routerEvents.getNavigationEvents('End').pipe(startWith(null), map(() => this.routes.search({ path: getRoutePath(this.router) }))), route => {
            this.segments = [];
            if (route) {
                let node = { parent: route };
                while (node.parent) {
                    node = node.parent;
                    const { parent, children, isLeaf, path, ...segment } = node;
                    if (!isAdministration(segment))
                        this.segments.unshift(segment);
                }
                this.cdRef.detectChanges();
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: BreadcrumbComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: BreadcrumbComponent, isStandalone: true, selector: "abp-breadcrumb", providers: [SubscriptionService], ngImport: i0, template: "<abp-breadcrumb-items [items]=\"segments\"></abp-breadcrumb-items>\r\n", dependencies: [{ kind: "component", type: BreadcrumbItemsComponent, selector: "abp-breadcrumb-items", inputs: ["items"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: BreadcrumbComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-breadcrumb', changeDetection: ChangeDetectionStrategy.OnPush, providers: [SubscriptionService], imports: [BreadcrumbItemsComponent], template: "<abp-breadcrumb-items [items]=\"segments\"></abp-breadcrumb-items>\r\n" }]
        }] });
function isAdministration(route) {
    return route.name === "AbpUiNavigation::Menu:Administration" /* eThemeSharedRouteNames.Administration */;
}

/* eslint-disable @angular-eslint/no-output-native */
class ButtonComponent {
    constructor() {
        this.renderer = inject(Renderer2);
        this.buttonId = '';
        this.buttonClass = 'btn btn-primary';
        this.buttonType = 'button';
        this.formName = undefined;
        this.loading = false;
        this.disabled = false;
        this.click = new EventEmitter();
        this.focus = new EventEmitter();
        this.blur = new EventEmitter();
        this.abpClick = new EventEmitter();
        this.abpFocus = new EventEmitter();
        this.abpBlur = new EventEmitter();
    }
    get icon() {
        return `${this.loading ? 'fa fa-spinner fa-spin' : this.iconClass || 'd-none'}`;
    }
    ngOnInit() {
        if (this.attributes) {
            Object.keys(this.attributes).forEach(key => {
                if (this.attributes?.[key]) {
                    this.renderer.setAttribute(this.buttonRef.nativeElement, key, this.attributes[key]);
                }
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: ButtonComponent, isStandalone: true, selector: "abp-button", inputs: { buttonId: "buttonId", buttonClass: "buttonClass", buttonType: "buttonType", formName: "formName", iconClass: "iconClass", loading: "loading", disabled: "disabled", attributes: "attributes" }, outputs: { click: "click", focus: "focus", blur: "blur", abpClick: "abpClick", abpFocus: "abpFocus", abpBlur: "abpBlur" }, viewQueries: [{ propertyName: "buttonRef", first: true, predicate: ["button"], descendants: true, static: true }], ngImport: i0, template: `
    <button
      #button
      [id]="buttonId"
      [attr.type]="buttonType"
      [attr.form]="formName"
      [ngClass]="buttonClass"
      [disabled]="loading || disabled"
      (click.stop)="click.next($event); abpClick.next($event)"
      (focus)="focus.next($event); abpFocus.next($event)"
      (blur)="blur.next($event); abpBlur.next($event)"
    >
      <i [ngClass]="icon" class="me-1" aria-hidden="true"></i><ng-content></ng-content>
    </button>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: StopPropagationDirective, selector: "[click.stop]", outputs: ["click.stop"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-button',
                    template: `
    <button
      #button
      [id]="buttonId"
      [attr.type]="buttonType"
      [attr.form]="formName"
      [ngClass]="buttonClass"
      [disabled]="loading || disabled"
      (click.stop)="click.next($event); abpClick.next($event)"
      (focus)="focus.next($event); abpFocus.next($event)"
      (blur)="blur.next($event); abpBlur.next($event)"
    >
      <i [ngClass]="icon" class="me-1" aria-hidden="true"></i><ng-content></ng-content>
    </button>
  `,
                    imports: [CommonModule, StopPropagationDirective],
                }]
        }], propDecorators: { buttonId: [{
                type: Input
            }], buttonClass: [{
                type: Input
            }], buttonType: [{
                type: Input
            }], formName: [{
                type: Input
            }], iconClass: [{
                type: Input
            }], loading: [{
                type: Input
            }], disabled: [{
                type: Input
            }], attributes: [{
                type: Input
            }], click: [{
                type: Output
            }], focus: [{
                type: Output
            }], blur: [{
                type: Output
            }], abpClick: [{
                type: Output
            }], abpFocus: [{
                type: Output
            }], abpBlur: [{
                type: Output
            }], buttonRef: [{
                type: ViewChild,
                args: ['button', { static: true }]
            }] } });

var Confirmation;
(function (Confirmation) {
    let Status;
    (function (Status) {
        Status["confirm"] = "confirm";
        Status["reject"] = "reject";
        Status["dismiss"] = "dismiss";
    })(Status = Confirmation.Status || (Confirmation.Status = {}));
})(Confirmation || (Confirmation = {}));

const CONFIRMATION_ICONS = new InjectionToken('CONFIRMATION_ICONS');
const DEFAULT_CONFIRMATION_ICONS = {
    info: 'fa fa-info-circle',
    success: 'fa fa-check-circle',
    warning: 'fa fa-exclamation-triangle',
    error: 'fa fa-times-circle',
    default: 'fa fa-question-circle',
    neutral: '',
};

class ConfirmationComponent {
    constructor() {
        this.icons = inject(CONFIRMATION_ICONS);
        this.confirm = Confirmation.Status.confirm;
        this.reject = Confirmation.Status.reject;
        this.dismiss = Confirmation.Status.dismiss;
    }
    close(status) {
        this.clear(status);
    }
    getIconClass({ severity, options }) {
        if (options && options.icon) {
            return options.icon;
        }
        if (!this.icons) {
            return '';
        }
        if (severity) {
            return this.icons[severity];
        }
        return this.icons.default;
    }
    isCustomIconExists({ options }) {
        return !!(options && (options.iconTemplate || options.icon));
    }
    isIconTemplateExits({ options }) {
        return !!(options && options.iconTemplate);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ConfirmationComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.7", type: ConfirmationComponent, isStandalone: true, selector: "abp-confirmation", ngImport: i0, template: "@if (confirmation$ | async; as data) {\r\n  <div class=\"confirmation\">\r\n    <div\r\n      class=\"confirmation-backdrop\"\r\n      (click)=\"data.options?.dismissible ? close(dismiss) : null\"\r\n    ></div>\r\n    <div class=\"confirmation-dialog\">\r\n      @if (data.severity || isCustomIconExists(data)) {\r\n        <div class=\"icon-container\" [ngClass]=\"data.severity\">\r\n          @if (isIconTemplateExits(data)) {\r\n            <div [outerHTML]=\"data.options.iconTemplate\"></div>\r\n          } @else {\r\n            <i class=\"icon\" [ngClass]=\"getIconClass(data)\"></i>\r\n          }\r\n        </div>\r\n      }\r\n      <div class=\"content\">\r\n        @if (data.title) {\r\n          <h1\r\n            class=\"title\"\r\n            [innerHTML]=\"data.title | abpLocalization: data.options?.titleLocalizationParams\"\r\n          ></h1>\r\n        }\r\n        @if (data.message) {\r\n          <p\r\n            class=\"message\"\r\n            [innerHTML]=\"data.message | abpLocalization: data.options?.messageLocalizationParams\"\r\n          ></p>\r\n        }\r\n      </div>\r\n      <div class=\"footer\">\r\n        @if (!data?.options?.hideCancelBtn) {\r\n          <button\r\n            id=\"cancel\"\r\n            class=\"btn btn-outline-primary me-2\"\r\n            [innerHTML]=\"data.options?.cancelText || 'AbpUi::Cancel' | abpLocalization\"\r\n            (click)=\"close(reject)\"\r\n          ></button>\r\n        }\r\n        @if (!data?.options?.hideYesBtn) {\r\n          <button\r\n            id=\"confirm\"\r\n            class=\"btn btn-primary\"\r\n            [innerHTML]=\"data.options?.yesText || 'AbpUi::Yes' | abpLocalization\"\r\n            (click)=\"close(confirm)\"\r\n          ></button>\r\n        }\r\n      </div>\r\n    </div>\r\n  </div>\r\n}\r\n", styles: [".confirmation{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:1060}.confirmation .confirmation-backdrop{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1061!important}.confirmation .confirmation-dialog{display:flex;flex-direction:column;margin:20px auto;padding:0;width:450px;min-height:300px;z-index:1062!important}@media screen and (max-width:500px){.confirmation .confirmation-dialog{width:90vw}}.confirmation .confirmation-dialog .icon-container{display:flex;align-items:center;justify-content:center;padding:40px 20px 10px}.confirmation .confirmation-dialog .icon-container .icon{width:100px;height:100px;stroke-width:1;font-size:80px;text-align:center}.confirmation .confirmation-dialog .content{flex-grow:1;display:block}.confirmation .confirmation-dialog .content .title{display:block;margin:0;padding:0;font-size:27px;font-weight:600;text-align:center}.confirmation .confirmation-dialog .content .message{display:block;padding:8px 20px 20px;font-size:16px;font-weight:400;text-align:center;margin-bottom:0}.confirmation .confirmation-dialog .footer{display:flex;align-items:center;justify-content:flex-end;padding:20px;width:100%}\n"], dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "pipe", type: LocalizationPipe, name: "abpLocalization" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ConfirmationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-confirmation', imports: [NgClass, AsyncPipe, LocalizationPipe], template: "@if (confirmation$ | async; as data) {\r\n  <div class=\"confirmation\">\r\n    <div\r\n      class=\"confirmation-backdrop\"\r\n      (click)=\"data.options?.dismissible ? close(dismiss) : null\"\r\n    ></div>\r\n    <div class=\"confirmation-dialog\">\r\n      @if (data.severity || isCustomIconExists(data)) {\r\n        <div class=\"icon-container\" [ngClass]=\"data.severity\">\r\n          @if (isIconTemplateExits(data)) {\r\n            <div [outerHTML]=\"data.options.iconTemplate\"></div>\r\n          } @else {\r\n            <i class=\"icon\" [ngClass]=\"getIconClass(data)\"></i>\r\n          }\r\n        </div>\r\n      }\r\n      <div class=\"content\">\r\n        @if (data.title) {\r\n          <h1\r\n            class=\"title\"\r\n            [innerHTML]=\"data.title | abpLocalization: data.options?.titleLocalizationParams\"\r\n          ></h1>\r\n        }\r\n        @if (data.message) {\r\n          <p\r\n            class=\"message\"\r\n            [innerHTML]=\"data.message | abpLocalization: data.options?.messageLocalizationParams\"\r\n          ></p>\r\n        }\r\n      </div>\r\n      <div class=\"footer\">\r\n        @if (!data?.options?.hideCancelBtn) {\r\n          <button\r\n            id=\"cancel\"\r\n            class=\"btn btn-outline-primary me-2\"\r\n            [innerHTML]=\"data.options?.cancelText || 'AbpUi::Cancel' | abpLocalization\"\r\n            (click)=\"close(reject)\"\r\n          ></button>\r\n        }\r\n        @if (!data?.options?.hideYesBtn) {\r\n          <button\r\n            id=\"confirm\"\r\n            class=\"btn btn-primary\"\r\n            [innerHTML]=\"data.options?.yesText || 'AbpUi::Yes' | abpLocalization\"\r\n            (click)=\"close(confirm)\"\r\n          ></button>\r\n        }\r\n      </div>\r\n    </div>\r\n  </div>\r\n}\r\n", styles: [".confirmation{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:1060}.confirmation .confirmation-backdrop{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1061!important}.confirmation .confirmation-dialog{display:flex;flex-direction:column;margin:20px auto;padding:0;width:450px;min-height:300px;z-index:1062!important}@media screen and (max-width:500px){.confirmation .confirmation-dialog{width:90vw}}.confirmation .confirmation-dialog .icon-container{display:flex;align-items:center;justify-content:center;padding:40px 20px 10px}.confirmation .confirmation-dialog .icon-container .icon{width:100px;height:100px;stroke-width:1;font-size:80px;text-align:center}.confirmation .confirmation-dialog .content{flex-grow:1;display:block}.confirmation .confirmation-dialog .content .title{display:block;margin:0;padding:0;font-size:27px;font-weight:600;text-align:center}.confirmation .confirmation-dialog .content .message{display:block;padding:8px 20px 20px;font-size:16px;font-weight:400;text-align:center;margin-bottom:0}.confirmation .confirmation-dialog .footer{display:flex;align-items:center;justify-content:flex-end;padding:20px;width:100%}\n"] }]
        }] });

class HttpErrorWrapperComponent {
    constructor() {
        this.destroyRef = inject(DestroyRef);
        this.document = inject(DOCUMENT);
        this.window = this.document.defaultView;
        this.router = inject(Router);
        this.status = 0;
        this.title = '_::Oops!';
        this.details = '_::Sorry, an error has occured.';
        this.customComponent = undefined;
        this.hideCloseIcon = false;
        this.isHomeShow = true;
    }
    get statusText() {
        return this.status ? `[${this.status}]` : '';
    }
    ngOnInit() {
        const computedStyle = this.window.getComputedStyle(this.document.body);
        const backgroundColor = computedStyle?.getPropertyValue('background-color');
        this.backgroundColor = backgroundColor || '#fff';
    }
    ngAfterViewInit() {
        if (this.customComponent) {
            const customComponentRef = createComponent(this.customComponent, {
                environmentInjector: this.environmentInjector,
            });
            customComponentRef.instance.errorStatus = this.status;
            //In our custom "HttpErrorComponent", we have a "status" property.
            //We used to have "errorStatus", but it wasn't signal type. "status" variable is signal type.
            //I've checked because of backward compatibility. Developers might have their own custom HttpErrorComponent.
            //We need to deprecated and remove "errorStatus" in the future.
            if (customComponentRef.instance.status) {
                customComponentRef.instance.status.set(this.status);
            }
            customComponentRef.instance.destroy$ = this.destroy$;
            this.appRef.attachView(customComponentRef.hostView);
            if (this.containerRef) {
                this.containerRef.nativeElement.appendChild(customComponentRef.hostView.rootNodes[0]);
            }
            customComponentRef.changeDetectorRef.detectChanges();
        }
        fromEvent(this.document, 'keyup')
            .pipe(debounceTime(150), filter((key) => key && key.key === 'Escape'), takeUntilDestroyed(this.destroyRef))
            .subscribe(() => this.destroy());
    }
    goHome() {
        this.router.navigateByUrl('/', { onSameUrlNavigation: 'reload' });
        this.destroy();
    }
    destroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    ngOnDestroy() {
        this.destroy();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HttpErrorWrapperComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.7", type: HttpErrorWrapperComponent, isStandalone: true, selector: "abp-http-error-wrapper", viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["container"], descendants: true }], ngImport: i0, template: "<div\r\n  #container\r\n  id=\"abp-http-error-container\"\r\n  class=\"error\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n>\r\n  @if (!hideCloseIcon) {\r\n    <button id=\"abp-close-button\" type=\"button\" class=\"btn-close me-2\" (click)=\"destroy()\"></button>\r\n  }\r\n\r\n  @if (!customComponent) {\r\n    <div class=\"row centered\">\r\n      <div class=\"col-md-12\">\r\n        <div class=\"error-template\">\r\n          <h1>{{ statusText }} {{ title | abpLocalization }}</h1>\r\n          <div class=\"error-details\">\r\n            {{ details | abpLocalization }}\r\n          </div>\r\n          <div class=\"error-actions\">\r\n            @if (isHomeShow) {\r\n              <a (click)=\"goHome()\" class=\"btn btn-primary btn-md mt-2\"\r\n                ><span class=\"glyphicon glyphicon-home\"></span>\r\n                {{ { key: '::Menu:Home', defaultValue: 'Home' } | abpLocalization }}\r\n              </a>\r\n            }\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  }\r\n</div>\r\n", styles: [".error{position:fixed;top:0;width:100vw;height:100vh;z-index:999999}.centered{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "pipe", type: LocalizationPipe, name: "abpLocalization" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: HttpErrorWrapperComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-http-error-wrapper', imports: [CommonModule, LocalizationPipe], template: "<div\r\n  #container\r\n  id=\"abp-http-error-container\"\r\n  class=\"error\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n>\r\n  @if (!hideCloseIcon) {\r\n    <button id=\"abp-close-button\" type=\"button\" class=\"btn-close me-2\" (click)=\"destroy()\"></button>\r\n  }\r\n\r\n  @if (!customComponent) {\r\n    <div class=\"row centered\">\r\n      <div class=\"col-md-12\">\r\n        <div class=\"error-template\">\r\n          <h1>{{ statusText }} {{ title | abpLocalization }}</h1>\r\n          <div class=\"error-details\">\r\n            {{ details | abpLocalization }}\r\n          </div>\r\n          <div class=\"error-actions\">\r\n            @if (isHomeShow) {\r\n              <a (click)=\"goHome()\" class=\"btn btn-primary btn-md mt-2\"\r\n                ><span class=\"glyphicon glyphicon-home\"></span>\r\n                {{ { key: '::Menu:Home', defaultValue: 'Home' } | abpLocalization }}\r\n              </a>\r\n            }\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  }\r\n</div>\r\n", styles: [".error{position:fixed;top:0;width:100vw;height:100vh;z-index:999999}.centered{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}\n"] }]
        }], propDecorators: { containerRef: [{
                type: ViewChild,
                args: ['container', { static: false }]
            }] } });

class LoaderBarComponent {
    constructor() {
        this.cdRef = inject(ChangeDetectorRef);
        this.subscription = inject(SubscriptionService);
        this.httpWaitService = inject(HttpWaitService);
        this.routerWaitService = inject(RouterWaitService);
        this.containerClass = 'abp-loader-bar';
        this.color = '#77b6ff';
        this.progressLevel = 0;
        this.interval = new Subscription();
        this.timer = new Subscription();
        this.intervalPeriod = 350;
        this.stopDelay = 800;
        this.clearProgress = () => {
            this.progressLevel = 0;
            this.cdRef.detectChanges();
        };
        this.reportProgress = () => {
            if (this.progressLevel < 75) {
                this.progressLevel += 1 + Math.random() * 9;
            }
            else if (this.progressLevel < 90) {
                this.progressLevel += 0.4;
            }
            else if (this.progressLevel < 100) {
                this.progressLevel += 0.1;
            }
            else {
                this.interval.unsubscribe();
            }
            this.cdRef.detectChanges();
        };
    }
    set isLoading(value) {
        this._isLoading = value;
        this.cdRef.detectChanges();
    }
    get isLoading() {
        return this._isLoading;
    }
    get boxShadow() {
        return `0 0 10px rgba(${this.color}, 0.5)`;
    }
    ngOnInit() {
        this.subscribeLoading();
    }
    subscribeLoading() {
        this.subscription.addOne(combineLatest([this.httpWaitService.getLoading$(), this.routerWaitService.getLoading$()]), ([httpLoading, routerLoading]) => {
            if (httpLoading || routerLoading)
                this.startLoading();
            else
                this.stopLoading();
        });
    }
    ngOnDestroy() {
        this.interval.unsubscribe();
    }
    startLoading() {
        if (this.isLoading || !this.interval.closed)
            return;
        this.isLoading = true;
        this.progressLevel = 0;
        this.cdRef.detectChanges();
        this.interval = timer(0, this.intervalPeriod).subscribe(this.reportProgress);
        this.timer.unsubscribe();
    }
    stopLoading() {
        this.interval.unsubscribe();
        this.progressLevel = 100;
        this.isLoading = false;
        if (!this.timer.closed)
            return;
        this.timer = timer(this.stopDelay).subscribe(this.clearProgress);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LoaderBarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: LoaderBarComponent, isStandalone: true, selector: "abp-loader-bar", inputs: { isLoading: "isLoading", containerClass: "containerClass", color: "color" }, providers: [SubscriptionService], ngImport: i0, template: `
    <div id="abp-loader-bar" [ngClass]="containerClass" [class.is-loading]="isLoading">
      <div
        class="abp-progress"
        [class.progressing]="progressLevel"
        [style.width.vw]="progressLevel"
        [ngStyle]="{
          'background-color': color,
          'box-shadow': boxShadow,
        }"
      ></div>
    </div>
  `, isInline: true, styles: [".abp-loader-bar{left:0;opacity:0;position:fixed;top:0;transition:opacity .4s linear .4s;z-index:99999}.abp-loader-bar.is-loading{opacity:1;transition:none}.abp-loader-bar .abp-progress{height:3px;left:0;position:fixed;top:0}.abp-loader-bar .abp-progress.progressing{transition:width .4s ease}\n"], dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LoaderBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-loader-bar', template: `
    <div id="abp-loader-bar" [ngClass]="containerClass" [class.is-loading]="isLoading">
      <div
        class="abp-progress"
        [class.progressing]="progressLevel"
        [style.width.vw]="progressLevel"
        [ngStyle]="{
          'background-color': color,
          'box-shadow': boxShadow,
        }"
      ></div>
    </div>
  `, providers: [SubscriptionService], imports: [NgClass, NgStyle], styles: [".abp-loader-bar{left:0;opacity:0;position:fixed;top:0;transition:opacity .4s linear .4s;z-index:99999}.abp-loader-bar.is-loading{opacity:1;transition:none}.abp-loader-bar .abp-progress{height:3px;left:0;position:fixed;top:0}.abp-loader-bar .abp-progress.progressing{transition:width .4s ease}\n"] }]
        }], propDecorators: { isLoading: [{
                type: Input
            }], containerClass: [{
                type: Input
            }], color: [{
                type: Input
            }] } });

class LoadingComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LoadingComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: LoadingComponent, isStandalone: true, selector: "abp-loading", ngImport: i0, template: `
    <div class="abp-loading">
      <i class="fa fa-spinner fa-pulse abp-spinner" aria-hidden="true"></i>
    </div>
  `, isInline: true, styles: [".abp-loading{position:absolute;width:100%;height:100%;top:0;left:0;z-index:1040}.abp-loading .abp-spinner{position:absolute;top:50%;left:50%;font-size:14px;-moz-transform:translateX(-50%) translateY(-50%);-o-transform:translateX(-50%) translateY(-50%);-ms-transform:translateX(-50%) translateY(-50%);-webkit-transform:translateX(-50%) translateY(-50%);transform:translate(-50%) translateY(-50%)}\n"], encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LoadingComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-loading', template: `
    <div class="abp-loading">
      <i class="fa fa-spinner fa-pulse abp-spinner" aria-hidden="true"></i>
    </div>
  `, encapsulation: ViewEncapsulation.None, imports: [], styles: [".abp-loading{position:absolute;width:100%;height:100%;top:0;left:0;z-index:1040}.abp-loading .abp-spinner{position:absolute;top:50%;left:50%;font-size:14px;-moz-transform:translateX(-50%) translateY(-50%);-o-transform:translateX(-50%) translateY(-50%);-ms-transform:translateX(-50%) translateY(-50%);-webkit-transform:translateX(-50%) translateY(-50%);transform:translate(-50%) translateY(-50%)}\n"] }]
        }] });

class NavItem {
    constructor(props) {
        Object.assign(this, props);
    }
}

class UserMenu extends NavItem {
}

class ConfirmationService {
    constructor() {
        this.contentProjectionService = inject(ContentProjectionService);
        this.document = inject(DOCUMENT);
        this.confirmation$ = new ReplaySubject(1);
        this.clear = (status = Confirmation.Status.dismiss) => {
            this.confirmation$.next(null);
            this.status$.next(status);
        };
    }
    setContainer() {
        this.containerComponentRef = this.contentProjectionService.projectContent(PROJECTION_STRATEGY.AppendComponentToBody(ConfirmationComponent, {
            confirmation$: this.confirmation$,
            clear: this.clear,
        }));
        setTimeout(() => {
            this.containerComponentRef.changeDetectorRef.detectChanges();
        }, 0);
    }
    info(message, title, options) {
        return this.show(message, title, 'info', options);
    }
    success(message, title, options) {
        return this.show(message, title, 'success', options);
    }
    warn(message, title, options) {
        return this.show(message, title, 'warning', options);
    }
    error(message, title, options) {
        return this.show(message, title, 'error', options);
    }
    show(message, title, severity, options = {}) {
        if (!this.containerComponentRef)
            this.setContainer();
        this.confirmation$.next({
            message,
            title,
            severity: severity || 'neutral',
            options,
        });
        this.status$ = new Subject();
        const { dismissible = true } = options;
        if (dismissible)
            this.listenToEscape();
        return this.status$;
    }
    listenToEscape() {
        fromEvent(this.document, 'keyup')
            .pipe(takeUntil(this.status$), debounceTime(150), filter((key) => key && key.key === 'Escape'))
            .subscribe(() => {
            this.clear();
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ConfirmationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ConfirmationService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ConfirmationService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class AbstractMenuService {
    get items() {
        return this._items$.value;
    }
    get items$() {
        return this._items$.asObservable();
    }
    constructor() {
        this._items$ = new BehaviorSubject([]);
        this.sortItems = (a, b) => {
            return this.sortFn(a, b);
        };
        this.sortFn = inject(SORT_COMPARE_FUNC);
    }
    addItems(newItems) {
        const items = [...this.items];
        newItems.forEach(item => {
            const index = items.findIndex(i => i.id === item.id);
            const data = new this.baseClass(item);
            if (index > -1) {
                items[index] = data;
                return;
            }
            items.push(data);
        });
        items.sort(this.sortItems);
        this._items$.next(items);
    }
    removeItem(id) {
        const index = this.items.findIndex(item => item.id === id);
        if (index < 0)
            return;
        const items = [...this.items.slice(0, index), ...this.items.slice(index + 1)];
        this._items$.next(items);
    }
    patchItem(id, item) {
        const index = this.items.findIndex(i => i.id === id);
        if (index < 0)
            return;
        const items = [...this.items];
        items[index] = new this.baseClass({ ...items[index], ...item });
        items.sort(this.sortItems);
        this._items$.next(items);
    }
}

class NavItemsService extends AbstractMenuService {
    constructor() {
        super(...arguments);
        this.baseClass = NavItem;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: NavItemsService, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: NavItemsService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: NavItemsService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class PageAlertService {
    constructor() {
        this.alerts = new InternalStore([]);
        this.alerts$ = this.alerts.sliceState(state => state);
    }
    show(alert) {
        const newAlert = {
            ...alert,
            dismissible: alert.dismissible ?? true,
        };
        this.alerts.set([newAlert, ...this.alerts.state]);
    }
    remove(index) {
        const alerts = [...this.alerts.state];
        alerts.splice(index, 1);
        this.alerts.set(alerts);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PageAlertService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PageAlertService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PageAlertService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class ToastComponent {
    constructor() {
        this.remove = new EventEmitter();
    }
    get severityClass() {
        if (!this.toast || !this.toast.severity)
            return '';
        return `abp-toast-${this.toast.severity}`;
    }
    get iconClass() {
        const { iconClass } = this.toast.options || {};
        if (iconClass) {
            return iconClass;
        }
        switch (this.toast.severity) {
            case 'success':
                return 'bi-check';
            case 'info':
                return 'bi-info-circle';
            case 'warning':
                return 'bi-exclamation-triangle';
            case 'error':
                return 'bi-shield-exclamation';
            default:
                return 'bi-exclamation-triangle';
        }
    }
    ngOnInit() {
        const { sticky, life } = this.toast.options || {};
        if (sticky)
            return;
        const timeout = life || 5000;
        setTimeout(() => {
            this.close();
        }, timeout);
    }
    close() {
        this.remove.emit(this.toast.options?.id);
    }
    tap() {
        if (this.toast.options?.tapToDismiss)
            this.close();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ToastComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.7", type: ToastComponent, isStandalone: true, selector: "abp-toast", inputs: { toast: "toast" }, outputs: { remove: "remove" }, ngImport: i0, template: "<div class=\"abp-toast\" [ngClass]=\"severityClass\" (click)=\"tap()\">\r\n  <div class=\"abp-toast-icon\">\r\n    <i class=\"bi icon\" [ngClass]=\"iconClass\" aria-hidden=\"true\"></i>\r\n  </div>\r\n  <div class=\"abp-toast-content\">\r\n    @if (toast.options?.closable) {\r\n      <button class=\"abp-toast-close-button\" (click)=\"close()\">\r\n        <i class=\"bi bi-x fs-4\" aria-hidden=\"true\"></i>\r\n      </button>\r\n    }\r\n    <div class=\"abp-toast-title\">\r\n      {{ toast.title | abpLocalization: toast.options?.titleLocalizationParams }}\r\n    </div>\r\n    <p\r\n      class=\"abp-toast-message\"\r\n      [innerHTML]=\"toast.message | abpLocalization: toast.options?.messageLocalizationParams\"\r\n    ></p>\r\n  </div>\r\n</div>\r\n", styles: [".abp-toast{display:grid;grid-template-columns:35px 1fr;gap:5px;margin:5px 0;padding:7px;width:350px;-webkit-user-select:none;user-select:none;z-index:9999;color:#fff;border-radius:8px;font-size:14px;box-shadow:0 0 20px #4c577d05;border:2px solid #f0f0f0;background-color:#f0f0f0;color:#000;box-shadow:0 0 10px -5px #0006}.abp-toast:hover{border:2px solid #e4e4e4;background-color:#e4e4e4;box-shadow:0 0 15px -5px #0006}.abp-toast{opacity:1}.abp-toast.abp-toast-success{border:2px solid #4fbf67;background-color:#4fbf67;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-success:hover{border:2px solid rgb(69.1,187.4,94.45);background-color:#45bb5e;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-info{border:2px solid #438aa7;background-color:#438aa7;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-info:hover{border:2px solid rgb(63.65,131.1,158.65);background-color:#40839f;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-warning{border:2px solid #ff9f38;background-color:#ff9f38;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-warning:hover{border:2px solid rgb(255,151.4984924623,40.45);background-color:#ff9728;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-error{border:2px solid #c00d49;background-color:#c00d49;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-error:hover{border:2px solid rgb(182.4,12.35,69.35);background-color:#b60c45;box-shadow:0 0 15px -5px #0006}.abp-toast .abp-toast-icon{display:flex;align-items:center;justify-content:center}.abp-toast .abp-toast-icon .icon{font-size:32px}.abp-toast .abp-toast-content{position:relative;display:flex;align-self:center;flex-direction:column;word-break:break-word;padding-bottom:2px}.abp-toast .abp-toast-content .abp-toast-close-button{position:absolute;top:0;right:0;display:flex;align-items:center;justify-content:center;margin:0;padding:0 5px 0 0;width:25px;height:100%;border:none;border-radius:50%;background:transparent;color:inherit}.abp-toast .abp-toast-content .abp-toast-close-button:focus{outline:none}.abp-toast .abp-toast-content .abp-toast-title{margin:0;padding:0;font-size:1rem;font-weight:600}.abp-toast .abp-toast-content .abp-toast-message{margin:0;padding:0;max-width:240px}\n"], dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "pipe", type: LocalizationPipe, name: "abpLocalization" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ToastComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-toast', imports: [NgClass, LocalizationPipe], template: "<div class=\"abp-toast\" [ngClass]=\"severityClass\" (click)=\"tap()\">\r\n  <div class=\"abp-toast-icon\">\r\n    <i class=\"bi icon\" [ngClass]=\"iconClass\" aria-hidden=\"true\"></i>\r\n  </div>\r\n  <div class=\"abp-toast-content\">\r\n    @if (toast.options?.closable) {\r\n      <button class=\"abp-toast-close-button\" (click)=\"close()\">\r\n        <i class=\"bi bi-x fs-4\" aria-hidden=\"true\"></i>\r\n      </button>\r\n    }\r\n    <div class=\"abp-toast-title\">\r\n      {{ toast.title | abpLocalization: toast.options?.titleLocalizationParams }}\r\n    </div>\r\n    <p\r\n      class=\"abp-toast-message\"\r\n      [innerHTML]=\"toast.message | abpLocalization: toast.options?.messageLocalizationParams\"\r\n    ></p>\r\n  </div>\r\n</div>\r\n", styles: [".abp-toast{display:grid;grid-template-columns:35px 1fr;gap:5px;margin:5px 0;padding:7px;width:350px;-webkit-user-select:none;user-select:none;z-index:9999;color:#fff;border-radius:8px;font-size:14px;box-shadow:0 0 20px #4c577d05;border:2px solid #f0f0f0;background-color:#f0f0f0;color:#000;box-shadow:0 0 10px -5px #0006}.abp-toast:hover{border:2px solid #e4e4e4;background-color:#e4e4e4;box-shadow:0 0 15px -5px #0006}.abp-toast{opacity:1}.abp-toast.abp-toast-success{border:2px solid #4fbf67;background-color:#4fbf67;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-success:hover{border:2px solid rgb(69.1,187.4,94.45);background-color:#45bb5e;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-info{border:2px solid #438aa7;background-color:#438aa7;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-info:hover{border:2px solid rgb(63.65,131.1,158.65);background-color:#40839f;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-warning{border:2px solid #ff9f38;background-color:#ff9f38;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-warning:hover{border:2px solid rgb(255,151.4984924623,40.45);background-color:#ff9728;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-error{border:2px solid #c00d49;background-color:#c00d49;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-error:hover{border:2px solid rgb(182.4,12.35,69.35);background-color:#b60c45;box-shadow:0 0 15px -5px #0006}.abp-toast .abp-toast-icon{display:flex;align-items:center;justify-content:center}.abp-toast .abp-toast-icon .icon{font-size:32px}.abp-toast .abp-toast-content{position:relative;display:flex;align-self:center;flex-direction:column;word-break:break-word;padding-bottom:2px}.abp-toast .abp-toast-content .abp-toast-close-button{position:absolute;top:0;right:0;display:flex;align-items:center;justify-content:center;margin:0;padding:0 5px 0 0;width:25px;height:100%;border:none;border-radius:50%;background:transparent;color:inherit}.abp-toast .abp-toast-content .abp-toast-close-button:focus{outline:none}.abp-toast .abp-toast-content .abp-toast-title{margin:0;padding:0;font-size:1rem;font-weight:600}.abp-toast .abp-toast-content .abp-toast-message{margin:0;padding:0;max-width:240px}\n"] }]
        }], propDecorators: { toast: [{
                type: Input
            }], remove: [{
                type: Output
            }] } });

class ToastContainerComponent {
    constructor() {
        this.toasts = [];
        this.right = '30px';
        this.defaultRight = '30px';
        this.defaultMobileRight = '0';
        this.bottom = '30px';
    }
    ngOnInit() {
        this.setDefaultRight();
        this.toasts$.subscribe(toasts => {
            this.toasts = this.toastKey
                ? toasts.filter(t => {
                    return t.options && t.options.containerKey !== this.toastKey;
                })
                : toasts;
        });
    }
    onWindowResize() {
        this.setDefaultRight();
    }
    setDefaultRight() {
        const screenWidth = window.innerWidth;
        if (screenWidth < 768 && this.right == this.defaultRight) {
            this.right = this.defaultMobileRight;
        }
    }
    trackByFunc(index, toast) {
        if (!toast)
            return null;
        return toast.options?.id;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ToastContainerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.7", type: ToastContainerComponent, isStandalone: true, selector: "abp-toast-container", inputs: { top: "top", right: "right", bottom: "bottom", left: "left", toastKey: "toastKey" }, host: { listeners: { "window:resize": "onWindowResize($event)" } }, ngImport: i0, template: "<div\r\n  class=\"abp-toast-container\"\r\n  [style.top]=\"top || 'auto'\"\r\n  [style.right]=\"right || 'auto'\"\r\n  [style.bottom]=\"bottom || 'auto'\"\r\n  [style.left]=\"left || 'auto'\"\r\n  [style.display]=\"toasts.length ? 'flex' : 'none'\"\r\n  [@toastInOut]=\"toasts.length\"\r\n>\r\n  @for (toast of toasts; track toast.options?.id) {\r\n    <abp-toast\r\n      [toast]=\"toast\"\r\n      (remove)=\"remove($event)\"\r\n    ></abp-toast>\r\n  }\r\n</div>\r\n", styles: [".abp-toast-container{position:fixed;display:flex;flex-direction:column;align-items:center;justify-content:flex-end;min-width:350px;min-height:80px;z-index:1900}.abp-toast-container.new-on-top{flex-direction:column-reverse}@media only screen and (max-width:768px){.abp-toast-container{min-width:100%}}\n"], dependencies: [{ kind: "component", type: ToastComponent, selector: "abp-toast", inputs: ["toast"], outputs: ["remove"] }], animations: [toastInOut] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ToastContainerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-toast-container', animations: [toastInOut], imports: [ToastComponent], template: "<div\r\n  class=\"abp-toast-container\"\r\n  [style.top]=\"top || 'auto'\"\r\n  [style.right]=\"right || 'auto'\"\r\n  [style.bottom]=\"bottom || 'auto'\"\r\n  [style.left]=\"left || 'auto'\"\r\n  [style.display]=\"toasts.length ? 'flex' : 'none'\"\r\n  [@toastInOut]=\"toasts.length\"\r\n>\r\n  @for (toast of toasts; track toast.options?.id) {\r\n    <abp-toast\r\n      [toast]=\"toast\"\r\n      (remove)=\"remove($event)\"\r\n    ></abp-toast>\r\n  }\r\n</div>\r\n", styles: [".abp-toast-container{position:fixed;display:flex;flex-direction:column;align-items:center;justify-content:flex-end;min-width:350px;min-height:80px;z-index:1900}.abp-toast-container.new-on-top{flex-direction:column-reverse}@media only screen and (max-width:768px){.abp-toast-container{min-width:100%}}\n"] }]
        }], propDecorators: { top: [{
                type: Input
            }], right: [{
                type: Input
            }], bottom: [{
                type: Input
            }], left: [{
                type: Input
            }], toastKey: [{
                type: Input
            }], onWindowResize: [{
                type: HostListener,
                args: ['window:resize', ['$event']]
            }] } });

class ToasterService {
    setContainer() {
        this.containerComponentRef = this.contentProjectionService.projectContent(PROJECTION_STRATEGY.AppendComponentToBody(ToastContainerComponent, {
            toasts$: this.toasts$,
            remove: this.remove,
        }));
        this.containerComponentRef.changeDetectorRef.detectChanges();
    }
    constructor() {
        this.toasts$ = new ReplaySubject(1);
        this.lastId = -1;
        this.toasts = [];
        /**
         * Removes the toast with given id.
         * @param id ID of the toast to be removed.
         */
        this.remove = (id) => {
            this.toasts = this.toasts.filter(toast => toast.options?.id !== id);
            this.toasts$.next(this.toasts);
        };
        this.contentProjectionService = inject(ContentProjectionService);
    }
    /**
     * Creates an info toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    info(message, title, options) {
        return this.show(message, title, 'info', options);
    }
    /**
     * Creates a success toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    success(message, title, options) {
        return this.show(message, title, 'success', options);
    }
    /**
     * Creates a warning toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    warn(message, title, options) {
        return this.show(message, title, 'warning', options);
    }
    /**
     * Creates an error toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    error(message, title, options) {
        return this.show(message, title, 'error', options);
    }
    /**
     * Creates a toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param severity Sets color of the toast. "success", "warning" etc.
     * @param options Spesific style or structural options for individual toast
     */
    show(message, title = undefined, severity = 'neutral', options = {}) {
        if (!this.containerComponentRef)
            this.setContainer();
        const id = ++this.lastId;
        this.toasts.push({
            message,
            title,
            severity,
            options: { closable: true, id, ...options },
        });
        this.toasts$.next(this.toasts);
        return id;
    }
    /**
     * Removes all open toasts at once.
     */
    clear(containerKey) {
        this.toasts = !containerKey
            ? []
            : this.toasts.filter(toast => toast.options?.containerKey !== containerKey);
        this.toasts$.next(this.toasts);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ToasterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ToasterService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ToasterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

class UserMenuService extends AbstractMenuService {
    constructor() {
        super(...arguments);
        this.baseClass = UserMenu;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: UserMenuService, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: UserMenuService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: UserMenuService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

const HTTP_ERROR_CONFIG = new InjectionToken('HTTP_ERROR_CONFIG');
/**
  @deprecated use **`CUSTOM_ERROR_HANDLERS`** injection token instead of this, see more info https://abp.io/docs/latest/framework/ui/angular/http-requests
*/
const HTTP_ERROR_HANDLER = new InjectionToken('HTTP_ERROR_HANDLER');
const CUSTOM_ERROR_HANDLERS = new InjectionToken('CUSTOM_ERROR_HANDLERS');

class CreateErrorComponentService {
    constructor() {
        this.document = inject(DOCUMENT);
        this.rendererFactory = inject(RendererFactory2);
        this.routerEvents = inject(RouterEvents);
        this.injector = inject(Injector);
        this.envInjector = inject(EnvironmentInjector);
        this.httpErrorConfig = inject(HTTP_ERROR_CONFIG);
        this.componentRef = null;
        this.listenToRouterDataResolved();
    }
    listenToRouterDataResolved() {
        this.routerEvents
            .getEvents(ResolveEnd)
            .pipe(filter(() => !!this.componentRef))
            .subscribe(() => {
            this.componentRef?.destroy();
            this.componentRef = null;
        });
    }
    getErrorHostElement() {
        return this.document.body;
    }
    isCloseIconHidden() {
        return !!this.httpErrorConfig?.errorScreen?.hideCloseIcon;
    }
    canCreateCustomError(status) {
        const { component, forWhichErrors } = this.httpErrorConfig?.errorScreen || {};
        if (!component || !forWhichErrors) {
            return false;
        }
        return forWhichErrors.indexOf(status) > -1;
    }
    execute(instance) {
        const renderer = this.rendererFactory.createRenderer(null, null);
        const hostElement = this.getErrorHostElement();
        const host = renderer.selectRootElement(hostElement, true);
        this.componentRef = createComponent(HttpErrorWrapperComponent, {
            environmentInjector: this.envInjector,
        });
        for (const key in instance) {
            /* istanbul ignore else */
            if (Object.prototype.hasOwnProperty.call(this.componentRef.instance, key)) {
                this.componentRef.instance[key] = instance[key];
            }
        }
        this.componentRef.instance.hideCloseIcon = this.isCloseIconHidden();
        const appRef = this.injector.get(ApplicationRef);
        if (this.canCreateCustomError(instance.status)) {
            this.componentRef.instance.appRef = appRef;
            this.componentRef.instance.environmentInjector = this.envInjector;
            this.componentRef.instance.customComponent = this.httpErrorConfig.errorScreen?.component;
        }
        appRef.attachView(this.componentRef.hostView);
        renderer.appendChild(host, this.componentRef.hostView.rootNodes[0]);
        const destroy$ = new Subject();
        this.componentRef.instance.destroy$ = destroy$;
        destroy$.subscribe(() => {
            this.componentRef?.destroy();
            this.componentRef = null;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CreateErrorComponentService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CreateErrorComponentService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CreateErrorComponentService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });

const DEFAULT_ERROR_MESSAGES = {
    defaultError: {
        title: 'An error has occurred!',
        details: 'Error detail not sent by server.',
    },
    defaultError401: {
        title: 'You are not authenticated!',
        details: 'You should be authenticated (sign in) in order to perform this operation.',
    },
    defaultError403: {
        title: 'You are not authorized!',
        details: 'You are not allowed to perform this operation.',
    },
    defaultError404: {
        title: 'Resource not found!',
        details: 'The resource requested could not found on the server.',
    },
    defaultError500: {
        title: 'Internal server error',
        details: 'Error detail not sent by server.',
    },
};
const DEFAULT_ERROR_LOCALIZATIONS = {
    defaultError: {
        title: 'AbpUi::DefaultErrorMessage',
        details: 'AbpUi::DefaultErrorMessageDetail',
    },
    defaultError401: {
        title: 'AbpUi::DefaultErrorMessage401',
        details: 'AbpUi::DefaultErrorMessage401Detail',
    },
    defaultError403: {
        title: 'AbpUi::DefaultErrorMessage403',
        details: 'AbpUi::DefaultErrorMessage403Detail',
    },
    defaultError404: {
        title: 'AbpUi::DefaultErrorMessage404',
        details: 'AbpUi::DefaultErrorMessage404Detail',
    },
    defaultError500: {
        title: 'AbpUi::500Message',
        details: 'AbpUi::DefaultErrorMessage',
    },
};
const CUSTOM_HTTP_ERROR_HANDLER_PRIORITY = Object.freeze({
    veryLow: -99,
    low: -9,
    normal: 0,
    high: 9,
    veryHigh: 99,
});
const HTTP_ERROR_STATUS = {
    '401': 'AbpUi::401Message',
    '403': 'AbpUi::403Message',
    '404': 'AbpUi::404Message',
    '500': 'AbpUi::500Message',
};
const HTTP_ERROR_DETAIL = {
    '401': 'AbpUi::DefaultErrorMessage401Detail',
    '403': 'AbpUi::DefaultErrorMessage403Detail',
    '404': 'AbpUi::DefaultErrorMessage404Detail',
    '500': 'AbpUi::DefaultErrorMessage',
};

function getErrorFromRequestBody(body) {
    let message;
    let title;
    if (body.details) {
        message = body.details;
        title = body.message;
    }
    else if (body.message) {
        title = {
            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
        };
        message = body.message;
    }
    else {
        message = {
            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
        };
        title = '';
    }
    return { message, title };
}

class AbpFormatErrorHandlerService {
    constructor() {
        this.priority = CUSTOM_HTTP_ERROR_HANDLER_PRIORITY.high;
        this.confirmationService = inject(ConfirmationService);
        this.authService = inject(AuthService);
        this.error = undefined;
    }
    navigateToLogin() {
        return this.authService.navigateToLogin();
    }
    canHandle(error) {
        if (error instanceof HttpErrorResponse && error.headers.get('_AbpErrorFormat')) {
            this.error = error;
            return true;
        }
        return false;
    }
    execute() {
        const { message, title } = getErrorFromRequestBody(this.error?.error?.error);
        this.confirmationService
            .error(message, title, {
            hideCancelBtn: true,
            yesText: 'AbpAccount::Close',
        })
            .subscribe(() => {
            if (this.error?.status === 401) {
                this.navigateToLogin();
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpFormatErrorHandlerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpFormatErrorHandlerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpFormatErrorHandlerService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class TenantResolveErrorHandlerService {
    constructor() {
        this.sessionService = inject(SessionStateService);
        this.priority = CUSTOM_HTTP_ERROR_HANDLER_PRIORITY.high;
        this.authService = inject(AuthService);
    }
    isTenantResolveError(error) {
        return error instanceof HttpErrorResponse && !!error.headers.get('Abp-Tenant-Resolve-Error');
    }
    canHandle(error) {
        return this.isTenantResolveError(error);
    }
    execute() {
        this.sessionService.setTenant(null);
        this.authService.logout().subscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TenantResolveErrorHandlerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TenantResolveErrorHandlerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: TenantResolveErrorHandlerService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class StatusCodeErrorHandlerService {
    constructor() {
        this.confirmationService = inject(ConfirmationService);
        this.createErrorComponentService = inject(CreateErrorComponentService);
        this.authService = inject(AuthService);
        this.handledStatusCodes = [401, 403, 404, 500];
        this.priority = CUSTOM_HTTP_ERROR_HANDLER_PRIORITY.normal;
    }
    navigateToLogin() {
        this.authService.navigateToLogin();
    }
    showConfirmation(message, title) {
        return this.confirmationService.error(message, title, {
            hideCancelBtn: true,
            yesText: 'AbpAccount::Close',
        });
    }
    showPage() {
        const key = `defaultError${this.status}`;
        const shouldRemoveDetail = [401, 404].indexOf(this.status) > -1;
        const instance = {
            title: {
                key: DEFAULT_ERROR_LOCALIZATIONS[key]?.title,
                defaultValue: DEFAULT_ERROR_MESSAGES[key]?.title,
            },
            details: {
                key: DEFAULT_ERROR_LOCALIZATIONS[key]?.details,
                defaultValue: DEFAULT_ERROR_MESSAGES[key]?.details,
            },
            status: this.status,
        };
        if (shouldRemoveDetail) {
            delete instance.details;
        }
        this.createErrorComponentService.execute(instance);
    }
    canHandle(error) {
        this.status = error?.status || 0;
        return this.handledStatusCodes.indexOf(this.status) > -1;
    }
    execute() {
        const key = `defaultError${this.status}`;
        const title = {
            key: DEFAULT_ERROR_LOCALIZATIONS[key]?.title,
            defaultValue: DEFAULT_ERROR_MESSAGES[key]?.title,
        };
        const message = {
            key: DEFAULT_ERROR_LOCALIZATIONS[key]?.details,
            defaultValue: DEFAULT_ERROR_MESSAGES[key]?.details,
        };
        const canCreateCustomError = this.createErrorComponentService.canCreateCustomError(this.status);
        switch (this.status) {
            case 401:
            case 404:
                if (canCreateCustomError) {
                    this.showPage();
                    break;
                }
                if (this.status === 401) {
                    this.authService.navigateToLogin();
                    break;
                }
                this.showConfirmation(title, message).subscribe();
                break;
            case 403:
            case 500:
                this.showPage();
                break;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: StatusCodeErrorHandlerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: StatusCodeErrorHandlerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: StatusCodeErrorHandlerService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class UnknownStatusCodeErrorHandlerService {
    constructor() {
        this.priority = CUSTOM_HTTP_ERROR_HANDLER_PRIORITY.normal;
        this.statusText = 'Unknown Error';
        this.message = '';
        this.createErrorComponentService = inject(CreateErrorComponentService);
    }
    canHandle(error) {
        if (error && error.status === 0 && error.statusText === this.statusText) {
            this.message = error.message;
            return true;
        }
        return false;
    }
    execute() {
        this.createErrorComponentService.execute({
            title: {
                key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
                defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
            },
            details: this.message,
            isHomeShow: false,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: UnknownStatusCodeErrorHandlerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: UnknownStatusCodeErrorHandlerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: UnknownStatusCodeErrorHandlerService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

var styles = `
.is-invalid .form-control {
  border-color: #dc3545;
  border-style: solid !important;
  padding-right: calc(1.5em + .75rem);
  background-image: url(data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e);
  background-repeat: no-repeat;
  background-position: right calc(.375em + .1875rem) center;
  background-size: calc(.75em + .375rem) calc(.75em + .375rem);
}

.is-invalid .invalid-feedback,
.is-invalid + * .invalid-feedback {
  display: block;
}

.data-tables-filter {
  text-align: right;
}

[dir=rtl] .data-tables-filter {
  text-align: left;
}

.pointer {
  cursor: pointer;
}

.navbar .dropdown-submenu a::after {
  transform: rotate(-90deg);
  position: absolute;
  right: 16px;
  top: 18px;
}

.navbar .dropdown-menu {
  min-width: 215px;
}

.datatable-scroll {
  margin-bottom: 5px !important;
  width: unset !important;
}

.ui-table-scrollable-body::-webkit-scrollbar {
  height: 5px !important;
  width: 5px !important;
}

.ui-table-scrollable-body::-webkit-scrollbar-track {
  background: #ddd;
}

.ui-table-scrollable-body::-webkit-scrollbar-thumb {
  background: #8a8686;
}

.abp-ellipsis-inline {
  display: inline-block;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.abp-ellipsis {
  overflow: hidden !important;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.ui-widget-overlay {
  z-index: 1000;
}

.color-white {
  color: #FFF !important;
}

.custom-checkbox > label {
  cursor: pointer;
}

/* <animations */

.fade-in-top {
  animation: fadeInTop 0.2s ease-in-out;
}

.fade-out-top {
  animation: fadeOutTop 0.2s ease-in-out;
}

.abp-collapsed-height {
  -moz-transition: max-height linear 0.35s;
  -ms-transition: max-height linear 0.35s;
  -o-transition: max-height linear 0.35s;
  -webkit-transition: max-height linear 0.35s;
  overflow:hidden;
  transition:max-height 0.35s linear;
  height:auto;
  max-height: 0;
}

.abp-mh-25 {
  max-height: 25vh;
}

.abp-mh-50 {
  transition:max-height 0.65s linear;
  max-height: 50vh;
}

.abp-mh-75 {
  transition:max-height 0.85s linear;
  max-height: 75vh;
}

.abp-mh-100 {
  transition:max-height 1s linear;
  max-height: 100vh;
}

[class^="sorting"] {
  opacity: .3;
  cursor: pointer;
}
[class^="sorting"]:before {
  right: 0.5rem;
  content: "↑";
}
[class^="sorting"]:after {
  right: 0.5rem;
  content: "↓";
}

.sorting_desc {
  opacity: 1;
}
.sorting_desc:before {
  opacity: .3;
}

.sorting_asc {
  opacity: 1;
}
.sorting_asc:after {
  opacity: .3;
}
.ngx-datatable.material {
  box-shadow: none;
}
ngb-typeahead-window, ngb-typeahead-window.dropdown-menu {
  max-height: 25em;
  overflow-y: scroll !important;
  z-index: 1050;
}

.abp-modal-header {
  word-break: break-word;
}


@keyframes fadeInTop {
  from {
    transform: translateY(-5px);
    opacity: 0;
  }

  to {
    transform: translateY(0px);
    opacity: 1;
  }
}

@keyframes fadeOutTop {
  to {
    transform: translateY(-5px);
    opacity: 0;
  }
}

/* </animations */
.ngb-dp-body {
  z-index: 1055 !important;
}
`;

const THEME_SHARED_APPEND_CONTENT = new InjectionToken('THEME_SHARED_APPEND_CONTENT', {
    providedIn: 'root',
    factory: () => {
        const domInsertion = inject(DomInsertionService);
        domInsertion.insertContent(CONTENT_STRATEGY.AppendStyleToHead(styles));
    },
});

const defaultNgxDatatableMessages = {
    emptyMessage: 'AbpUi::NoDataAvailableInDatatable',
    errorMessage: 'AbpUi::ErrorLoadingDatatable',
    totalMessage: 'AbpUi::Total',
    selectedMessage: 'AbpUi::Selected',
};
const NGX_DATATABLE_MESSAGES = new InjectionToken('NGX_DATATABLE_MESSAGES');

const SUPPRESS_UNSAVED_CHANGES_WARNING = new InjectionToken('SUPPRESS_UNSAVED_CHANGES_WARNING');

const LOGO_URL_TOKEN = new InjectionToken('LOGO_URL_TOKEN');
const LOGO_APP_NAME_TOKEN = new InjectionToken('LOGO_APP_NAME_TOKEN');

class RouterErrorHandlerService {
    constructor() {
        this.routerEvents = inject(RouterEvents);
        this.httpErrorConfig = inject(HTTP_ERROR_CONFIG);
        this.createErrorComponentService = inject(CreateErrorComponentService);
        this.filterRouteErrors = (navigationError) => {
            if (!this.httpErrorConfig?.skipHandledErrorCodes) {
                return true;
            }
            return (navigationError.error?.message?.indexOf('Cannot match') > -1 &&
                this.httpErrorConfig.skipHandledErrorCodes.findIndex(code => code === 404) < 0);
        };
    }
    listen() {
        this.routerEvents
            .getNavigationEvents('Error')
            .pipe(filter(this.filterRouteErrors))
            .subscribe(() => this.show404Page());
    }
    show404Page() {
        const instance = {
            title: {
                key: DEFAULT_ERROR_LOCALIZATIONS.defaultError404.title,
                defaultValue: DEFAULT_ERROR_MESSAGES.defaultError404.title,
            },
            status: 404,
        };
        this.createErrorComponentService.execute(instance);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RouterErrorHandlerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RouterErrorHandlerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: RouterErrorHandlerService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class AbpAuthenticationErrorHandler {
    constructor() {
        this.priority = CUSTOM_HTTP_ERROR_HANDLER_PRIORITY.veryHigh;
        this.authService = inject(AuthService);
        this.configStateService = inject(ConfigStateService);
    }
    canHandle(error) {
        return error instanceof HttpErrorResponse && error.status === 401;
    }
    execute() {
        this.configStateService.refreshAppState().subscribe(({ currentUser }) => {
            if (!currentUser.isAuthenticated) {
                this.authService.logout({ noRedirectToLogoutUrl: true });
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpAuthenticationErrorHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpAuthenticationErrorHandler, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpAuthenticationErrorHandler, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class ModalRefService {
    constructor() {
        this.modalRefs = [];
    }
    register(modal) {
        this.modalRefs.push(modal);
    }
    unregister(modal) {
        const index = this.modalRefs.indexOf(modal);
        if (index > -1) {
            this.modalRefs.splice(index, 1);
        }
    }
    dismissAll(mode) {
        this.modalRefs.forEach(modal => modal.dismiss(mode));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ModalRefService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ModalRefService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ModalRefService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class ModalComponent {
    get modalWindowRef() {
        return this.document.querySelector(`ngb-modal-window.${this.modalIdentifier}`);
    }
    get isFormDirty() {
        return Boolean(this.modalWindowRef?.querySelector('.ng-dirty'));
    }
    constructor() {
        this.confirmationService = inject(ConfirmationService);
        this.modal = inject(NgbModal);
        this.modalRefService = inject(ModalRefService);
        this.suppressUnsavedChangesWarningToken = inject(SUPPRESS_UNSAVED_CHANGES_WARNING, {
            optional: true,
        });
        this.destroyRef = inject(DestroyRef);
        this.document = inject(DOCUMENT);
        this.visible = model(false);
        this.busy = input(false, {
            transform: (value) => {
                if (this.abpSubmit() && this.abpSubmit() instanceof ButtonComponent) {
                    this.abpSubmit().loading = value;
                }
                return value;
            },
        });
        this.options = input({ keyboard: true });
        this.suppressUnsavedChangesWarning = input(this.suppressUnsavedChangesWarningToken);
        this.modalContent = viewChild('modalContent');
        this.abpHeader = contentChild('abpHeader');
        this.abpBody = contentChild('abpBody');
        this.abpFooter = contentChild('abpFooter');
        this.abpSubmit = contentChild(ButtonComponent, { read: ButtonComponent });
        this.init = output();
        this.appear = output();
        this.disappear = output();
        this.isConfirmationOpen = false;
        this.modalIdentifier = `modal-${uuid()}`;
        effect(() => {
            this.toggle(this.visible());
        });
    }
    ngOnInit() {
        this.modalRefService.register(this);
    }
    dismiss(mode) {
        switch (mode) {
            case 'hard':
                this.visible.set(false);
                break;
            case 'soft':
                this.close();
                break;
            default:
                break;
        }
    }
    toggle(value) {
        this.visible.set(value);
        if (!value) {
            this.modalRef?.dismiss();
            this.disappear.emit();
            return;
        }
        setTimeout(() => this.listen(), 0);
        this.modalRef = this.modal.open(this.modalContent(), {
            size: 'md',
            centered: false,
            keyboard: false,
            scrollable: true,
            beforeDismiss: () => {
                if (!this.visible())
                    return true;
                this.close();
                return !this.visible();
            },
            ...this.options(),
            windowClass: `${this.options().windowClass || ''} ${this.modalIdentifier}`,
        });
        this.appear.emit();
    }
    ngOnDestroy() {
        this.modalRefService.unregister(this);
        this.toggle(false);
    }
    close() {
        if (this.busy())
            return;
        if (this.isFormDirty && !this.suppressUnsavedChangesWarning()) {
            if (this.isConfirmationOpen)
                return;
            this.isConfirmationOpen = true;
            this.confirmationService
                .warn('AbpUi::AreYouSureYouWantToCancelEditingWarningMessage', 'AbpUi::AreYouSure', {
                dismissible: false,
            })
                .subscribe((status) => {
                this.isConfirmationOpen = false;
                if (status === Confirmation.Status.confirm) {
                    this.visible.set(false);
                }
            });
        }
        else {
            this.visible.set(false);
        }
    }
    listen() {
        if (this.modalWindowRef) {
            fromEvent(this.modalWindowRef, 'keyup')
                .pipe(takeUntilDestroyed(this.destroyRef), debounceTime(150), filter((key) => key && key.key === 'Escape' && this.options().keyboard))
                .subscribe(() => this.close());
        }
        fromEvent(window, 'beforeunload')
            .pipe(takeUntilDestroyed(this.destroyRef))
            .subscribe(event => {
            if (this.isFormDirty && !this.suppressUnsavedChangesWarning()) {
                event.preventDefault();
            }
        });
        this.init.emit();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ModalComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.7", type: ModalComponent, isStandalone: true, selector: "abp-modal", inputs: { visible: { classPropertyName: "visible", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null }, busy: { classPropertyName: "busy", publicName: "busy", isSignal: true, isRequired: false, transformFunction: null }, options: { classPropertyName: "options", publicName: "options", isSignal: true, isRequired: false, transformFunction: null }, suppressUnsavedChangesWarning: { classPropertyName: "suppressUnsavedChangesWarning", publicName: "suppressUnsavedChangesWarning", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visible: "visibleChange", init: "init", appear: "appear", disappear: "disappear" }, providers: [SubscriptionService], queries: [{ propertyName: "abpHeader", first: true, predicate: ["abpHeader"], descendants: true, isSignal: true }, { propertyName: "abpBody", first: true, predicate: ["abpBody"], descendants: true, isSignal: true }, { propertyName: "abpFooter", first: true, predicate: ["abpFooter"], descendants: true, isSignal: true }, { propertyName: "abpSubmit", first: true, predicate: ButtonComponent, descendants: true, read: ButtonComponent, isSignal: true }], viewQueries: [{ propertyName: "modalContent", first: true, predicate: ["modalContent"], descendants: true, isSignal: true }], ngImport: i0, template: "<ng-content></ng-content>\r\n\r\n<ng-template #modalContent let-modal>\r\n  @if (abpHeader()) {\r\n    <div id=\"abp-modal-header\" class=\"modal-header abp-modal-header\">\r\n      <ng-container *ngTemplateOutlet=\"abpHeader()\"></ng-container>\r\n      \u200B\r\n      <button\r\n        id=\"abp-modal-close-button\"\r\n        type=\"button\"\r\n        class=\"btn-sm btn-close\"\r\n        aria-label=\"Close\"\r\n        (click)=\"modal.dismiss()\"\r\n      ></button>\r\n    </div>\r\n  }\r\n  @if (abpBody()) {\r\n    <div id=\"abp-modal-body\" class=\"modal-body\">\r\n      <ng-container *ngTemplateOutlet=\"abpBody()\"></ng-container>\r\n    </div>\r\n  }\r\n  @if (abpFooter()) {\r\n    <div id=\"abp-modal-footer\" class=\"modal-footer\">\r\n      <ng-container *ngTemplateOutlet=\"abpFooter()\"></ng-container>\r\n    </div>\r\n  }\r\n</ng-template>\r\n", styles: [".modal.show{display:block!important}.modal-backdrop{opacity:.8}.modal::-webkit-scrollbar{width:7px}.modal::-webkit-scrollbar-track{background:#ddd}.modal::-webkit-scrollbar-thumb{background:#8a8686}.modal-dialog{z-index:1050}\n"], dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ModalComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-modal', providers: [SubscriptionService], imports: [NgTemplateOutlet], template: "<ng-content></ng-content>\r\n\r\n<ng-template #modalContent let-modal>\r\n  @if (abpHeader()) {\r\n    <div id=\"abp-modal-header\" class=\"modal-header abp-modal-header\">\r\n      <ng-container *ngTemplateOutlet=\"abpHeader()\"></ng-container>\r\n      \u200B\r\n      <button\r\n        id=\"abp-modal-close-button\"\r\n        type=\"button\"\r\n        class=\"btn-sm btn-close\"\r\n        aria-label=\"Close\"\r\n        (click)=\"modal.dismiss()\"\r\n      ></button>\r\n    </div>\r\n  }\r\n  @if (abpBody()) {\r\n    <div id=\"abp-modal-body\" class=\"modal-body\">\r\n      <ng-container *ngTemplateOutlet=\"abpBody()\"></ng-container>\r\n    </div>\r\n  }\r\n  @if (abpFooter()) {\r\n    <div id=\"abp-modal-footer\" class=\"modal-footer\">\r\n      <ng-container *ngTemplateOutlet=\"abpFooter()\"></ng-container>\r\n    </div>\r\n  }\r\n</ng-template>\r\n", styles: [".modal.show{display:block!important}.modal-backdrop{opacity:.8}.modal::-webkit-scrollbar{width:7px}.modal::-webkit-scrollbar-track{background:#ddd}.modal::-webkit-scrollbar-thumb{background:#8a8686}.modal-dialog{z-index:1050}\n"] }]
        }], ctorParameters: () => [] });

class ModalCloseDirective {
    constructor() {
        this.modal = inject(ModalComponent, { optional: true });
        const modal = this.modal;
        if (!modal) {
            console.error('Please use abpClose within an abp-modal');
        }
    }
    onClick() {
        this.modal?.close();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ModalCloseDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: ModalCloseDirective, isStandalone: true, selector: "[abpClose]", host: { listeners: { "click": "onClick()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ModalCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpClose]',
                }]
        }], ctorParameters: () => [], propDecorators: { onClick: [{
                type: HostListener,
                args: ['click']
            }] } });

/**
 * @deprecated use ShowPasswordDirective directive
 * https://abp.io/docs/latest/framework/ui/angular/show-password-directive
 */
class PasswordComponent extends AbstractNgModelComponent {
    toggleFieldTextType() {
        this.fieldTextType = !this.fieldTextType;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PasswordComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: PasswordComponent, isStandalone: true, selector: "abp-password", inputs: { inputId: "inputId", formControlName: "formControlName" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => PasswordComponent),
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0, template: "<div class=\"input-group\" validationTarget>\r\n  <input\r\n    [type]=\"fieldTextType ? 'text' : 'password'\"\r\n    class=\"form-control\"\r\n    [id]=\"inputId\"\r\n    [(ngModel)]=\"value\"\r\n  />\r\n\r\n  <button class=\"btn btn-secondary\" type=\"button\" (click)=\"toggleFieldTextType()\">\r\n    <i\r\n      class=\"fa\"\r\n      aria-hidden=\"true\"\r\n      [ngClass]=\"{\r\n        'fa-eye-slash': !fieldTextType,\r\n        'fa-eye': fieldTextType\r\n      }\"\r\n    ></i>\r\n  </button>\r\n</div>\r\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i1$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i1$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "ngmodule", type: NgxValidateCoreModule }, { kind: "directive", type: i2.ValidationTargetDirective, selector: "[validationTarget]", exportAs: ["validationTarget"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: PasswordComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-password', imports: [NgClass, FormsModule, NgxValidateCoreModule], providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => PasswordComponent),
                            multi: true,
                        },
                    ], template: "<div class=\"input-group\" validationTarget>\r\n  <input\r\n    [type]=\"fieldTextType ? 'text' : 'password'\"\r\n    class=\"form-control\"\r\n    [id]=\"inputId\"\r\n    [(ngModel)]=\"value\"\r\n  />\r\n\r\n  <button class=\"btn btn-secondary\" type=\"button\" (click)=\"toggleFieldTextType()\">\r\n    <i\r\n      class=\"fa\"\r\n      aria-hidden=\"true\"\r\n      [ngClass]=\"{\r\n        'fa-eye-slash': !fieldTextType,\r\n        'fa-eye': fieldTextType\r\n      }\"\r\n    ></i>\r\n  </button>\r\n</div>\r\n" }]
        }], propDecorators: { inputId: [{
                type: Input
            }], formControlName: [{
                type: Input
            }] } });

class CardBodyComponent {
    constructor() {
        this.componentClass = 'card-body';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: CardBodyComponent, isStandalone: true, selector: "abp-card-body", inputs: { cardBodyClass: "cardBodyClass", cardBodyStyle: "cardBodyStyle" }, host: { properties: { "class": "this.componentClass" } }, ngImport: i0, template: ` <div [ngClass]="cardBodyClass" [ngStyle]="cardBodyStyle">
    <ng-content></ng-content>
  </div>`, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardBodyComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-card-body',
                    template: ` <div [ngClass]="cardBodyClass" [ngStyle]="cardBodyStyle">
    <ng-content></ng-content>
  </div>`,
                    imports: [NgClass, NgStyle],
                }]
        }], propDecorators: { componentClass: [{
                type: HostBinding,
                args: ['class']
            }], cardBodyClass: [{
                type: Input
            }], cardBodyStyle: [{
                type: Input
            }] } });

class CardComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: CardComponent, isStandalone: true, selector: "abp-card", inputs: { cardClass: "cardClass", cardStyle: "cardStyle" }, ngImport: i0, template: ` <div class="card" [ngClass]="cardClass" [ngStyle]="cardStyle">
    <ng-content></ng-content>
  </div>`, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-card',
                    template: ` <div class="card" [ngClass]="cardClass" [ngStyle]="cardStyle">
    <ng-content></ng-content>
  </div>`,
                    imports: [NgClass, NgStyle],
                }]
        }], propDecorators: { cardClass: [{
                type: Input
            }], cardStyle: [{
                type: Input
            }] } });

class CardHeaderComponent {
    constructor() {
        this.componentClass = 'card-header';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: CardHeaderComponent, isStandalone: true, selector: "abp-card-header", inputs: { cardHeaderClass: "cardHeaderClass", cardHeaderStyle: "cardHeaderStyle" }, host: { properties: { "class": "this.componentClass" } }, ngImport: i0, template: `
    <div [ngClass]="cardHeaderClass" [ngStyle]="cardHeaderStyle">
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardHeaderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-card-header', template: `
    <div [ngClass]="cardHeaderClass" [ngStyle]="cardHeaderStyle">
      <ng-content></ng-content>
    </div>
  `, imports: [NgClass, NgStyle] }]
        }], propDecorators: { componentClass: [{
                type: HostBinding,
                args: ['class']
            }], cardHeaderClass: [{
                type: Input
            }], cardHeaderStyle: [{
                type: Input
            }] } });

class CardFooterComponent {
    constructor() {
        this.componentClass = 'card-footer';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardFooterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: CardFooterComponent, isStandalone: true, selector: "abp-card-footer", inputs: { cardFooterStyle: "cardFooterStyle", cardFooterClass: "cardFooterClass" }, host: { properties: { "class": "this.componentClass" } }, ngImport: i0, template: `
    <div [ngStyle]="cardFooterStyle" [ngClass]="cardFooterClass">
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardFooterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-card-footer', template: `
    <div [ngStyle]="cardFooterStyle" [ngClass]="cardFooterClass">
      <ng-content></ng-content>
    </div>
  `, imports: [NgClass, NgStyle] }]
        }], propDecorators: { componentClass: [{
                type: HostBinding,
                args: ['class']
            }], cardFooterStyle: [{
                type: Input
            }], cardFooterClass: [{
                type: Input
            }] } });

class CardTitleDirective {
    constructor() {
        this.directiveClass = 'card-title';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardTitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: CardTitleDirective, isStandalone: true, selector: "abp-card-title, [abp-card-title], [abpCardTitle]", host: { properties: { "class": "this.directiveClass" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `abp-card-title, [abp-card-title], [abpCardTitle]`,
                }]
        }], propDecorators: { directiveClass: [{
                type: HostBinding,
                args: ['class']
            }] } });

class CardSubtitleDirective {
    constructor() {
        this.directiveClass = 'card-subtitle';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardSubtitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: CardSubtitleDirective, isStandalone: true, selector: "abp-card-subtitle, [abp-card-subtitle], [abpCardSubtitle]", host: { properties: { "class": "this.directiveClass" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardSubtitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `abp-card-subtitle, [abp-card-subtitle], [abpCardSubtitle]`,
                }]
        }], propDecorators: { directiveClass: [{
                type: HostBinding,
                args: ['class']
            }] } });

class CardImgTopDirective {
    constructor() {
        this.directiveClass = 'card-img-top';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardImgTopDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: CardImgTopDirective, isStandalone: true, selector: "abp-card-img-top, [abp-card-img-top], [abpCardImgTop]", host: { properties: { "class": "this.directiveClass" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardImgTopDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `abp-card-img-top, [abp-card-img-top], [abpCardImgTop]`,
                }]
        }], propDecorators: { directiveClass: [{
                type: HostBinding,
                args: ['class']
            }] } });

class CardHeaderDirective {
    constructor() {
        this.directiveClass = 'card-header';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardHeaderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: CardHeaderDirective, isStandalone: true, selector: "abp-card-header, [abp-card-header], [abpCardHeader]", host: { properties: { "class": "this.directiveClass" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardHeaderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `abp-card-header, [abp-card-header], [abpCardHeader]`,
                }]
        }], propDecorators: { directiveClass: [{
                type: HostBinding,
                args: ['class']
            }] } });

const CARD_DIRECTIVES = [
    CardTitleDirective,
    CardSubtitleDirective,
    CardImgTopDirective,
    CardHeaderDirective,
];
const CARD_COMPONENTS = [
    CardComponent,
    CardBodyComponent,
    CardHeaderComponent,
    CardFooterComponent,
];
class CardModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: CardModule, imports: [CardComponent,
            CardBodyComponent,
            CardHeaderComponent,
            CardFooterComponent, CardTitleDirective,
            CardSubtitleDirective,
            CardImgTopDirective,
            CardHeaderDirective], exports: [CardComponent,
            CardBodyComponent,
            CardHeaderComponent,
            CardFooterComponent, CardTitleDirective,
            CardSubtitleDirective,
            CardImgTopDirective,
            CardHeaderDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: CardModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [],
                    imports: [...CARD_COMPONENTS, ...CARD_DIRECTIVES],
                    exports: [...CARD_COMPONENTS, ...CARD_DIRECTIVES],
                }]
        }] });

class FormCheckboxComponent extends AbstractNgModelComponent {
    constructor() {
        super(...arguments);
        this.labelClass = 'form-check-label';
        this.checkboxClass = 'form-check-input';
        this.checkboxReadonly = false;
        this.checkboxBlur = new EventEmitter();
        this.checkboxFocus = new EventEmitter();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: FormCheckboxComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.7", type: FormCheckboxComponent, isStandalone: true, selector: "abp-checkbox", inputs: { label: "label", labelClass: "labelClass", checkboxId: "checkboxId", checkboxStyle: "checkboxStyle", checkboxClass: "checkboxClass", checkboxReadonly: "checkboxReadonly" }, outputs: { checkboxBlur: "checkboxBlur", checkboxFocus: "checkboxFocus" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => FormCheckboxComponent),
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0, template: `
    <div class="mb-3">
      <input
        type="checkbox"
        [(ngModel)]="value"
        [id]="checkboxId"
        [readonly]="checkboxReadonly"
        [ngClass]="checkboxClass"
        [ngStyle]="checkboxStyle"
        (blur)="checkboxBlur.next()"
        (focus)="checkboxFocus.next()"
      />
      @if (label) {
        <label [ngClass]="labelClass" [for]="checkboxId">
          {{ label | abpLocalization }}
        </label>
      }
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i1$1.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i1$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "pipe", type: LocalizationPipe, name: "abpLocalization" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: FormCheckboxComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-checkbox',
                    template: `
    <div class="mb-3">
      <input
        type="checkbox"
        [(ngModel)]="value"
        [id]="checkboxId"
        [readonly]="checkboxReadonly"
        [ngClass]="checkboxClass"
        [ngStyle]="checkboxStyle"
        (blur)="checkboxBlur.next()"
        (focus)="checkboxFocus.next()"
      />
      @if (label) {
        <label [ngClass]="labelClass" [for]="checkboxId">
          {{ label | abpLocalization }}
        </label>
      }
    </div>
  `,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FormCheckboxComponent),
                            multi: true,
                        },
                    ],
                    imports: [NgClass, NgStyle, FormsModule, LocalizationPipe],
                }]
        }], propDecorators: { label: [{
                type: Input
            }], labelClass: [{
                type: Input
            }], checkboxId: [{
                type: Input
            }], checkboxStyle: [{
                type: Input
            }], checkboxClass: [{
                type: Input
            }], checkboxReadonly: [{
                type: Input
            }], checkboxBlur: [{
                type: Output
            }], checkboxFocus: [{
                type: Output
            }] } });

class FormInputComponent extends AbstractNgModelComponent {
    constructor() {
        super(...arguments);
        this.inputReadonly = false;
        this.label = '';
        this.labelClass = 'form-label';
        this.inputPlaceholder = '';
        this.inputClass = 'form-control';
        this.formBlur = new EventEmitter();
        this.formFocus = new EventEmitter();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: FormInputComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.7", type: FormInputComponent, isStandalone: true, selector: "abp-form-input", inputs: { inputId: "inputId", inputReadonly: "inputReadonly", label: "label", labelClass: "labelClass", inputPlaceholder: "inputPlaceholder", inputStyle: "inputStyle", inputClass: "inputClass" }, outputs: { formBlur: "formBlur", formFocus: "formFocus" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => FormInputComponent),
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0, template: `
    <div class="mb-3">
      @if (label) {
        <label [ngClass]="labelClass" [for]="inputId">
          {{ label | abpLocalization }}
        </label>
      }
      <input
        type="text"
        [id]="inputId"
        [placeholder]="inputPlaceholder"
        [readonly]="inputReadonly"
        [ngClass]="inputClass"
        [ngStyle]="inputStyle"
        (blur)="formBlur.next()"
        (focus)="formFocus.next()"
        [(ngModel)]="value"
      />
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "pipe", type: LocalizationPipe, name: "abpLocalization" }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i1$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i1$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: FormInputComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-form-input',
                    template: `
    <div class="mb-3">
      @if (label) {
        <label [ngClass]="labelClass" [for]="inputId">
          {{ label | abpLocalization }}
        </label>
      }
      <input
        type="text"
        [id]="inputId"
        [placeholder]="inputPlaceholder"
        [readonly]="inputReadonly"
        [ngClass]="inputClass"
        [ngStyle]="inputStyle"
        (blur)="formBlur.next()"
        (focus)="formFocus.next()"
        [(ngModel)]="value"
      />
    </div>
  `,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FormInputComponent),
                            multi: true,
                        },
                    ],
                    imports: [NgClass, NgStyle, LocalizationPipe, FormsModule],
                }]
        }], propDecorators: { inputId: [{
                type: Input
            }], inputReadonly: [{
                type: Input
            }], label: [{
                type: Input
            }], labelClass: [{
                type: Input
            }], inputPlaceholder: [{
                type: Input
            }], inputStyle: [{
                type: Input
            }], inputClass: [{
                type: Input
            }], formBlur: [{
                type: Output
            }], formFocus: [{
                type: Output
            }] } });

class InternetConnectionStatusComponent {
    constructor() {
        this.internetConnectionService = inject(InternetConnectionService);
        this.isOnline = this.internetConnectionService.networkStatus;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: InternetConnectionStatusComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.7", type: InternetConnectionStatusComponent, isStandalone: true, selector: "abp-internet-status", ngImport: i0, template: `
    @if (!isOnline()) {
      <div class="status-icon">
        <i
          ngbTooltip="{{ 'AbpUi::InternetConnectionInfo' | abpLocalization }}"
          container="body"
          placement="left-top"
          class="fa fa-wifi text-blinking blink"
        >
        </i>
      </div>
    }
  `, isInline: true, styles: [".blink{animation:blinker .9s cubic-bezier(.5,0,1,1) infinite alternate}@keyframes blinker{0%{color:#c1c1c1}70%{color:#fa2379}to{color:#fa2379}}.text-blinking{font-size:30px}.status-icon{position:fixed;z-index:999999;top:50%;left:50%;width:30px;text-align:center;margin-left:-15px;margin-top:-15px;translate:transform(-50%,-50%)}\n"], dependencies: [{ kind: "pipe", type: LocalizationPipe, name: "abpLocalization" }, { kind: "directive", type: NgbTooltip, selector: "[ngbTooltip]", inputs: ["animation", "autoClose", "placement", "popperOptions", "triggers", "positionTarget", "container", "disableTooltip", "tooltipClass", "tooltipContext", "openDelay", "closeDelay", "ngbTooltip"], outputs: ["shown", "hidden"], exportAs: ["ngbTooltip"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: InternetConnectionStatusComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-internet-status', imports: [LocalizationPipe, NgbTooltip], template: `
    @if (!isOnline()) {
      <div class="status-icon">
        <i
          ngbTooltip="{{ 'AbpUi::InternetConnectionInfo' | abpLocalization }}"
          container="body"
          placement="left-top"
          class="fa fa-wifi text-blinking blink"
        >
        </i>
      </div>
    }
  `, styles: [".blink{animation:blinker .9s cubic-bezier(.5,0,1,1) infinite alternate}@keyframes blinker{0%{color:#c1c1c1}70%{color:#fa2379}to{color:#fa2379}}.text-blinking{font-size:30px}.status-icon{position:fixed;z-index:999999;top:50%;left:50%;width:30px;text-align:center;margin-left:-15px;margin-top:-15px;translate:transform(-50%,-50%)}\n"] }]
        }] });

class SpinnerComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SpinnerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.7", type: SpinnerComponent, isStandalone: true, selector: "abp-spinner", ngImport: i0, template: `
    <div class="d-flex justify-content-center align-items-center border-top" style="height: 62px">
      <div class="spinner-border" role="status" id="loading">
        <span class="visually-hidden">Loading...</span>
      </div>
    </div>
  `, isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: SpinnerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-spinner',
                    template: `
    <div class="d-flex justify-content-center align-items-center border-top" style="height: 62px">
      <div class="spinner-border" role="status" id="loading">
        <span class="visually-hidden">Loading...</span>
      </div>
    </div>
  `,
                }]
        }] });

class EllipsisDirective {
    constructor() {
        this.cdRef = inject(ChangeDetectorRef);
        this.elRef = inject(ElementRef);
        this.enabled = true;
    }
    get inlineClass() {
        return this.enabled && this.width;
    }
    get class() {
        return this.enabled && !this.width;
    }
    get maxWidth() {
        return this.enabled && this.width ? this.width || '170px' : undefined;
    }
    ngAfterViewInit() {
        this.title = this.title || this.elRef.nativeElement.innerText;
        this.cdRef.detectChanges();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: EllipsisDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: EllipsisDirective, isStandalone: true, selector: "[abpEllipsis]", inputs: { width: ["abpEllipsis", "width"], title: "title", enabled: ["abpEllipsisEnabled", "enabled"] }, host: { properties: { "title": "this.title", "class.abp-ellipsis-inline": "this.inlineClass", "class.abp-ellipsis": "this.class", "style.max-width": "this.maxWidth" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: EllipsisDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpEllipsis]',
                }]
        }], propDecorators: { width: [{
                type: Input,
                args: ['abpEllipsis']
            }], title: [{
                type: HostBinding,
                args: ['title']
            }, {
                type: Input
            }], enabled: [{
                type: Input,
                args: ['abpEllipsisEnabled']
            }], inlineClass: [{
                type: HostBinding,
                args: ['class.abp-ellipsis-inline']
            }], class: [{
                type: HostBinding,
                args: ['class.abp-ellipsis']
            }], maxWidth: [{
                type: HostBinding,
                args: ['style.max-width']
            }] } });

class LoadingDirective {
    constructor() {
        this.elRef = inject(ElementRef);
        this.cdRes = inject(ComponentFactoryResolver);
        this.injector = inject(Injector);
        this.renderer = inject(Renderer2);
        this.position = 'relative';
        this.delay = 0;
        this.rootNode = null;
        this.timerSubscription = null;
    }
    get loading() {
        return this._loading;
    }
    set loading(newValue) {
        setTimeout(() => {
            if (!newValue && this.timerSubscription) {
                this.timerSubscription.unsubscribe();
                this.timerSubscription = null;
                this._loading = newValue;
                if (this.rootNode) {
                    this.renderer.removeChild(this.rootNode.parentElement, this.rootNode);
                    this.rootNode = null;
                }
                return;
            }
            this.timerSubscription = timer(this.delay)
                .pipe(take(1))
                .subscribe(() => {
                if (!this.componentRef) {
                    this.componentRef = this.cdRes
                        .resolveComponentFactory(LoadingComponent)
                        .create(this.injector);
                }
                if (newValue && !this.rootNode) {
                    this.rootNode = this.componentRef.hostView.rootNodes[0];
                    this.targetElement?.appendChild(this.rootNode);
                }
                else if (this.rootNode) {
                    this.renderer.removeChild(this.rootNode.parentElement, this.rootNode);
                    this.rootNode = null;
                }
                this._loading = newValue;
                this.timerSubscription = null;
            });
        }, 0);
    }
    ngOnInit() {
        if (!this.targetElement) {
            const { offsetHeight, offsetWidth } = this.elRef.nativeElement;
            if (!offsetHeight && !offsetWidth && this.elRef.nativeElement.children?.length) {
                this.targetElement = this.elRef.nativeElement.children[0];
            }
            else {
                this.targetElement = this.elRef.nativeElement;
            }
        }
    }
    ngOnDestroy() {
        if (this.timerSubscription) {
            this.timerSubscription.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LoadingDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: LoadingDirective, isStandalone: true, selector: "[abpLoading]", inputs: { loading: ["abpLoading", "loading"], targetElement: ["abpLoadingTargetElement", "targetElement"], delay: ["abpLoadingDelay", "delay"] }, host: { properties: { "style.position": "this.position" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: LoadingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpLoading]',
                }]
        }], propDecorators: { position: [{
                type: HostBinding,
                args: ['style.position']
            }], loading: [{
                type: Input,
                args: ['abpLoading']
            }], targetElement: [{
                type: Input,
                args: ['abpLoadingTargetElement']
            }], delay: [{
                type: Input,
                args: ['abpLoadingDelay']
            }] } });

class NgxDatatableDefaultDirective {
    get classes() {
        return `ngx-datatable ${this.class}`;
    }
    constructor() {
        this.table = inject(DatatableComponent);
        this.document = inject(DOCUMENT);
        this.platformId = inject(PLATFORM_ID);
        this.subscription = new Subscription();
        this.resizeDiff = 0;
        this.class = 'material bordered';
        this.table.columnMode = ColumnMode.force;
        this.table.footerHeight = 50;
        this.table.headerHeight = 50;
        this.table.rowHeight = 'auto';
        this.table.scrollbarH = true;
        this.table.virtualization = false;
    }
    fixHorizontalGap(scroller) {
        const { body, documentElement } = this.document;
        if (isPlatformBrowser(this.platformId)) {
            if (documentElement.scrollHeight !== documentElement.clientHeight) {
                if (this.resizeDiff === 0) {
                    this.resizeDiff = window.innerWidth - body.offsetWidth;
                    scroller.scrollWidth -= this.resizeDiff;
                }
            }
            else {
                scroller.scrollWidth += this.resizeDiff;
                this.resizeDiff = 0;
            }
        }
    }
    fixStyleOnWindowResize() {
        if (isPlatformBrowser(this.platformId)) {
            const subscription = fromEvent(window, 'resize')
                .pipe(debounceTime(500))
                .subscribe(() => {
                const { scroller } = this.table.bodyComponent;
                if (!scroller)
                    return;
                this.fixHorizontalGap(scroller);
            });
            this.subscription.add(subscription);
        }
    }
    ngAfterViewInit() {
        this.fixStyleOnWindowResize();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: NgxDatatableDefaultDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: NgxDatatableDefaultDirective, isStandalone: true, selector: "ngx-datatable[default]", inputs: { class: "class" }, host: { properties: { "class": "this.classes" } }, exportAs: ["ngxDatatableDefault"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: NgxDatatableDefaultDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'ngx-datatable[default]',
                    exportAs: 'ngxDatatableDefault',
                }]
        }], ctorParameters: () => [], propDecorators: { class: [{
                type: Input
            }], classes: [{
                type: HostBinding,
                args: ['class']
            }] } });

class NgxDatatableListDirective {
    constructor() {
        this.table = inject(DatatableComponent);
        this.cdRef = inject(ChangeDetectorRef);
        this.destroyRef = inject(DestroyRef);
        this.localizationService = inject(LocalizationService);
        this.ngxDatatableMessages = inject(NGX_DATATABLE_MESSAGES, { optional: true });
        this.viewContainerRef = inject(ViewContainerRef);
        this.renderer = inject(Renderer2);
        this.setInitialValues();
    }
    ngDoCheck() {
        this.refreshPageIfDataExist();
    }
    ngOnInit() {
        this.subscribeToPage();
        this.subscribeToSort();
        this.subscribeToRequestStatus();
    }
    ngOnChanges({ list }) {
        this.subscribeToQuery();
        if (!list.firstChange)
            return;
        const { maxResultCount, page } = list.currentValue;
        this.table.limit = maxResultCount;
        this.table.offset = page;
    }
    subscribeToRequestStatus() {
        const requestStatus$ = this.list.requestStatus$.pipe(distinctUntilChanged());
        const { emptyMessage, errorMessage } = this.ngxDatatableMessages || defaultNgxDatatableMessages;
        requestStatus$.subscribe(status => {
            this.table.loadingIndicator = false;
            if (status === 'idle') {
                return;
            }
            if (status === 'loading') {
                this.table.messages.emptyMessage = undefined;
                this.table.loadingIndicator = true;
                this.cdRef.detectChanges();
                this.updateLoadingIndicator();
                return;
            }
            if (status === 'error') {
                this.table.messages.emptyMessage = this.localizationService.instant(errorMessage);
                this.viewContainerRef.clear();
                this.cdRef.markForCheck();
            }
            if (status === 'success') {
                this.table.messages.emptyMessage = this.localizationService.instant(emptyMessage);
                this.viewContainerRef.clear();
            }
        });
    }
    updateLoadingIndicator() {
        const body = this.table.element.querySelector('datatable-body');
        const progress = this.table.element.querySelector('datatable-progress');
        if (!body) {
            return;
        }
        if (progress) {
            this.replaceLoadingIndicator(body, progress);
        }
    }
    replaceLoadingIndicator(parent, placeholder) {
        this.viewContainerRef.clear();
        const spinnerRef = this.viewContainerRef.createComponent(SpinnerComponent);
        const spinnerElement = spinnerRef.location.nativeElement;
        this.renderer.insertBefore(parent, spinnerElement, parent.firstChild);
        const placeholderParent = placeholder?.parentNode;
        if (placeholderParent) {
            this.renderer.removeChild(placeholderParent, placeholder);
        }
    }
    setInitialValues() {
        this.table.externalPaging = true;
        this.table.externalSorting = true;
        const { selectedMessage, totalMessage } = this.ngxDatatableMessages || defaultNgxDatatableMessages;
        this.table.messages = {
            totalMessage: this.localizationService.instant(totalMessage),
            selectedMessage: this.localizationService.instant(selectedMessage),
        };
    }
    subscribeToSort() {
        this.table.sort
            .pipe(takeUntilDestroyed(this.destroyRef))
            .subscribe(({ sorts: [{ prop, dir }] }) => {
            if (prop === this.list.sortKey && this.list.sortOrder === 'desc') {
                this.list.sortKey = '';
                this.list.sortOrder = '';
                this.table.sorts = [];
                this.cdRef.detectChanges();
            }
            else {
                this.list.sortKey = prop;
                this.list.sortOrder = dir;
            }
        });
    }
    subscribeToPage() {
        this.table.page.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(({ offset }) => {
            this.setTablePage(offset);
        });
    }
    subscribeToQuery() {
        this.list.query$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {
            const offset = this.list.page;
            if (this.table.offset !== offset)
                this.table.offset = offset;
        });
    }
    setTablePage(pageNum) {
        this.list.page = pageNum;
        this.table.offset = pageNum;
    }
    refreshPageIfDataExist() {
        if (this.table.rows?.length < 1 && this.table.count > 0) {
            let maxPage = Math.floor(Number(this.table.count / this.list.maxResultCount));
            if (this.table.count < this.list.maxResultCount) {
                this.setTablePage(0);
                return;
            }
            if (this.table.count % this.list.maxResultCount === 0) {
                maxPage -= 1;
            }
            if (this.list.page < maxPage) {
                this.setTablePage(this.list.page);
                return;
            }
            this.setTablePage(maxPage);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: NgxDatatableListDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: NgxDatatableListDirective, isStandalone: true, selector: "ngx-datatable[list]", inputs: { list: "list" }, exportAs: ["ngxDatatableList"], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: NgxDatatableListDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'ngx-datatable[list]',
                    exportAs: 'ngxDatatableList',
                }]
        }], ctorParameters: () => [], propDecorators: { list: [{
                type: Input
            }] } });

class AbpVisibleDirective {
    constructor() {
        this.viewContainerRef = inject(ViewContainerRef);
        this.templateRef = inject(TemplateRef);
        this.condition$ = of(false);
    }
    set abpVisible(value) {
        this.condition$ = checkType(value);
        this.subscribeToCondition();
    }
    ngOnInit() {
        this.updateVisibility();
    }
    ngOnDestroy() {
        this.conditionSubscription?.unsubscribe();
    }
    subscribeToCondition() {
        this.conditionSubscription = this.condition$.subscribe(value => {
            this.isVisible = value;
            this.updateVisibility();
        });
    }
    updateVisibility() {
        this.viewContainerRef.clear();
        // it should be false not falsy
        if (this.isVisible === false) {
            return;
        }
        this.viewContainerRef.createEmbeddedView(this.templateRef);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpVisibleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: AbpVisibleDirective, isStandalone: true, selector: "[abpVisible]", inputs: { abpVisible: "abpVisible" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: AbpVisibleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpVisible]',
                }]
        }], propDecorators: { abpVisible: [{
                type: Input
            }] } });
function checkType(value) {
    if (value instanceof Promise) {
        return from(value);
    }
    else if (value instanceof Observable) {
        return value;
    }
    else if (typeof value === 'boolean') {
        return of(value);
    }
    else if (value === undefined || value === null) {
        return of(true);
    }
    else {
        return EMPTY;
    }
}

class DisabledDirective {
    constructor() {
        this.ngControl = inject(NgControl, { host: true });
        this.abpDisabled = false;
    }
    // Related issue: https://github.com/angular/angular/issues/35330
    ngOnChanges({ abpDisabled }) {
        if (this.ngControl.control && abpDisabled) {
            this.ngControl.control[abpDisabled.currentValue ? 'disable' : 'enable']();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DisabledDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "20.0.7", type: DisabledDirective, isStandalone: true, selector: "[abpDisabled]", inputs: { abpDisabled: "abpDisabled" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DisabledDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpDisabled]',
                }]
        }], propDecorators: { abpDisabled: [{
                type: Input
            }] } });

var eFormComponets;
(function (eFormComponets) {
    eFormComponets["FormInputComponent"] = "FormInputComponent";
    eFormComponets["FormCheckboxComponent"] = "FormCheckboxComponent";
})(eFormComponets || (eFormComponets = {}));

class DocumentDirHandlerService {
    constructor() {
        this.injector = inject(Injector);
        this.dir = new BehaviorSubject('ltr');
        this.dir$ = this.dir.asObservable();
        this.listenToLanguageChanges();
    }
    listenToLanguageChanges() {
        const l10n = this.injector.get(LocalizationService);
        // will always listen, no need to unsubscribe
        l10n.currentLang$.pipe(map(locale => getLocaleDirection(locale))).subscribe(dir => {
            this.dir.next(dir);
            this.setBodyDir(dir);
        });
    }
    setBodyDir(dir) {
        this.injector.get(DOCUMENT).body.dir = dir;
        this.injector.get(DOCUMENT).dir = dir;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DocumentDirHandlerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DocumentDirHandlerService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DocumentDirHandlerService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });

class ErrorHandler {
    constructor() {
        this.injector = inject(Injector);
        this.httpErrorReporter = inject(HttpErrorReporterService);
        this.confirmationService = inject(ConfirmationService);
        this.routerErrorHandlerService = inject(RouterErrorHandlerService);
        this.httpErrorConfig = inject(HTTP_ERROR_CONFIG);
        this.customErrorHandlers = inject(CUSTOM_ERROR_HANDLERS);
        this.httpErrorHandler = inject(HTTP_ERROR_HANDLER, { optional: true });
        this.executeErrorHandler = (error) => {
            if (this.httpErrorHandler) {
                return this.httpErrorHandler(this.injector, error);
            }
            return of(error);
        };
        this.filterRestErrors = ({ status }) => {
            if (typeof status !== 'number')
                return false;
            if (!this.httpErrorConfig?.skipHandledErrorCodes) {
                return true;
            }
            return this.httpErrorConfig.skipHandledErrorCodes?.findIndex(code => code === status) < 0;
        };
        this.listenToRestError();
        this.listenToRouterError();
    }
    listenToRouterError() {
        this.routerErrorHandlerService.listen();
    }
    listenToRestError() {
        this.httpErrorReporter.reporter$
            .pipe(filter(this.filterRestErrors), switchMap(this.executeErrorHandler))
            .subscribe(err => this.handleError(err));
    }
    sortHttpErrorHandlers(a, b) {
        return (b.priority || 0) - (a.priority || 0);
    }
    handleError(err) {
        if (this.customErrorHandlers && this.customErrorHandlers.length) {
            const errorHandlerService = this.customErrorHandlers
                .sort(this.sortHttpErrorHandlers)
                .find(service => service.canHandle(err));
            if (errorHandlerService) {
                errorHandlerService.execute();
                return;
            }
        }
        this.showError().subscribe();
    }
    showError() {
        const title = {
            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
        };
        const message = {
            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.details,
            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.details,
        };
        return this.confirmationService.error(message, title, {
            hideCancelBtn: true,
            yesText: 'AbpAccount::Close',
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ErrorHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ErrorHandler, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ErrorHandler, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });

const NG_BOOTSTRAP_CONFIG_PROVIDERS = [
    {
        provide: NgbDatepickerI18n,
        useClass: DatepickerI18nAdapter,
    },
    {
        provide: NgbTimepickerI18n,
        useClass: TimepickerI18nAdapter,
    },
    provideAppInitializer(() => {
        configureNgBootstrap();
    }),
];
function configureNgBootstrap() {
    const datepicker = inject(NgbInputDatepickerConfig);
    const typeahead = inject(NgbTypeaheadConfig);
    datepicker.container = 'body';
    typeahead.container = 'body';
}

const THEME_SHARED_ROUTE_PROVIDERS = [
    provideAppInitializer(() => {
        configureRoutes();
    }),
];
function configureRoutes() {
    const routesService = inject(RoutesService);
    routesService.add([
        {
            path: undefined,
            name: "AbpUiNavigation::Menu:Administration" /* eThemeSharedRouteNames.Administration */,
            iconClass: 'fa fa-wrench',
            order: 100,
        },
    ]);
}

const tenantNotFoundProvider = {
    provide: TENANT_NOT_FOUND_BY_NAME,
    useFactory: function () {
        const confirm = inject(ConfirmationService);
        const document = inject(DOCUMENT);
        return (response) => {
            const { error } = response.error;
            // hide loading donut
            const appRoot = document.querySelector('app-root div.donut');
            if (appRoot) {
                appRoot.remove();
            }
            confirm.error(error.details, error.message, { hideCancelBtn: true, hideYesBtn: true });
        };
    },
};

const DEFAULT_HANDLERS_PROVIDERS = [
    {
        provide: CUSTOM_ERROR_HANDLERS,
        multi: true,
        useExisting: TenantResolveErrorHandlerService,
    },
    {
        provide: CUSTOM_ERROR_HANDLERS,
        multi: true,
        useExisting: AbpFormatErrorHandlerService,
    },
    {
        provide: CUSTOM_ERROR_HANDLERS,
        multi: true,
        useExisting: StatusCodeErrorHandlerService,
    },
    {
        provide: CUSTOM_ERROR_HANDLERS,
        multi: true,
        useExisting: UnknownStatusCodeErrorHandlerService,
    },
    {
        provide: CUSTOM_ERROR_HANDLERS,
        multi: true,
        useExisting: AbpAuthenticationErrorHandler,
    },
];

const DEFAULT_VALIDATION_BLUEPRINTS = {
    creditCard: 'AbpValidation::ThisFieldIsNotAValidCreditCardNumber.',
    email: 'AbpValidation::ThisFieldIsNotAValidEmailAddress.',
    invalid: 'AbpValidation::ThisFieldIsNotValid.',
    max: 'AbpValidation::ThisFieldMustBeLessOrEqual{0}[{{ max }}]',
    maxlength: 'AbpValidation::ThisFieldMustBeAStringOrArrayTypeWithAMaximumLengthOf{0}[{{ requiredLength }}]',
    min: 'AbpValidation::ThisFieldMustBeGreaterThanOrEqual{0}[{{ min }}]',
    minlength: 'AbpValidation::ThisFieldMustBeAStringOrArrayTypeWithAMinimumLengthOf{0}[{{ requiredLength }}]',
    ngbDate: 'AbpValidation::ThisFieldIsNotValid.',
    passwordMismatch: 'AbpIdentity::Volo.Abp.Identity:PasswordConfirmationFailed',
    range: 'AbpValidation::ThisFieldMustBeBetween{0}And{1}[{{ min }},{{ max }}]',
    required: 'AbpValidation::ThisFieldIsRequired.',
    url: 'AbpValidation::ThisFieldIsNotAValidFullyQualifiedHttpHttpsOrFtpUrl',
    passwordRequiresLower: 'AbpIdentity::Volo.Abp.Identity:PasswordRequiresLower',
    passwordRequiresUpper: 'AbpIdentity::Volo.Abp.Identity:PasswordRequiresUpper',
    passwordRequiresDigit: 'AbpIdentity::Volo.Abp.Identity:PasswordRequiresDigit',
    passwordRequiresNonAlphanumeric: 'AbpIdentity::Volo.Abp.Identity:PasswordRequiresNonAlphanumeric',
    usernamePattern: 'AbpIdentity::Volo.Abp.Identity:InvalidUserName[{{ actualValue }}]',
    customMessage: '{{ customMessage }}'
};

var scripts = '';

function isNumber(value) {
    return !isNaN(toInteger(value));
}
function toInteger(value) {
    return parseInt(`${value}`, 10);
}
class DateParserFormatter extends NgbDateParserFormatter {
    constructor() {
        super();
        this.configState = inject(ConfigStateService);
        this.locale = inject(LOCALE_ID);
    }
    parse(value) {
        if (value) {
            const dateParts = value.trim().split('-');
            // TODO: CHANGED
            if (dateParts.length === 1 && isNumber(dateParts[0])) {
                return { year: toInteger(dateParts[0]), month: -1, day: -1 };
            }
            else if (dateParts.length === 2 && isNumber(dateParts[0]) && isNumber(dateParts[1])) {
                return { year: toInteger(dateParts[0]), month: toInteger(dateParts[1]), day: -1 };
            }
            else if (dateParts.length === 3 &&
                isNumber(dateParts[0]) &&
                isNumber(dateParts[1]) &&
                isNumber(dateParts[2])) {
                return {
                    year: toInteger(dateParts[0]),
                    month: toInteger(dateParts[1]),
                    day: toInteger(dateParts[2]),
                };
            }
        }
        return null;
    }
    format(date) {
        if (!date)
            return '';
        const localization = this.configState.getOne('localization');
        const dateFormat = localization.currentCulture?.dateTimeFormat?.shortDatePattern || 'yyyy-MM-dd';
        return formatDate(new Date(date.year, date.month - 1, date.day), dateFormat, this.locale);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DateParserFormatter, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DateParserFormatter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: DateParserFormatter, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });

const { minLength, maxLength } = Validators;
function getPasswordValidators(injector) {
    const getRule = getRuleFn(injector);
    const passwordRulesArr = [];
    let requiredLength = 1;
    if (getRule('RequireDigit') === 'true') {
        passwordRulesArr.push('number');
    }
    if (getRule('RequireLowercase') === 'true') {
        passwordRulesArr.push('small');
    }
    if (getRule('RequireUppercase') === 'true') {
        passwordRulesArr.push('capital');
    }
    if (getRule('RequireNonAlphanumeric') === 'true') {
        passwordRulesArr.push('special');
    }
    if (Number.isInteger(+getRule('RequiredLength'))) {
        requiredLength = +getRule('RequiredLength');
    }
    const passwordValidators = passwordRulesArr.map(rule => validatePassword(rule));
    return [...passwordValidators, minLength(requiredLength), maxLength(128)];
}
function getRuleFn(injector) {
    const configState = injector.get(ConfigStateService);
    return (key) => {
        const passwordRules = configState.getSettings('Identity.Password');
        return (passwordRules[`Abp.Identity.Password.${key}`] || '').toLowerCase();
    };
}
const errorMessageMap = {
    small: 'passwordRequiresLower',
    capital: 'passwordRequiresUpper',
    number: 'passwordRequiresDigit',
    special: 'passwordRequiresNonAlphanumeric',
};
function validatePassword(shouldContain) {
    return (control) => {
        if (!control.value)
            return null;
        const value = normalizeDiacritics(control.value);
        const regexMap = {
            small: /.*[a-z].*/,
            capital: /.*[A-Z].*/,
            number: /.*[0-9].*/,
            special: /.*[^0-9a-zA-Z].*/,
        };
        const regex = regexMap[shouldContain];
        const isValid = regex.test(value);
        if (isValid) {
            return null;
        }
        const error = errorMessageMap[shouldContain];
        return {
            [error]: true,
        };
    };
}

var ThemeSharedFeatureKind;
(function (ThemeSharedFeatureKind) {
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["HttpErrorConfig"] = 0] = "HttpErrorConfig";
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["ValidationBluePrint"] = 1] = "ValidationBluePrint";
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["ValidationErrorsFn"] = 2] = "ValidationErrorsFn";
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["ValidateOnSubmit"] = 3] = "ValidateOnSubmit";
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["Validation"] = 4] = "Validation";
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["ConfirmationIcons"] = 5] = "ConfirmationIcons";
})(ThemeSharedFeatureKind || (ThemeSharedFeatureKind = {}));
function makeThemeSharedFeature(kind, providers) {
    return {
        ɵkind: kind,
        ɵproviders: providers,
    };
}
function withHttpErrorConfig(httpErrorConfig) {
    return makeThemeSharedFeature(ThemeSharedFeatureKind.HttpErrorConfig, [
        {
            provide: HTTP_ERROR_CONFIG,
            useValue: httpErrorConfig,
        },
    ]);
}
function withValidationBluePrint(bluePrints) {
    return makeThemeSharedFeature(ThemeSharedFeatureKind.ValidationBluePrint, [
        {
            provide: VALIDATION_BLUEPRINTS,
            useValue: {
                ...DEFAULT_VALIDATION_BLUEPRINTS,
                ...(bluePrints || {}),
            },
        },
    ]);
}
function withValidationMapErrorsFn(mapErrorsFn) {
    return makeThemeSharedFeature(ThemeSharedFeatureKind.ValidationErrorsFn, [
        {
            provide: VALIDATION_MAP_ERRORS_FN,
            useValue: mapErrorsFn || defaultMapErrorsFn,
        },
    ]);
}
function withValidateOnSubmit(validateOnSubmit) {
    return makeThemeSharedFeature(ThemeSharedFeatureKind.ValidateOnSubmit, [
        {
            provide: VALIDATION_VALIDATE_ON_SUBMIT,
            useValue: validateOnSubmit,
        },
    ]);
}
function withConfirmationIcon(confirmationIcons) {
    return makeThemeSharedFeature(ThemeSharedFeatureKind.HttpErrorConfig, [
        {
            provide: CONFIRMATION_ICONS,
            useValue: { ...DEFAULT_CONFIRMATION_ICONS, ...(confirmationIcons || {}) },
        },
    ]);
}
function provideAbpThemeShared(...features) {
    const providers = [
        provideAppInitializer(() => {
            inject(ErrorHandler);
            inject(THEME_SHARED_APPEND_CONTENT);
            inject(DocumentDirHandlerService);
        }),
        THEME_SHARED_ROUTE_PROVIDERS,
        { provide: HTTP_ERROR_CONFIG, useValue: undefined },
        { provide: NgbDateParserFormatter, useClass: DateParserFormatter },
        NG_BOOTSTRAP_CONFIG_PROVIDERS,
        {
            provide: VALIDATION_BLUEPRINTS,
            useValue: { ...DEFAULT_VALIDATION_BLUEPRINTS },
        },
        {
            provide: VALIDATION_MAP_ERRORS_FN,
            useValue: defaultMapErrorsFn,
        },
        {
            provide: VALIDATION_VALIDATE_ON_SUBMIT,
            useValue: undefined,
        },
        DocumentDirHandlerService,
        {
            provide: CONFIRMATION_ICONS,
            useValue: { ...DEFAULT_CONFIRMATION_ICONS },
        },
        tenantNotFoundProvider,
        DEFAULT_HANDLERS_PROVIDERS,
    ];
    for (const feature of features) {
        providers.push(...feature.ɵproviders);
    }
    return makeEnvironmentProviders(providers);
}

var LogoFeatureKind;
(function (LogoFeatureKind) {
    LogoFeatureKind[LogoFeatureKind["Options"] = 0] = "Options";
})(LogoFeatureKind || (LogoFeatureKind = {}));
function makeLogoFeature(kind, providers) {
    return {
        ɵkind: kind,
        ɵproviders: providers,
    };
}
function withEnvironmentOptions(options = {}) {
    const { name, logoUrl } = options.application || {};
    return makeLogoFeature(LogoFeatureKind.Options, [
        {
            provide: LOGO_URL_TOKEN,
            useValue: logoUrl || '',
        },
        {
            provide: LOGO_APP_NAME_TOKEN,
            useValue: name || 'ProjectName',
        },
    ]);
}
function provideLogo(...features) {
    const providers = [];
    features.forEach(({ ɵproviders }) => providers.push(...ɵproviders));
    return makeEnvironmentProviders(providers);
}

const THEME_SHARED_EXPORTS = [
    BreadcrumbComponent,
    BreadcrumbItemsComponent,
    ButtonComponent,
    ConfirmationComponent,
    LoaderBarComponent,
    LoadingComponent,
    ModalComponent,
    ToastComponent,
    ToastContainerComponent,
    LoadingDirective,
    ModalCloseDirective,
    FormInputComponent,
    FormCheckboxComponent,
    HttpErrorWrapperComponent,
    NgxDatatableModule,
    NgxValidateCoreModule,
    CardModule,
    DisabledDirective,
    AbpVisibleDirective,
    NgxDatatableListDirective,
    NgxDatatableDefaultDirective,
    PasswordComponent,
];
class BaseThemeSharedModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: BaseThemeSharedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: BaseThemeSharedModule, imports: [BreadcrumbComponent,
            BreadcrumbItemsComponent,
            ButtonComponent,
            ConfirmationComponent,
            LoaderBarComponent,
            LoadingComponent,
            ModalComponent,
            ToastComponent,
            ToastContainerComponent,
            LoadingDirective,
            ModalCloseDirective,
            FormInputComponent,
            FormCheckboxComponent,
            HttpErrorWrapperComponent,
            NgxDatatableModule,
            NgxValidateCoreModule,
            CardModule,
            DisabledDirective,
            AbpVisibleDirective,
            NgxDatatableListDirective,
            NgxDatatableDefaultDirective,
            PasswordComponent], exports: [BreadcrumbComponent,
            BreadcrumbItemsComponent,
            ButtonComponent,
            ConfirmationComponent,
            LoaderBarComponent,
            LoadingComponent,
            ModalComponent,
            ToastComponent,
            ToastContainerComponent,
            LoadingDirective,
            ModalCloseDirective,
            FormInputComponent,
            FormCheckboxComponent,
            HttpErrorWrapperComponent,
            NgxDatatableModule,
            NgxValidateCoreModule,
            CardModule,
            DisabledDirective,
            AbpVisibleDirective,
            NgxDatatableListDirective,
            NgxDatatableDefaultDirective,
            PasswordComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: BaseThemeSharedModule, imports: [ButtonComponent,
            FormInputComponent,
            FormCheckboxComponent,
            HttpErrorWrapperComponent,
            NgxDatatableModule,
            NgxValidateCoreModule,
            CardModule,
            PasswordComponent,
            NgxDatatableModule,
            NgxValidateCoreModule,
            CardModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: BaseThemeSharedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...THEME_SHARED_EXPORTS],
                    declarations: [],
                    exports: [...THEME_SHARED_EXPORTS],
                }]
        }] });
class ThemeSharedModule {
    /**
     * @deprecated forRoot method is deprecated, use `provideAbpThemeShared` *function* for config settings.
     */
    static forRoot({ httpErrorConfig, validation = {}, confirmationIcons = {} } = {}) {
        return {
            ngModule: ThemeSharedModule,
            providers: [
                provideAbpThemeShared(withHttpErrorConfig(httpErrorConfig), withValidationBluePrint(validation.blueprints), withValidationMapErrorsFn(validation.mapErrorsFn), withValidateOnSubmit(validation.validateOnSubmit), withConfirmationIcon(confirmationIcons)),
            ],
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ThemeSharedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.7", ngImport: i0, type: ThemeSharedModule, imports: [BaseThemeSharedModule], exports: [BaseThemeSharedModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ThemeSharedModule, imports: [BaseThemeSharedModule, BaseThemeSharedModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.7", ngImport: i0, type: ThemeSharedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [BaseThemeSharedModule],
                    exports: [BaseThemeSharedModule],
                }]
        }] });

/*
 * Public API Surface of theme-shared
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AbpAuthenticationErrorHandler, AbpFormatErrorHandlerService, AbpVisibleDirective, BaseThemeSharedModule, BreadcrumbComponent, BreadcrumbItemsComponent, ButtonComponent, CARD_COMPONENTS, CARD_DIRECTIVES, CONFIRMATION_ICONS, CUSTOM_ERROR_HANDLERS, CUSTOM_HTTP_ERROR_HANDLER_PRIORITY, CardBodyComponent, CardComponent, CardFooterComponent, CardHeaderComponent, CardHeaderDirective, CardImgTopDirective, CardModule, CardSubtitleDirective, CardTitleDirective, Confirmation, ConfirmationComponent, ConfirmationService, CreateErrorComponentService, DEFAULT_CONFIRMATION_ICONS, DEFAULT_ERROR_LOCALIZATIONS, DEFAULT_ERROR_MESSAGES, DEFAULT_HANDLERS_PROVIDERS, DEFAULT_VALIDATION_BLUEPRINTS, DateAdapter, DateParserFormatter, DateTimeAdapter, DatepickerI18nAdapter, DisabledDirective, DocumentDirHandlerService, EllipsisDirective, ErrorHandler, FormCheckboxComponent, FormInputComponent, HTTP_ERROR_CONFIG, HTTP_ERROR_DETAIL, HTTP_ERROR_HANDLER, HTTP_ERROR_STATUS, HttpErrorWrapperComponent, InternetConnectionStatusComponent, LOGO_APP_NAME_TOKEN, LOGO_URL_TOKEN, LoaderBarComponent, LoadingComponent, LoadingDirective, LogoFeatureKind, ModalCloseDirective, ModalComponent, ModalRefService, NGX_DATATABLE_MESSAGES, NG_BOOTSTRAP_CONFIG_PROVIDERS, NavItem, NavItemsService, NgxDatatableDefaultDirective, NgxDatatableListDirective, PageAlertService, PasswordComponent, RouterErrorHandlerService, SUPPRESS_UNSAVED_CHANGES_WARNING, SpinnerComponent, StatusCodeErrorHandlerService, THEME_SHARED_APPEND_CONTENT, THEME_SHARED_EXPORTS, THEME_SHARED_ROUTE_PROVIDERS, TenantResolveErrorHandlerService, ThemeSharedFeatureKind, ThemeSharedModule, TimeAdapter, TimepickerI18nAdapter, ToastComponent, ToastContainerComponent, ToasterService, UnknownStatusCodeErrorHandlerService, UserMenu, UserMenuService, bounceIn, collapse, collapseLinearWithMargin, collapseWithMargin, collapseX, collapseY, collapseYWithMargin, configureNgBootstrap, configureRoutes, defaultNgxDatatableMessages, dialogAnimation, eFormComponets, expandX, expandY, expandYWithMargin, fadeAnimation, fadeIn, fadeInDown, fadeInLeft, fadeInRight, fadeInUp, fadeOut, fadeOutDown, fadeOutLeft, fadeOutRight, fadeOutUp, getErrorFromRequestBody, getPasswordValidators, provideAbpThemeShared, provideLogo, slideFromBottom, tenantNotFoundProvider, toastInOut, validatePassword, withConfirmationIcon, withEnvironmentOptions, withHttpErrorConfig, withValidateOnSubmit, withValidationBluePrint, withValidationMapErrorsFn };
//# sourceMappingURL=abp-ng.theme.shared.mjs.map
