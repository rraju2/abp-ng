import { NgbDateStruct, NgbTimeStruct, NgbDateAdapter, NgbDatepickerI18n, NgbTimeAdapter, NgbTimepickerI18n, NgbModal, NgbModalOptions, NgbModalRef, NgbDateParserFormatter } from '@ng-bootstrap/ng-bootstrap';
import * as i0 from '@angular/core';
import { OnInit, ChangeDetectorRef, EventEmitter, ElementRef, InjectionToken, Type, Injector, AfterViewInit, OnDestroy, DestroyRef, ApplicationRef, EnvironmentInjector, RendererFactory2, ComponentRef, TemplateRef, OnChanges, DoCheck, ViewContainerRef, Renderer2, SimpleChanges, Provider, EnvironmentProviders, ModuleWithProviders } from '@angular/core';
import * as _angular_animations from '@angular/animations';
import { ABP, LocalizationParam, SortableItem, Strict, RouterEvents, SessionStateService, AuthService, ConfigStateService, AbstractNgModelComponent, InternetConnectionService, LocalizationService, ListService, HttpErrorReporterService, Environment } from '@abp/ng.core';
import * as rxjs from 'rxjs';
import { ReplaySubject, Observable, Subject, Subscription, BehaviorSubject } from 'rxjs';
import { Router, NavigationError } from '@angular/router';
import { HttpErrorResponse } from '@angular/common/http';
import * as i16 from '@ngx-validate/core';
import { Validation } from '@ngx-validate/core';
import * as i15 from '@swimlane/ngx-datatable';
import { DatatableComponent } from '@swimlane/ngx-datatable';
import { ValidatorFn } from '@angular/forms';

declare class DateTimeAdapter {
    value: Partial<NgbDateTimeStruct>;
    fromModel(value: string | Date): Partial<NgbDateTimeStruct> | null;
    toModel(value: Partial<NgbDateTimeStruct> | null): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<DateTimeAdapter, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<DateTimeAdapter>;
}
type NgbDateTimeStruct = NgbDateStruct & NgbTimeStruct;

declare class DateAdapter extends NgbDateAdapter<string | Date> {
    fromModel(value: string | Date): NgbDateStruct | null;
    toModel(value: NgbDateStruct | null): string;
    protected dateOf(value: string): Date;
    static ɵfac: i0.ɵɵFactoryDeclaration<DateAdapter, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<DateAdapter>;
}

declare class DatepickerI18nAdapter extends NgbDatepickerI18n {
    private configState;
    private defaultLocale;
    private get locale();
    getWeekdayLabel(weekday: number): string;
    getWeekLabel(): string;
    getMonthShortName(month: number): string;
    getMonthFullName(month: number): string;
    getDayAriaLabel(date: NgbDateStruct): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatepickerI18nAdapter, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<DatepickerI18nAdapter>;
}

declare class TimeAdapter extends NgbTimeAdapter<string | Date> {
    fromModel(value: string | Date): NgbTimeStruct | null;
    toModel(value: NgbTimeStruct | null): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<TimeAdapter, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TimeAdapter>;
}

declare class TimepickerI18nAdapter extends NgbTimepickerI18n {
    private configState;
    private defaultLocale;
    private get locale();
    getMorningPeriod(): string;
    getAfternoonPeriod(): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<TimepickerI18nAdapter, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TimepickerI18nAdapter>;
}

declare const bounceIn: _angular_animations.AnimationReferenceMetadata;

declare const collapseY: _angular_animations.AnimationReferenceMetadata;
declare const collapseYWithMargin: _angular_animations.AnimationReferenceMetadata;
declare const collapseX: _angular_animations.AnimationReferenceMetadata;
declare const expandY: _angular_animations.AnimationReferenceMetadata;
declare const expandYWithMargin: _angular_animations.AnimationReferenceMetadata;
declare const expandX: _angular_animations.AnimationReferenceMetadata;
declare const collapse: _angular_animations.AnimationTriggerMetadata;
declare const collapseWithMargin: _angular_animations.AnimationTriggerMetadata;
declare const collapseLinearWithMargin: _angular_animations.AnimationTriggerMetadata;

declare const fadeIn: _angular_animations.AnimationReferenceMetadata;
declare const fadeOut: _angular_animations.AnimationReferenceMetadata;
declare const fadeInDown: _angular_animations.AnimationReferenceMetadata;
declare const fadeInUp: _angular_animations.AnimationReferenceMetadata;
declare const fadeInLeft: _angular_animations.AnimationReferenceMetadata;
declare const fadeInRight: _angular_animations.AnimationReferenceMetadata;
declare const fadeOutDown: _angular_animations.AnimationReferenceMetadata;
declare const fadeOutUp: _angular_animations.AnimationReferenceMetadata;
declare const fadeOutLeft: _angular_animations.AnimationReferenceMetadata;
declare const fadeOutRight: _angular_animations.AnimationReferenceMetadata;

declare const fadeAnimation: _angular_animations.AnimationTriggerMetadata;
declare const dialogAnimation: _angular_animations.AnimationTriggerMetadata;

declare const slideFromBottom: _angular_animations.AnimationTriggerMetadata;

declare const toastInOut: _angular_animations.AnimationTriggerMetadata;

declare class BreadcrumbItemsComponent {
    items: Partial<ABP.Route>[];
    static ɵfac: i0.ɵɵFactoryDeclaration<BreadcrumbItemsComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<BreadcrumbItemsComponent, "abp-breadcrumb-items", never, { "items": { "alias": "items"; "required": false; }; }, {}, never, never, true, never>;
}

declare class BreadcrumbComponent implements OnInit {
    readonly cdRef: ChangeDetectorRef;
    private router;
    private routes;
    private subscription;
    private routerEvents;
    segments: Partial<ABP.Route>[];
    ngOnInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<BreadcrumbComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<BreadcrumbComponent, "abp-breadcrumb", never, {}, {}, never, never, true, never>;
}

declare class ButtonComponent implements OnInit {
    private renderer;
    buttonId: string;
    buttonClass: string;
    buttonType: string;
    formName?: string;
    iconClass?: string;
    loading: boolean;
    disabled: boolean | undefined;
    attributes?: ABP.Dictionary<string>;
    readonly click: EventEmitter<MouseEvent>;
    readonly focus: EventEmitter<FocusEvent>;
    readonly blur: EventEmitter<FocusEvent>;
    readonly abpClick: EventEmitter<MouseEvent>;
    readonly abpFocus: EventEmitter<FocusEvent>;
    readonly abpBlur: EventEmitter<FocusEvent>;
    buttonRef: ElementRef<HTMLButtonElement>;
    get icon(): string;
    ngOnInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ButtonComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ButtonComponent, "abp-button", never, { "buttonId": { "alias": "buttonId"; "required": false; }; "buttonClass": { "alias": "buttonClass"; "required": false; }; "buttonType": { "alias": "buttonType"; "required": false; }; "formName": { "alias": "formName"; "required": false; }; "iconClass": { "alias": "iconClass"; "required": false; }; "loading": { "alias": "loading"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "attributes": { "alias": "attributes"; "required": false; }; }, { "click": "click"; "focus": "focus"; "blur": "blur"; "abpClick": "abpClick"; "abpFocus": "abpFocus"; "abpBlur": "abpBlur"; }, never, ["*"], true, never>;
}

declare namespace Confirmation {
    interface Options {
        id?: any;
        dismissible?: boolean;
        messageLocalizationParams?: string[];
        titleLocalizationParams?: string[];
        hideCancelBtn?: boolean;
        hideYesBtn?: boolean;
        cancelText?: LocalizationParam;
        yesText?: LocalizationParam;
        icon?: string;
        iconTemplate?: string;
    }
    interface DialogData {
        message: LocalizationParam;
        title?: LocalizationParam;
        severity?: Severity;
        options?: Partial<Options>;
    }
    type Severity = 'neutral' | 'success' | 'info' | 'warning' | 'error';
    enum Status {
        confirm = "confirm",
        reject = "reject",
        dismiss = "dismiss"
    }
}

declare class ConfirmationComponent {
    private icons;
    confirm: Confirmation.Status;
    reject: Confirmation.Status;
    dismiss: Confirmation.Status;
    confirmation$: ReplaySubject<Confirmation.DialogData | null>;
    clear: (status: Confirmation.Status) => void;
    close(status: Confirmation.Status): void;
    getIconClass({ severity, options }: Confirmation.DialogData): string;
    isCustomIconExists({ options }: Confirmation.DialogData): boolean;
    isIconTemplateExits({ options }: Confirmation.DialogData): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<ConfirmationComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ConfirmationComponent, "abp-confirmation", never, {}, {}, never, never, true, never>;
}

interface ConfirmationIcons {
    info: string;
    success: string;
    warning: string;
    error: string;
    default: string;
    neutral: string;
}
declare const CONFIRMATION_ICONS: InjectionToken<Partial<ConfirmationIcons>>;
declare const DEFAULT_CONFIRMATION_ICONS: ConfirmationIcons;

interface RootParams {
    httpErrorConfig?: HttpErrorConfig;
    validation?: Partial<Validation.Config>;
    confirmationIcons?: Partial<ConfirmationIcons>;
}
type ErrorScreenErrorCodes = 0 | 401 | 403 | 404 | 500;
interface HttpErrorConfig {
    skipHandledErrorCodes?: ErrorScreenErrorCodes[] | number[];
    errorScreen?: {
        component: Type<any>;
        forWhichErrors?: ErrorScreenErrorCodes[];
        hideCloseIcon?: boolean;
    };
}
type HttpErrorHandler<T = any> = (injector: Injector, httpError: HttpErrorResponse) => Observable<T>;
type LocaleDirection = 'ltr' | 'rtl';
interface CustomHttpErrorHandlerService {
    readonly priority: number;
    canHandle(error: unknown): boolean;
    execute(): void;
}

interface Badge {
    count?: number | Observable<number>;
    color?: string;
    icon?: string;
}
declare class NavItem {
    id?: string | number;
    name?: string;
    description?: string;
    badge?: Badge;
    component?: Type<any>;
    html?: string;
    action?: () => void;
    order?: number;
    requiredPolicy?: string;
    visible?: NavBarPropPredicate<NavItem>;
    icon?: string;
    constructor(props: Partial<NavItem>);
}
type NavBarPropPredicate<T> = (prop?: T, injector?: Injector) => boolean | Promise<boolean> | Observable<boolean>;

declare namespace Statistics {
    interface Response {
        data: Data;
    }
    interface Data {
        [key: string]: number;
    }
    interface Filter {
        startDate: string | Date;
        endDate: string | Date;
    }
}

declare namespace Toaster {
    interface ToastOptions {
        life?: number;
        sticky?: boolean;
        closable?: boolean;
        tapToDismiss?: boolean;
        messageLocalizationParams?: string[];
        titleLocalizationParams?: string[];
        id: any;
        containerKey?: string;
        iconClass?: string;
    }
    interface Toast {
        message: LocalizationParam;
        title?: LocalizationParam;
        severity?: string;
        options?: ToastOptions;
    }
    type Severity = 'neutral' | 'success' | 'info' | 'warning' | 'error';
    type ToasterId = string | number;
    interface Service {
        show: (message: LocalizationParam, title: LocalizationParam, severity: Toaster.Severity, options: Partial<Toaster.ToastOptions>) => ToasterId;
        remove: (id: number) => void;
        clear: (containerKey?: string) => void;
        info: (message: LocalizationParam, title?: LocalizationParam, options?: Partial<Toaster.ToastOptions>) => ToasterId;
        success: (message: LocalizationParam, title?: LocalizationParam, options?: Partial<Toaster.ToastOptions>) => ToasterId;
        warn: (message: LocalizationParam, title?: LocalizationParam, options?: Partial<Toaster.ToastOptions>) => ToasterId;
        error: (message: LocalizationParam, title?: LocalizationParam, options?: Partial<Toaster.ToastOptions>) => ToasterId;
    }
}

declare class UserMenu extends NavItem {
    textTemplate?: UserMenuTextTemplate;
}
interface UserMenuTextTemplate {
    text: string;
    icon?: string;
}

type PasswordRule = 'small' | 'capital' | 'number' | 'special';

declare class HttpErrorWrapperComponent implements OnInit, AfterViewInit, OnDestroy {
    protected readonly destroyRef: DestroyRef;
    protected readonly document: Document;
    protected readonly window: Window & typeof globalThis;
    protected readonly router: Router;
    appRef: ApplicationRef;
    environmentInjector: EnvironmentInjector;
    status: ErrorScreenErrorCodes;
    title: LocalizationParam;
    details: LocalizationParam;
    customComponent: Type<any> | undefined;
    destroy$: Subject<void>;
    hideCloseIcon: boolean;
    backgroundColor: string;
    isHomeShow: boolean;
    containerRef?: ElementRef<HTMLDivElement>;
    get statusText(): string;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    goHome(): void;
    destroy(): void;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<HttpErrorWrapperComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<HttpErrorWrapperComponent, "abp-http-error-wrapper", never, {}, {}, never, never, true, never>;
}

declare class LoaderBarComponent implements OnDestroy, OnInit {
    private cdRef;
    private subscription;
    private httpWaitService;
    private routerWaitService;
    protected _isLoading: boolean;
    set isLoading(value: boolean);
    get isLoading(): boolean;
    containerClass: string;
    color: string;
    progressLevel: number;
    interval: Subscription;
    timer: Subscription;
    intervalPeriod: number;
    stopDelay: number;
    private readonly clearProgress;
    private readonly reportProgress;
    get boxShadow(): string;
    ngOnInit(): void;
    subscribeLoading(): void;
    ngOnDestroy(): void;
    startLoading(): void;
    stopLoading(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<LoaderBarComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<LoaderBarComponent, "abp-loader-bar", never, { "isLoading": { "alias": "isLoading"; "required": false; }; "containerClass": { "alias": "containerClass"; "required": false; }; "color": { "alias": "color"; "required": false; }; }, {}, never, never, true, never>;
}

declare class LoadingComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<LoadingComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<LoadingComponent, "abp-loading", never, {}, {}, never, never, true, never>;
}

declare class ModalCloseDirective {
    private modal;
    constructor();
    onClick(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalCloseDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ModalCloseDirective, "[abpClose]", never, {}, {}, never, never, true, never>;
}

type ModalDismissMode = 'hard' | 'soft';
interface DismissableModal {
    dismiss(mode: ModalDismissMode): void;
}
declare class ModalRefService {
    modalRefs: DismissableModal[];
    register(modal: DismissableModal): void;
    unregister(modal: DismissableModal): void;
    dismissAll(mode: ModalDismissMode): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalRefService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ModalRefService>;
}

declare class ConfirmationService {
    private contentProjectionService;
    private document;
    status$: Subject<Confirmation.Status>;
    confirmation$: ReplaySubject<Confirmation.DialogData>;
    private containerComponentRef;
    clear: (status?: Confirmation.Status) => void;
    private setContainer;
    info(message: LocalizationParam, title: LocalizationParam, options?: Partial<Confirmation.Options>): Observable<Confirmation.Status>;
    success(message: LocalizationParam, title: LocalizationParam, options?: Partial<Confirmation.Options>): Observable<Confirmation.Status>;
    warn(message: LocalizationParam, title: LocalizationParam, options?: Partial<Confirmation.Options>): Observable<Confirmation.Status>;
    error(message: LocalizationParam, title: LocalizationParam, options?: Partial<Confirmation.Options>): Observable<Confirmation.Status>;
    show(message: LocalizationParam, title: LocalizationParam, severity?: Confirmation.Severity, options?: Partial<Confirmation.Options>): Observable<Confirmation.Status>;
    private listenToEscape;
    static ɵfac: i0.ɵɵFactoryDeclaration<ConfirmationService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ConfirmationService>;
}

declare abstract class AbstractMenuService<T extends NavItem> {
    protected abstract baseClass: Type<any>;
    protected readonly sortFn: (a: SortableItem, b: SortableItem) => number;
    protected _items$: BehaviorSubject<T[]>;
    get items(): T[];
    get items$(): Observable<T[]>;
    constructor();
    addItems(newItems: T[]): void;
    removeItem(id: string | number): void;
    patchItem(id: string | number, item: Partial<Omit<T, 'id'>>): void;
    sortItems: (a: T, b: T) => number;
}

declare class NavItemsService extends AbstractMenuService<NavItem> {
    protected baseClass: typeof NavItem;
    static ɵfac: i0.ɵɵFactoryDeclaration<NavItemsService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NavItemsService>;
}

interface PageAlert {
    type: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
    message: string;
    dismissible?: boolean;
    title?: string;
    messageLocalizationParams?: string[];
    titleLocalizationParams?: string[];
}
declare class PageAlertService {
    private alerts;
    alerts$: rxjs.Observable<PageAlert[]>;
    show(alert: PageAlert): void;
    remove(index: number): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<PageAlertService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<PageAlertService>;
}

declare class ToasterService implements ToasterContract {
    private toasts$;
    private lastId;
    private toasts;
    private containerComponentRef;
    private contentProjectionService;
    private setContainer;
    constructor();
    /**
     * Creates an info toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    info(message: LocalizationParam, title?: LocalizationParam, options?: Partial<Toaster.ToastOptions>): Toaster.ToasterId;
    /**
     * Creates a success toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    success(message: LocalizationParam, title?: LocalizationParam, options?: Partial<Toaster.ToastOptions>): Toaster.ToasterId;
    /**
     * Creates a warning toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    warn(message: LocalizationParam, title?: LocalizationParam, options?: Partial<Toaster.ToastOptions>): Toaster.ToasterId;
    /**
     * Creates an error toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    error(message: LocalizationParam, title?: LocalizationParam, options?: Partial<Toaster.ToastOptions>): Toaster.ToasterId;
    /**
     * Creates a toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param severity Sets color of the toast. "success", "warning" etc.
     * @param options Spesific style or structural options for individual toast
     */
    show(message: LocalizationParam, title?: LocalizationParam | undefined, severity?: Toaster.Severity, options?: Partial<Toaster.ToastOptions>): Toaster.ToasterId;
    /**
     * Removes the toast with given id.
     * @param id ID of the toast to be removed.
     */
    remove: (id: number) => void;
    /**
     * Removes all open toasts at once.
     */
    clear(containerKey?: string): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ToasterService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ToasterService>;
}
type ToasterContract = Strict<ToasterService, Toaster.Service>;

declare class UserMenuService extends AbstractMenuService<UserMenu> {
    protected baseClass: typeof UserMenu;
    static ɵfac: i0.ɵɵFactoryDeclaration<UserMenuService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<UserMenuService>;
}

declare class CreateErrorComponentService {
    protected readonly document: Document;
    protected readonly rendererFactory: RendererFactory2;
    protected readonly routerEvents: RouterEvents;
    protected readonly injector: Injector;
    protected readonly envInjector: EnvironmentInjector;
    protected readonly httpErrorConfig: HttpErrorConfig;
    componentRef: ComponentRef<HttpErrorWrapperComponent> | null;
    constructor();
    protected listenToRouterDataResolved(): void;
    protected getErrorHostElement(): HTMLElement;
    protected isCloseIconHidden(): boolean;
    canCreateCustomError(status: ErrorScreenErrorCodes): boolean;
    execute(instance: Partial<HttpErrorWrapperComponent>): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<CreateErrorComponentService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<CreateErrorComponentService>;
}

declare class AbpFormatErrorHandlerService implements CustomHttpErrorHandlerService {
    readonly priority: 9;
    private confirmationService;
    private authService;
    private error;
    private navigateToLogin;
    canHandle(error: unknown): boolean;
    execute(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbpFormatErrorHandlerService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AbpFormatErrorHandlerService>;
}

declare class TenantResolveErrorHandlerService implements CustomHttpErrorHandlerService {
    protected readonly sessionService: SessionStateService;
    readonly priority: 9;
    private authService;
    private isTenantResolveError;
    canHandle(error: unknown): boolean;
    execute(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TenantResolveErrorHandlerService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TenantResolveErrorHandlerService>;
}

declare class StatusCodeErrorHandlerService implements CustomHttpErrorHandlerService {
    protected readonly confirmationService: ConfirmationService;
    protected readonly createErrorComponentService: CreateErrorComponentService;
    protected readonly authService: AuthService;
    protected readonly handledStatusCodes: readonly [401, 403, 404, 500];
    protected status: (typeof this.handledStatusCodes)[number];
    readonly priority: 0;
    protected navigateToLogin(): void;
    protected showConfirmation(message: LocalizationParam, title: LocalizationParam): Observable<Confirmation.Status>;
    protected showPage(): void;
    canHandle(error: any): boolean;
    execute(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<StatusCodeErrorHandlerService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<StatusCodeErrorHandlerService>;
}

declare class UnknownStatusCodeErrorHandlerService implements CustomHttpErrorHandlerService {
    readonly priority: 0;
    private statusText;
    private message;
    private createErrorComponentService;
    canHandle(error: {
        status: number;
        statusText: string;
        message: string;
    } | undefined): boolean;
    execute(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<UnknownStatusCodeErrorHandlerService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<UnknownStatusCodeErrorHandlerService>;
}

declare class RouterErrorHandlerService {
    protected readonly routerEvents: RouterEvents;
    protected readonly httpErrorConfig: HttpErrorConfig;
    protected readonly createErrorComponentService: CreateErrorComponentService;
    protected filterRouteErrors: (navigationError: NavigationError) => boolean;
    listen(): void;
    show404Page(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<RouterErrorHandlerService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<RouterErrorHandlerService>;
}

declare class AbpAuthenticationErrorHandler implements CustomHttpErrorHandlerService {
    readonly priority: 99;
    protected readonly authService: AuthService;
    protected readonly configStateService: ConfigStateService;
    canHandle(error: unknown): boolean;
    execute(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbpAuthenticationErrorHandler, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AbpAuthenticationErrorHandler>;
}

type ModalSize = 'sm' | 'md' | 'lg' | 'xl';
declare class ModalComponent implements OnInit, OnDestroy, DismissableModal {
    protected readonly confirmationService: ConfirmationService;
    protected readonly modal: NgbModal;
    protected readonly modalRefService: ModalRefService;
    protected readonly suppressUnsavedChangesWarningToken: boolean;
    protected readonly destroyRef: DestroyRef;
    private document;
    visible: i0.ModelSignal<boolean>;
    busy: i0.InputSignalWithTransform<boolean, boolean>;
    options: i0.InputSignal<NgbModalOptions>;
    suppressUnsavedChangesWarning: i0.InputSignal<boolean>;
    modalContent: i0.Signal<TemplateRef<any>>;
    abpHeader: i0.Signal<TemplateRef<any>>;
    abpBody: i0.Signal<TemplateRef<any>>;
    abpFooter: i0.Signal<TemplateRef<any>>;
    abpSubmit: i0.Signal<ButtonComponent>;
    readonly init: i0.OutputEmitterRef<void>;
    readonly appear: i0.OutputEmitterRef<void>;
    readonly disappear: i0.OutputEmitterRef<void>;
    modalRef: NgbModalRef;
    isConfirmationOpen: boolean;
    modalIdentifier: string;
    get modalWindowRef(): Element;
    get isFormDirty(): boolean;
    constructor();
    ngOnInit(): void;
    dismiss(mode: ModalDismissMode): void;
    protected toggle(value: boolean): void;
    ngOnDestroy(): void;
    close(): void;
    listen(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ModalComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ModalComponent, "abp-modal", never, { "visible": { "alias": "visible"; "required": false; "isSignal": true; }; "busy": { "alias": "busy"; "required": false; "isSignal": true; }; "options": { "alias": "options"; "required": false; "isSignal": true; }; "suppressUnsavedChangesWarning": { "alias": "suppressUnsavedChangesWarning"; "required": false; "isSignal": true; }; }, { "visible": "visibleChange"; "init": "init"; "appear": "appear"; "disappear": "disappear"; }, ["abpHeader", "abpBody", "abpFooter", "abpSubmit"], ["*"], true, never>;
}

declare class ToastContainerComponent implements OnInit {
    toasts$: ReplaySubject<Toaster.Toast[]>;
    remove: (toastId: number) => void;
    toasts: Toaster.Toast[];
    top?: string;
    right: string;
    defaultRight: string;
    defaultMobileRight: string;
    bottom: string;
    left?: string;
    toastKey?: string;
    ngOnInit(): void;
    onWindowResize(): void;
    setDefaultRight(): void;
    trackByFunc(index: number, toast: Toaster.Toast): any;
    static ɵfac: i0.ɵɵFactoryDeclaration<ToastContainerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ToastContainerComponent, "abp-toast-container", never, { "top": { "alias": "top"; "required": false; }; "right": { "alias": "right"; "required": false; }; "bottom": { "alias": "bottom"; "required": false; }; "left": { "alias": "left"; "required": false; }; "toastKey": { "alias": "toastKey"; "required": false; }; }, {}, never, never, true, never>;
}

declare class ToastComponent implements OnInit {
    toast: Toaster.Toast;
    remove: EventEmitter<number>;
    get severityClass(): string;
    get iconClass(): string;
    ngOnInit(): void;
    close(): void;
    tap(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ToastComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ToastComponent, "abp-toast", never, { "toast": { "alias": "toast"; "required": false; }; }, { "remove": "remove"; }, never, never, true, never>;
}

/**
 * @deprecated use ShowPasswordDirective directive
 * https://abp.io/docs/latest/framework/ui/angular/show-password-directive
 */
declare class PasswordComponent extends AbstractNgModelComponent {
    inputId: string;
    formControlName: string;
    fieldTextType?: boolean;
    toggleFieldTextType(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<PasswordComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<PasswordComponent, "abp-password", never, { "inputId": { "alias": "inputId"; "required": false; }; "formControlName": { "alias": "formControlName"; "required": false; }; }, {}, never, never, true, never>;
}

declare class CardBodyComponent {
    componentClass: string;
    cardBodyClass: string;
    cardBodyStyle: string;
    static ɵfac: i0.ɵɵFactoryDeclaration<CardBodyComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CardBodyComponent, "abp-card-body", never, { "cardBodyClass": { "alias": "cardBodyClass"; "required": false; }; "cardBodyStyle": { "alias": "cardBodyStyle"; "required": false; }; }, {}, never, ["*"], true, never>;
}

declare class CardComponent {
    cardClass: string;
    cardStyle: string;
    static ɵfac: i0.ɵɵFactoryDeclaration<CardComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CardComponent, "abp-card", never, { "cardClass": { "alias": "cardClass"; "required": false; }; "cardStyle": { "alias": "cardStyle"; "required": false; }; }, {}, never, ["*"], true, never>;
}

declare class CardHeaderComponent {
    componentClass: string;
    cardHeaderClass: string;
    cardHeaderStyle: string;
    static ɵfac: i0.ɵɵFactoryDeclaration<CardHeaderComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CardHeaderComponent, "abp-card-header", never, { "cardHeaderClass": { "alias": "cardHeaderClass"; "required": false; }; "cardHeaderStyle": { "alias": "cardHeaderStyle"; "required": false; }; }, {}, never, ["*"], true, never>;
}

declare class CardFooterComponent {
    componentClass: string;
    cardFooterStyle: string;
    cardFooterClass: string;
    static ɵfac: i0.ɵɵFactoryDeclaration<CardFooterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<CardFooterComponent, "abp-card-footer", never, { "cardFooterStyle": { "alias": "cardFooterStyle"; "required": false; }; "cardFooterClass": { "alias": "cardFooterClass"; "required": false; }; }, {}, never, ["*"], true, never>;
}

declare class CardTitleDirective {
    directiveClass: string;
    static ɵfac: i0.ɵɵFactoryDeclaration<CardTitleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<CardTitleDirective, "abp-card-title, [abp-card-title], [abpCardTitle]", never, {}, {}, never, never, true, never>;
}

declare class CardSubtitleDirective {
    directiveClass: string;
    static ɵfac: i0.ɵɵFactoryDeclaration<CardSubtitleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<CardSubtitleDirective, "abp-card-subtitle, [abp-card-subtitle], [abpCardSubtitle]", never, {}, {}, never, never, true, never>;
}

declare class CardImgTopDirective {
    directiveClass: string;
    static ɵfac: i0.ɵɵFactoryDeclaration<CardImgTopDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<CardImgTopDirective, "abp-card-img-top, [abp-card-img-top], [abpCardImgTop]", never, {}, {}, never, never, true, never>;
}

declare class CardHeaderDirective {
    directiveClass: string;
    static ɵfac: i0.ɵɵFactoryDeclaration<CardHeaderDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<CardHeaderDirective, "abp-card-header, [abp-card-header], [abpCardHeader]", never, {}, {}, never, never, true, never>;
}

declare const CARD_DIRECTIVES: (typeof CardTitleDirective)[];
declare const CARD_COMPONENTS: (typeof CardBodyComponent | typeof CardComponent | typeof CardHeaderComponent | typeof CardFooterComponent)[];
declare class CardModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<CardModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<CardModule, never, [typeof CardComponent, typeof CardBodyComponent, typeof CardHeaderComponent, typeof CardFooterComponent, typeof CardTitleDirective, typeof CardSubtitleDirective, typeof CardImgTopDirective, typeof CardHeaderDirective], [typeof CardComponent, typeof CardBodyComponent, typeof CardHeaderComponent, typeof CardFooterComponent, typeof CardTitleDirective, typeof CardSubtitleDirective, typeof CardImgTopDirective, typeof CardHeaderDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<CardModule>;
}

declare class FormCheckboxComponent extends AbstractNgModelComponent {
    label?: string;
    labelClass: string;
    checkboxId: string;
    checkboxStyle: {
        [klass: string]: any;
    } | null | undefined;
    checkboxClass: string;
    checkboxReadonly: boolean;
    checkboxBlur: EventEmitter<void>;
    checkboxFocus: EventEmitter<void>;
    static ɵfac: i0.ɵɵFactoryDeclaration<FormCheckboxComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<FormCheckboxComponent, "abp-checkbox", never, { "label": { "alias": "label"; "required": false; }; "labelClass": { "alias": "labelClass"; "required": false; }; "checkboxId": { "alias": "checkboxId"; "required": false; }; "checkboxStyle": { "alias": "checkboxStyle"; "required": false; }; "checkboxClass": { "alias": "checkboxClass"; "required": false; }; "checkboxReadonly": { "alias": "checkboxReadonly"; "required": false; }; }, { "checkboxBlur": "checkboxBlur"; "checkboxFocus": "checkboxFocus"; }, never, never, true, never>;
}

declare class FormInputComponent extends AbstractNgModelComponent {
    inputId: string;
    inputReadonly: boolean;
    label: string;
    labelClass: string;
    inputPlaceholder: string;
    inputStyle: {
        [klass: string]: any;
    } | null | undefined;
    inputClass: string;
    formBlur: EventEmitter<void>;
    formFocus: EventEmitter<void>;
    static ɵfac: i0.ɵɵFactoryDeclaration<FormInputComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<FormInputComponent, "abp-form-input", never, { "inputId": { "alias": "inputId"; "required": false; }; "inputReadonly": { "alias": "inputReadonly"; "required": false; }; "label": { "alias": "label"; "required": false; }; "labelClass": { "alias": "labelClass"; "required": false; }; "inputPlaceholder": { "alias": "inputPlaceholder"; "required": false; }; "inputStyle": { "alias": "inputStyle"; "required": false; }; "inputClass": { "alias": "inputClass"; "required": false; }; }, { "formBlur": "formBlur"; "formFocus": "formFocus"; }, never, never, true, never>;
}

declare class InternetConnectionStatusComponent {
    internetConnectionService: InternetConnectionService;
    isOnline: i0.Signal<boolean>;
    static ɵfac: i0.ɵɵFactoryDeclaration<InternetConnectionStatusComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<InternetConnectionStatusComponent, "abp-internet-status", never, {}, {}, never, never, true, never>;
}

declare class SpinnerComponent {
    static ɵfac: i0.ɵɵFactoryDeclaration<SpinnerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<SpinnerComponent, "abp-spinner", never, {}, {}, never, never, true, never>;
}

declare class EllipsisDirective implements AfterViewInit {
    private cdRef;
    private elRef;
    width?: string;
    title?: string;
    enabled: boolean;
    get inlineClass(): string;
    get class(): boolean;
    get maxWidth(): string;
    ngAfterViewInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<EllipsisDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<EllipsisDirective, "[abpEllipsis]", never, { "width": { "alias": "abpEllipsis"; "required": false; }; "title": { "alias": "title"; "required": false; }; "enabled": { "alias": "abpEllipsisEnabled"; "required": false; }; }, {}, never, never, true, never>;
}

declare class LoadingDirective implements OnInit, OnDestroy {
    private elRef;
    private cdRes;
    private injector;
    private renderer;
    private _loading;
    position: string;
    get loading(): boolean;
    set loading(newValue: boolean);
    targetElement: HTMLElement | undefined;
    delay: number;
    componentRef: ComponentRef<LoadingComponent>;
    rootNode: HTMLDivElement | null;
    timerSubscription: Subscription | null;
    ngOnInit(): void;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<LoadingDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<LoadingDirective, "[abpLoading]", never, { "loading": { "alias": "abpLoading"; "required": false; }; "targetElement": { "alias": "abpLoadingTargetElement"; "required": false; }; "delay": { "alias": "abpLoadingDelay"; "required": false; }; }, {}, never, never, true, never>;
}

declare class NgxDatatableDefaultDirective implements AfterViewInit, OnDestroy {
    private table;
    private document;
    private platformId;
    private subscription;
    private resizeDiff;
    class: string;
    get classes(): string;
    constructor();
    private fixHorizontalGap;
    private fixStyleOnWindowResize;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxDatatableDefaultDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgxDatatableDefaultDirective, "ngx-datatable[default]", ["ngxDatatableDefault"], { "class": { "alias": "class"; "required": false; }; }, {}, never, never, true, never>;
}

interface NgxDatatableMessages {
    emptyMessage: string;
    errorMessage: string;
    totalMessage: string;
    selectedMessage: string;
}
declare const defaultNgxDatatableMessages: {
    emptyMessage: string;
    errorMessage: string;
    totalMessage: string;
    selectedMessage: string;
};
declare const NGX_DATATABLE_MESSAGES: InjectionToken<Partial<NgxDatatableMessages>>;

declare class NgxDatatableListDirective implements OnChanges, OnInit, DoCheck {
    protected readonly table: DatatableComponent<any>;
    protected readonly cdRef: ChangeDetectorRef;
    protected readonly destroyRef: DestroyRef;
    protected readonly localizationService: LocalizationService;
    protected readonly ngxDatatableMessages: Partial<NgxDatatableMessages>;
    protected readonly viewContainerRef: ViewContainerRef;
    protected readonly renderer: Renderer2;
    list: ListService;
    constructor();
    ngDoCheck(): void;
    ngOnInit(): void;
    ngOnChanges({ list }: SimpleChanges): void;
    protected subscribeToRequestStatus(): void;
    protected updateLoadingIndicator(): void;
    protected replaceLoadingIndicator(parent: Element, placeholder: Element): void;
    protected setInitialValues(): void;
    protected subscribeToSort(): void;
    protected subscribeToPage(): void;
    protected subscribeToQuery(): void;
    protected setTablePage(pageNum: number): void;
    protected refreshPageIfDataExist(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxDatatableListDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgxDatatableListDirective, "ngx-datatable[list]", ["ngxDatatableList"], { "list": { "alias": "list"; "required": false; }; }, {}, never, never, true, never>;
}

declare class AbpVisibleDirective implements OnDestroy, OnInit {
    private viewContainerRef;
    private templateRef;
    conditionSubscription: Subscription | undefined;
    isVisible: boolean | undefined;
    set abpVisible(value: boolean | Promise<boolean> | Observable<boolean> | undefined | null);
    private condition$;
    ngOnInit(): void;
    ngOnDestroy(): void;
    private subscribeToCondition;
    private updateVisibility;
    static ɵfac: i0.ɵɵFactoryDeclaration<AbpVisibleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<AbpVisibleDirective, "[abpVisible]", never, { "abpVisible": { "alias": "abpVisible"; "required": false; }; }, {}, never, never, true, never>;
}

declare class DisabledDirective implements OnChanges {
    private ngControl;
    abpDisabled: boolean;
    ngOnChanges({ abpDisabled }: SimpleChanges): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DisabledDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DisabledDirective, "[abpDisabled]", never, { "abpDisabled": { "alias": "abpDisabled"; "required": false; }; }, {}, never, never, true, never>;
}

declare enum eFormComponets {
    FormInputComponent = "FormInputComponent",
    FormCheckboxComponent = "FormCheckboxComponent"
}

declare const enum eThemeSharedRouteNames {
    Administration = "AbpUiNavigation::Menu:Administration"
}

declare class DocumentDirHandlerService {
    protected injector: Injector;
    private dir;
    dir$: rxjs.Observable<LocaleDirection>;
    constructor();
    private listenToLanguageChanges;
    private setBodyDir;
    static ɵfac: i0.ɵɵFactoryDeclaration<DocumentDirHandlerService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<DocumentDirHandlerService>;
}

declare class ErrorHandler {
    protected injector: Injector;
    protected readonly httpErrorReporter: HttpErrorReporterService;
    protected readonly confirmationService: ConfirmationService;
    protected readonly routerErrorHandlerService: RouterErrorHandlerService;
    protected readonly httpErrorConfig: HttpErrorConfig;
    protected readonly customErrorHandlers: CustomHttpErrorHandlerService[];
    protected readonly httpErrorHandler: HttpErrorHandler;
    constructor();
    protected listenToRouterError(): void;
    protected listenToRestError(): void;
    protected executeErrorHandler: (error: HttpErrorResponse) => Observable<any>;
    protected sortHttpErrorHandlers(a: CustomHttpErrorHandlerService, b: CustomHttpErrorHandlerService): number;
    protected handleError(err: unknown): void;
    protected showError(): Observable<Confirmation.Status>;
    protected filterRestErrors: ({ status }: HttpErrorResponse) => boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<ErrorHandler, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ErrorHandler>;
}

declare const NG_BOOTSTRAP_CONFIG_PROVIDERS: (i0.EnvironmentProviders | {
    provide: typeof NgbDatepickerI18n;
    useClass: typeof DatepickerI18nAdapter;
} | {
    provide: typeof NgbTimepickerI18n;
    useClass: typeof TimepickerI18nAdapter;
})[];
declare function configureNgBootstrap(): void;

declare const THEME_SHARED_ROUTE_PROVIDERS: i0.EnvironmentProviders[];
declare function configureRoutes(): void;

declare const tenantNotFoundProvider: Provider;

declare const DEFAULT_HANDLERS_PROVIDERS: Provider[];

declare const THEME_SHARED_APPEND_CONTENT: InjectionToken<void>;

declare const HTTP_ERROR_CONFIG: InjectionToken<HttpErrorConfig>;
/**
  @deprecated use **`CUSTOM_ERROR_HANDLERS`** injection token instead of this, see more info https://abp.io/docs/latest/framework/ui/angular/http-requests
*/
declare const HTTP_ERROR_HANDLER: InjectionToken<HttpErrorHandler>;
declare const CUSTOM_ERROR_HANDLERS: InjectionToken<CustomHttpErrorHandlerService[]>;

declare const SUPPRESS_UNSAVED_CHANGES_WARNING: InjectionToken<boolean>;

declare const LOGO_URL_TOKEN: InjectionToken<string>;
declare const LOGO_APP_NAME_TOKEN: InjectionToken<string>;

declare enum ThemeSharedFeatureKind {
    HttpErrorConfig = 0,
    ValidationBluePrint = 1,
    ValidationErrorsFn = 2,
    ValidateOnSubmit = 3,
    Validation = 4,
    ConfirmationIcons = 5
}
interface ThemeSharedFeature<KindT extends ThemeSharedFeatureKind> {
    ɵkind: KindT;
    ɵproviders: Provider[];
}
declare function withHttpErrorConfig(httpErrorConfig: HttpErrorConfig): ThemeSharedFeature<ThemeSharedFeatureKind.HttpErrorConfig>;
declare function withValidationBluePrint(bluePrints: Validation.Blueprints): ThemeSharedFeature<ThemeSharedFeatureKind.ValidationBluePrint>;
declare function withValidationMapErrorsFn(mapErrorsFn: Validation.MapErrorsFn): ThemeSharedFeature<ThemeSharedFeatureKind.ValidationErrorsFn>;
declare function withValidateOnSubmit(validateOnSubmit: boolean): ThemeSharedFeature<ThemeSharedFeatureKind.ValidateOnSubmit>;
declare function withConfirmationIcon(confirmationIcons: Partial<ConfirmationIcons>): ThemeSharedFeature<ThemeSharedFeatureKind.HttpErrorConfig>;
declare function provideAbpThemeShared(...features: ThemeSharedFeature<ThemeSharedFeatureKind>[]): i0.EnvironmentProviders;

declare enum LogoFeatureKind {
    Options = 0
}
interface LogoFeature<KindT extends LogoFeatureKind> {
    ɵkind: KindT;
    ɵproviders: (Provider | EnvironmentProviders)[];
}
declare function withEnvironmentOptions(options?: Environment): LogoFeature<LogoFeatureKind.Options>;
declare function provideLogo(...features: LogoFeature<LogoFeatureKind>[]): EnvironmentProviders;

declare const THEME_SHARED_EXPORTS: (typeof LoadingComponent)[];
declare class BaseThemeSharedModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<BaseThemeSharedModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<BaseThemeSharedModule, never, [typeof BreadcrumbComponent, typeof BreadcrumbItemsComponent, typeof ButtonComponent, typeof ConfirmationComponent, typeof LoaderBarComponent, typeof LoadingComponent, typeof ModalComponent, typeof ToastComponent, typeof ToastContainerComponent, typeof LoadingDirective, typeof ModalCloseDirective, typeof FormInputComponent, typeof FormCheckboxComponent, typeof HttpErrorWrapperComponent, typeof i15.NgxDatatableModule, typeof i16.NgxValidateCoreModule, typeof CardModule, typeof DisabledDirective, typeof AbpVisibleDirective, typeof NgxDatatableListDirective, typeof NgxDatatableDefaultDirective, typeof PasswordComponent], [typeof BreadcrumbComponent, typeof BreadcrumbItemsComponent, typeof ButtonComponent, typeof ConfirmationComponent, typeof LoaderBarComponent, typeof LoadingComponent, typeof ModalComponent, typeof ToastComponent, typeof ToastContainerComponent, typeof LoadingDirective, typeof ModalCloseDirective, typeof FormInputComponent, typeof FormCheckboxComponent, typeof HttpErrorWrapperComponent, typeof i15.NgxDatatableModule, typeof i16.NgxValidateCoreModule, typeof CardModule, typeof DisabledDirective, typeof AbpVisibleDirective, typeof NgxDatatableListDirective, typeof NgxDatatableDefaultDirective, typeof PasswordComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<BaseThemeSharedModule>;
}
declare class ThemeSharedModule {
    /**
     * @deprecated forRoot method is deprecated, use `provideAbpThemeShared` *function* for config settings.
     */
    static forRoot({ httpErrorConfig, validation, confirmationIcons }?: RootParams): ModuleWithProviders<ThemeSharedModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<ThemeSharedModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<ThemeSharedModule, never, [typeof BaseThemeSharedModule], [typeof BaseThemeSharedModule]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<ThemeSharedModule>;
}

declare class DateParserFormatter extends NgbDateParserFormatter {
    private configState;
    private locale;
    constructor();
    parse(value: string): NgbDateStruct | null;
    format(date: NgbDateStruct): string;
    static ɵfac: i0.ɵɵFactoryDeclaration<DateParserFormatter, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<DateParserFormatter>;
}

declare function getPasswordValidators(injector: Injector): ValidatorFn[];
declare function validatePassword(shouldContain: PasswordRule): ValidatorFn;

declare function getErrorFromRequestBody(body: {
    details?: string;
    message?: string;
} | undefined): {
    message: LocalizationParam;
    title: LocalizationParam;
};

declare const DEFAULT_VALIDATION_BLUEPRINTS: {
    creditCard: string;
    email: string;
    invalid: string;
    max: string;
    maxlength: string;
    min: string;
    minlength: string;
    ngbDate: string;
    passwordMismatch: string;
    range: string;
    required: string;
    url: string;
    passwordRequiresLower: string;
    passwordRequiresUpper: string;
    passwordRequiresDigit: string;
    passwordRequiresNonAlphanumeric: string;
    usernamePattern: string;
    customMessage: string;
};

declare const DEFAULT_ERROR_MESSAGES: {
    defaultError: {
        title: string;
        details: string;
    };
    defaultError401: {
        title: string;
        details: string;
    };
    defaultError403: {
        title: string;
        details: string;
    };
    defaultError404: {
        title: string;
        details: string;
    };
    defaultError500: {
        title: string;
        details: string;
    };
};
declare const DEFAULT_ERROR_LOCALIZATIONS: {
    defaultError: {
        title: string;
        details: string;
    };
    defaultError401: {
        title: string;
        details: string;
    };
    defaultError403: {
        title: string;
        details: string;
    };
    defaultError404: {
        title: string;
        details: string;
    };
    defaultError500: {
        title: string;
        details: string;
    };
};
declare const CUSTOM_HTTP_ERROR_HANDLER_PRIORITY: Readonly<{
    veryLow: -99;
    low: -9;
    normal: 0;
    high: 9;
    veryHigh: 99;
}>;
declare const HTTP_ERROR_STATUS: {
    '401': string;
    '403': string;
    '404': string;
    '500': string;
};
declare const HTTP_ERROR_DETAIL: {
    '401': string;
    '403': string;
    '404': string;
    '500': string;
};

export { AbpAuthenticationErrorHandler, AbpFormatErrorHandlerService, AbpVisibleDirective, BaseThemeSharedModule, BreadcrumbComponent, BreadcrumbItemsComponent, ButtonComponent, CARD_COMPONENTS, CARD_DIRECTIVES, CONFIRMATION_ICONS, CUSTOM_ERROR_HANDLERS, CUSTOM_HTTP_ERROR_HANDLER_PRIORITY, CardBodyComponent, CardComponent, CardFooterComponent, CardHeaderComponent, CardHeaderDirective, CardImgTopDirective, CardModule, CardSubtitleDirective, CardTitleDirective, Confirmation, ConfirmationComponent, ConfirmationService, CreateErrorComponentService, DEFAULT_CONFIRMATION_ICONS, DEFAULT_ERROR_LOCALIZATIONS, DEFAULT_ERROR_MESSAGES, DEFAULT_HANDLERS_PROVIDERS, DEFAULT_VALIDATION_BLUEPRINTS, DateAdapter, DateParserFormatter, DateTimeAdapter, DatepickerI18nAdapter, DisabledDirective, DocumentDirHandlerService, EllipsisDirective, ErrorHandler, FormCheckboxComponent, FormInputComponent, HTTP_ERROR_CONFIG, HTTP_ERROR_DETAIL, HTTP_ERROR_HANDLER, HTTP_ERROR_STATUS, HttpErrorWrapperComponent, InternetConnectionStatusComponent, LOGO_APP_NAME_TOKEN, LOGO_URL_TOKEN, LoaderBarComponent, LoadingComponent, LoadingDirective, LogoFeatureKind, ModalCloseDirective, ModalComponent, ModalRefService, NGX_DATATABLE_MESSAGES, NG_BOOTSTRAP_CONFIG_PROVIDERS, NavItem, NavItemsService, NgxDatatableDefaultDirective, NgxDatatableListDirective, PageAlertService, PasswordComponent, RouterErrorHandlerService, SUPPRESS_UNSAVED_CHANGES_WARNING, SpinnerComponent, Statistics, StatusCodeErrorHandlerService, THEME_SHARED_APPEND_CONTENT, THEME_SHARED_EXPORTS, THEME_SHARED_ROUTE_PROVIDERS, TenantResolveErrorHandlerService, ThemeSharedFeatureKind, ThemeSharedModule, TimeAdapter, TimepickerI18nAdapter, ToastComponent, ToastContainerComponent, Toaster, ToasterService, UnknownStatusCodeErrorHandlerService, UserMenu, UserMenuService, bounceIn, collapse, collapseLinearWithMargin, collapseWithMargin, collapseX, collapseY, collapseYWithMargin, configureNgBootstrap, configureRoutes, defaultNgxDatatableMessages, dialogAnimation, eFormComponets, eThemeSharedRouteNames, expandX, expandY, expandYWithMargin, fadeAnimation, fadeIn, fadeInDown, fadeInLeft, fadeInRight, fadeInUp, fadeOut, fadeOutDown, fadeOutLeft, fadeOutRight, fadeOutUp, getErrorFromRequestBody, getPasswordValidators, provideAbpThemeShared, provideLogo, slideFromBottom, tenantNotFoundProvider, toastInOut, validatePassword, withConfirmationIcon, withEnvironmentOptions, withHttpErrorConfig, withValidateOnSubmit, withValidationBluePrint, withValidationMapErrorsFn };
export type { Badge, ConfirmationIcons, CustomHttpErrorHandlerService, DismissableModal, ErrorScreenErrorCodes, HttpErrorConfig, HttpErrorHandler, LocaleDirection, LogoFeature, ModalDismissMode, ModalSize, NavBarPropPredicate, NgxDatatableMessages, PageAlert, PasswordRule, RootParams, ThemeSharedFeature, ToasterContract, UserMenuTextTemplate };
